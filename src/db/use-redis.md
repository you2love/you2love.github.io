# 一、Redis常见用途

## 1. 核心用途：缓存

**应用场景**：缓存电商商品详情、用户信息、首页热点数据、复杂查询结果，减轻数据库压力，提升系统响应速度。

**常用数据结构**：String（缓存单个对象）、Hash（缓存结构化对象，避免序列化开销）。

**最佳实践**：采用Cache Aside策略保证缓存与数据库一致性；设置随机过期时间避免缓存雪崩。

## 2. 计数器/限流器

**应用场景**：视频播放量、文章阅读量、点赞数、商品库存扣减、接口限流（单用户时间窗口内请求控制）、秒杀防超卖。

**核心优势**：INCR/DECR命令原子性，无并发计数错误；支持过期时间，适配时间窗口统计。

**常用命令**：INCR/DECR（增减计数）、EXPIRE（设置时间窗口）、SET key value NX（限流判断）。

## 3. 分布式锁

**应用场景**：秒杀超卖防护、订单重复生成、分布式系统多节点资源竞争、数据同步一致性保障。

**核心原理**：获取锁用SET key 唯一值 NX PX 过期时间（NX保证独占，PX防死锁）；释放锁用Lua脚本原子操作（校验唯一值后删除，避免误删）。

**进阶方案**：Redisson框架（自带Watch Dog自动续期）；多节点场景用Redlock算法规避单点故障。

## 4. 消息队列（轻量级场景）

**应用场景**：异步任务（注册短信/邮件发送）、系统解耦（订单-库存联动）、延迟队列（订单30分钟未支付取消、优惠券过期提醒）。

**实现方式**：

- List：LPUSH生产消息，RPOP/BRPOP阻塞消费（避免轮询）；

- Pub/Sub：一对多广播，适用于实时通知、聊天室；

- Sorted Set：以过期时间为score，ZRANGEBYSCORE获取到期消息，实现延迟队列。

## 5. 数据去重与统计

|场景|数据结构|核心优势|
|---|---|---|
|共同好友、抽奖去重、标签交集|Set|支持SINTER（交集）、SUNION（并集）、SDIFF（差集）|
|独立UV统计（日活、页面访问人数）|HyperLogLog|仅占12KB内存，支持亿级数据基数估算|
|签到统计、用户在线状态|Bitmap|按位存储，1字节存8个状态，高效节省内存|
## 6. 分布式会话存储

**应用场景**：分布式系统中解决Session共享问题（替代Tomcat本地会话，避免请求跨节点会话丢失）。

**核心优势**：支持过期时间配置，会话有效期可控；高性能，支撑高并发访问。

## 7. 排行榜系统

**应用场景**：游戏积分榜、商品销量榜、直播礼物榜、用户贡献榜。

**核心优势**：Sorted Set自动按score排序，支持实时更新；ZREVRANGE查前N名、ZRANK查用户排名，百万级数据毫秒级响应。

# 二、Redis高频问题及核心答案

## （一）基础概念类

1. **Redis是什么？核心特点？**
答：开源基于内存的Key-Value NoSQL数据库，支持持久化、高可用和分布式扩展。核心特点：内存操作快、丰富数据结构、RDB/AOF持久化、主从/哨兵/集群高可用、单线程模型（IO阶段）、支持Lua脚本/发布订阅。

2. **Redis与Memcached的区别？**
答：数据结构上Redis支持多类型，Memcached仅String；持久化上Redis支持，Memcached不支持；高可用上Redis有原生方案，Memcached需第三方；内存管理Redis淘汰策略更优，Memcached碎片率高。

3. **Redis为什么快？**
答：① 基于内存，无磁盘IO瓶颈；② 单线程模型，无线程切换和锁竞争；③ IO多路复用技术，高效处理多连接；④ 高效数据结构（SDS、跳表等）；⑤ 无上下文切换开销。

## （二）核心数据结构类

1. **Redis支持的核心数据结构及底层实现、场景？**数据结构底层实现典型场景StringSDS（简单动态字符串）缓存、计数器、分布式锁Hashziplist→hashtable缓存结构化对象（用户信息）Listziplist→quicklist消息队列、最新列表Setintset→hashtable去重、交集/并集计算Sorted Setziplist→跳表+hashtable排行榜、延迟队列

2. **Sorted Set分数范围及注意事项？**
答：分数为double类型，范围±1.7976931348623157×10³⁰⁸；有效精度15-17位，整数超9×10¹⁵会丢失精度；相同分数按member字典序排序。

3. **跳表原理？Sorted Set为何选跳表而非红黑树？**
答：跳表通过多级索引快速定位，查询O(logN)；优势：范围查询更高效、实现简单、插入/删除性能稳定（红黑树需维护平衡）。

## （三）持久化机制类

1. **RDB与AOF的区别、优缺点？**特性RDB（快照）AOF（追加日志）原理定期将全量数据写入磁盘记录每一条写命令，重启重放优点文件小、恢复快、性能影响小数据安全高、日志可读缺点数据一致性差，易丢失中间数据文件大、恢复慢、写操作有开销

2. **混合持久化是什么？优势？**
答：Redis4.0+支持，AOF重写时将内存数据以RDB格式写入AOF开头，后续命令以AOF追加；结合RDB恢复快和AOF数据全的优点。

## （四）高可用架构类

1. **主从复制原理？**
答：分三阶段：① 全量复制：从库发SYNC，主库BGSAVE生成RDB并缓存写命令，同步给从库；② 增量复制：全量后主库实时同步写命令；③ 断线重连：通过偏移量和积压缓冲区增量同步。

2. **哨兵模式的作用及工作流程？**
答：作用：监控主从健康，自动故障转移。流程：① 监控（PING检测节点）；② 主观下线（单哨兵判定主库宕机）；③ 客观下线（多哨兵共识）；④ 选举领头哨兵；⑤ 故障转移（从库升主、同步地址）。

3. **Redis Cluster槽位分配规则？**
答：共16384个哈希槽；Key通过CRC16(key)%16384计算槽位；槽位分配给节点，通过Gossip协议同步槽位信息；客户端按槽位映射表访问节点。

## （五）缓存问题与解决方案类

1. **缓存穿透、击穿、雪崩的定义及解决方案？**

    - 穿透：查缓存和DB都不存在的Key→缓存空值、布隆过滤器、接口校验；

    - 击穿：热点Key过期，大量请求穿透→热点Key永不过期、互斥锁、提前预热；

    - 雪崩：大量Key同时过期或Redis宕机→过期时间随机化、多级缓存、Redis高可用、限流降级。

2. **如何保证缓存与数据库一致性？**
答：推荐Cache Aside策略：读（缓存→DB→写缓存）；写（更DB→删缓存）；删除失败用重试机制或消息队列保证最终一致。

## （六）高级特性与性能优化类

1. **过期策略与内存淘汰机制？**
答：过期策略：惰性删除（访问时检查）+定期删除（随机抽样删除）；内存淘汰机制（maxmemory-policy）：volatile-lru（过期Key中LRU）、allkeys-lru（所有Key中LRU，生产常用）、noeviction（默认，拒绝写）。

2. **Redis性能优化手段？**

    * 避免大Key，拆分结构化数据；
    * 用Pipeline减少网络往返；
    * AOF刷盘策略设为everysec；
    * 合理配置LRU淘汰策略；
    * 禁用KEYS、FLUSHDB，用SCAN遍历；
    * 优化连接参数（tcp-backlog等）。
