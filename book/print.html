<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>技术博客</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="记录技术积累">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="web.html"><strong aria-hidden="true">1.</strong> web</a></li><li class="chapter-item expanded "><a href="mac.html"><strong aria-hidden="true">2.</strong> mac</a></li><li class="chapter-item expanded "><a href="docker/docker.html"><strong aria-hidden="true">3.</strong> docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docker/python.html"><strong aria-hidden="true">3.1.</strong> python</a></li></ol></li><li class="chapter-item expanded "><a href="nginx/index.html"><strong aria-hidden="true">4.</strong> nginx</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nginx/install.html"><strong aria-hidden="true">4.1.</strong> 源码安装剖析</a></li><li class="chapter-item expanded "><a href="nginx/http.html"><strong aria-hidden="true">4.2.</strong> HTTP模块</a></li><li class="chapter-item expanded "><a href="nginx/use.html"><strong aria-hidden="true">4.3.</strong> 常用技巧</a></li><li class="chapter-item expanded "><a href="nginx/rtmp.html"><strong aria-hidden="true">4.4.</strong> rtmp</a></li></ol></li><li class="chapter-item expanded "><a href="golang/golang.html"><strong aria-hidden="true">5.</strong> golang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="golang/grpc.html"><strong aria-hidden="true">5.1.</strong> grpc</a></li><li class="chapter-item expanded "><a href="golang/code.html"><strong aria-hidden="true">5.2.</strong> code</a></li><li class="chapter-item expanded "><a href="golang/context.html"><strong aria-hidden="true">5.3.</strong> context</a></li><li class="chapter-item expanded "><a href="golang/echo.html"><strong aria-hidden="true">5.4.</strong> echo</a></li><li class="chapter-item expanded "><a href="golang/freetype.html"><strong aria-hidden="true">5.5.</strong> freetype</a></li><li class="chapter-item expanded "><a href="golang/generic.html"><strong aria-hidden="true">5.6.</strong> generic</a></li><li class="chapter-item expanded "><a href="golang/gin.html"><strong aria-hidden="true">5.7.</strong> gin</a></li><li class="chapter-item expanded "><a href="golang/go-git.html"><strong aria-hidden="true">5.8.</strong> go-git</a></li><li class="chapter-item expanded "><a href="golang/groupby.html"><strong aria-hidden="true">5.9.</strong> groupby</a></li><li class="chapter-item expanded "><a href="golang/io.html"><strong aria-hidden="true">5.10.</strong> io</a></li><li class="chapter-item expanded "><a href="golang/iris.html"><strong aria-hidden="true">5.11.</strong> iris</a></li><li class="chapter-item expanded "><a href="golang/log.html"><strong aria-hidden="true">5.12.</strong> log</a></li><li class="chapter-item expanded "><a href="golang/package.html"><strong aria-hidden="true">5.13.</strong> package</a></li><li class="chapter-item expanded "><a href="golang/regexp.html"><strong aria-hidden="true">5.14.</strong> regexp</a></li><li class="chapter-item expanded "><a href="golang/shell.html"><strong aria-hidden="true">5.15.</strong> shell</a></li><li class="chapter-item expanded "><a href="golang/sort.html"><strong aria-hidden="true">5.16.</strong> sort</a></li><li class="chapter-item expanded "><a href="golang/stringer.html"><strong aria-hidden="true">5.17.</strong> stringer</a></li></ol></li><li class="chapter-item expanded "><a href="python/python.html"><strong aria-hidden="true">6.</strong> python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python/fabric.html"><strong aria-hidden="true">6.1.</strong> fabric</a></li><li class="chapter-item expanded "><a href="python/fastapi.html"><strong aria-hidden="true">6.2.</strong> fastapi</a></li><li class="chapter-item expanded "><a href="python/memcached.html"><strong aria-hidden="true">6.3.</strong> memcached</a></li><li class="chapter-item expanded "><a href="python/numpy.html"><strong aria-hidden="true">6.4.</strong> numpy</a></li><li class="chapter-item expanded "><a href="python/ocr.html"><strong aria-hidden="true">6.5.</strong> ocr</a></li><li class="chapter-item expanded "><a href="python/paddleocr.html"><strong aria-hidden="true">6.6.</strong> paddleocr</a></li><li class="chapter-item expanded "><a href="python/redis.html"><strong aria-hidden="true">6.7.</strong> redis</a></li><li class="chapter-item expanded "><a href="python/requests.html"><strong aria-hidden="true">6.8.</strong> requests</a></li><li class="chapter-item expanded "><a href="python/httpx.html"><strong aria-hidden="true">6.9.</strong> httpx</a></li><li class="chapter-item expanded "><a href="python/opencv.html"><strong aria-hidden="true">6.10.</strong> opencv</a></li><li class="chapter-item expanded "><a href="python/js2py.html"><strong aria-hidden="true">6.11.</strong> js2py</a></li><li class="chapter-item expanded "><a href="python/woff.html"><strong aria-hidden="true">6.12.</strong> woff</a></li><li class="chapter-item expanded "><a href="python/svg.html"><strong aria-hidden="true">6.13.</strong> svg</a></li></ol></li><li class="chapter-item expanded "><a href="c++/c++.html"><strong aria-hidden="true">7.</strong> c++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c++/lz78.html"><strong aria-hidden="true">7.1.</strong> lz78算法</a></li><li class="chapter-item expanded "><a href="c++/perm.html"><strong aria-hidden="true">7.2.</strong> 排列生成</a></li><li class="chapter-item expanded "><a href="c++/random.html"><strong aria-hidden="true">7.3.</strong> 随机数生成</a></li></ol></li><li class="chapter-item expanded "><a href="memcached.html"><strong aria-hidden="true">8.</strong> memcached</a></li><li class="chapter-item expanded "><a href="redis.html"><strong aria-hidden="true">9.</strong> redis</a></li><li class="chapter-item expanded "><a href="mysql.html"><strong aria-hidden="true">10.</strong> mysql</a></li><li class="chapter-item expanded "><a href="markdown.html"><strong aria-hidden="true">11.</strong> markdown</a></li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">12.</strong> rust</a></li><li class="chapter-item expanded "><a href="unity/unity.html"><strong aria-hidden="true">13.</strong> unity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unity/et.html"><strong aria-hidden="true">13.1.</strong> ET框架</a></li></ol></li><li class="chapter-item expanded "><a href="git.html"><strong aria-hidden="true">14.</strong> git</a></li><li class="chapter-item expanded "><a href="grpc.html"><strong aria-hidden="true">15.</strong> grpc</a></li><li class="chapter-item expanded "><a href="brew.html"><strong aria-hidden="true">16.</strong> brew-酿制</a></li><li class="chapter-item expanded "><a href="gogs.html"><strong aria-hidden="true">17.</strong> gogs-代码托管</a></li><li class="chapter-item expanded "><a href="mermaid.html"><strong aria-hidden="true">18.</strong> mermaid-美人鱼</a></li><li class="chapter-item expanded "><a href="shell.html"><strong aria-hidden="true">19.</strong> shell</a></li><li class="chapter-item expanded "><a href="wireshark.html"><strong aria-hidden="true">20.</strong> wireshark</a></li><li class="chapter-item expanded "><a href="windows.html"><strong aria-hidden="true">21.</strong> windows</a></li><li class="chapter-item expanded "><a href="elastic.html"><strong aria-hidden="true">22.</strong> elastic</a></li><li class="chapter-item expanded "><a href="jenkins.html"><strong aria-hidden="true">23.</strong> jenkins</a></li><li class="chapter-item expanded "><a href="vim.html"><strong aria-hidden="true">24.</strong> vim</a></li><li class="chapter-item expanded "><a href="makefile.html"><strong aria-hidden="true">25.</strong> makefile</a></li><li class="chapter-item expanded "><a href="github.html"><strong aria-hidden="true">26.</strong> github</a></li><li class="chapter-item expanded "><a href="firefox.html"><strong aria-hidden="true">27.</strong> firefox</a></li><li class="chapter-item expanded "><a href="flutter.html"><strong aria-hidden="true">28.</strong> flutter</a></li><li class="chapter-item expanded "><a href="tesseract.html"><strong aria-hidden="true">29.</strong> tesseract</a></li><li class="chapter-item expanded "><a href="harbor.html"><strong aria-hidden="true">30.</strong> harbor</a></li><li class="chapter-item expanded "><a href="gitlab.html"><strong aria-hidden="true">31.</strong> gitlab</a></li><li class="chapter-item expanded "><a href="geocode.html"><strong aria-hidden="true">32.</strong> 地理编码</a></li><li class="chapter-item expanded "><a href="hugo.html"><strong aria-hidden="true">33.</strong> hugo</a></li><li class="chapter-item expanded "><a href="svn.html"><strong aria-hidden="true">34.</strong> svn</a></li><li class="chapter-item expanded "><a href="important.html"><strong aria-hidden="true">35.</strong> 重要</a></li><li class="chapter-item expanded "><a href="rpc.html"><strong aria-hidden="true">36.</strong> rpc</a></li><li class="chapter-item expanded "><a href="search.html"><strong aria-hidden="true">37.</strong> 搜索技巧</a></li><li class="chapter-item expanded "><a href="other.html"><strong aria-hidden="true">38.</strong> 杂项</a></li><li class="chapter-item expanded "><a href="opensource.html"><strong aria-hidden="true">39.</strong> 优秀开源软件</a></li><li class="chapter-item expanded "><a href="machinelearn.html"><strong aria-hidden="true">40.</strong> 机器学习</a></li><li class="chapter-item expanded "><a href="ai.html"><strong aria-hidden="true">41.</strong> ai</a></li><li class="chapter-item expanded "><a href="wasm.html"><strong aria-hidden="true">42.</strong> wasm</a></li><li class="chapter-item expanded "><a href="aliyun.html"><strong aria-hidden="true">43.</strong> 阿里云</a></li><li class="chapter-item expanded "><a href="tencent.html"><strong aria-hidden="true">44.</strong> 腾讯</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">技术博客</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h1 id="web"><a class="header" href="#web">web</a></h1>
<hr />
<h3 id="http协议"><a class="header" href="#http协议">HTTP协议</a></h3>
<hr />
<pre class="mermaid">    flowchart LR
      v1(HTTP1.1-1999年) --分帧复用--&gt; v2(HTTP2-2015年)
      v2 --tcp转向udp--&gt;v3(HTTP3-2021年)
</pre>
<ul>
<li>
<p>HTTP不变的协议过程
<img src="webp/web/http_proto.webp" alt="http_proto" /></p>
</li>
<li>
<p>HTTP底层传输变化
<img src="webp/web/http.webp" alt="HTTP协议" /></p>
</li>
<li>
<p>HTTP1.1改进</p>
<ul>
<li>默认持久连接</li>
<li>增加Cookie,虚拟主机,动态内容支持</li>
<li>使用CDN的实现域名分片机制</li>
</ul>
</li>
<li>
<p>HTTP1.1问题</p>
<ul>
<li>TCP的慢启动</li>
<li>多条TCP连接竞争带宽</li>
<li>队头阻塞</li>
</ul>
</li>
<li>
<p>HTTP2改进</p>
<ul>
<li>二进制分帧层</li>
<li>请求的优先级</li>
<li>服务器推送</li>
<li>头部压缩
<img src="webp/web/http2_tcp.webp" alt="http2_tcp" />
<img src="webp/web/http2_frame.webp" alt="http2_frame_tcp" />
<img src="webp/web/https_tcp_tls.webp" alt="https_tcp_tls" /></li>
</ul>
</li>
<li>
<p>HTTP2问题</p>
<ul>
<li>有序字节流引出的队头阻塞（Head-of-line blocking），使得HTTP2的多路复用能力大打折扣</li>
<li>TCP与TLS叠加了握手时延，建链时长还有1倍的下降空间</li>
<li>基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂。</li>
</ul>
</li>
<li>
<p>HTTP3改进</p>
<ul>
<li>HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题</li>
<li>HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度</li>
<li>HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本</li>
</ul>
</li>
</ul>
<h3 id="jwtjson-web-token"><a class="header" href="#jwtjson-web-token">jwt(JSON Web Token)</a></h3>
<hr />
<ul>
<li>
<p>是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。</p>
</li>
<li>
<p>服务器采用秘钥签名检验token内部数据是否正确，不再保存session</p>
</li>
<li>
<p>传统session方案,占用内存,不易扩展</p>
</li>
</ul>
<pre class="mermaid">
sequenceDiagram
    actor u as 用户
    actor s as 服务器
    u-&gt;&gt;s: login登陆
    s--&gt;&gt;u: form填写用户名密码
    u-&gt;&gt;s: Post用户名密码
    s-&gt;&gt;s: 数据库检查,生成并保存session
    s--&gt;&gt;u: setcookie sessionID
    u-&gt;&gt;s: cookies带上sessionID
    s-&gt;&gt;s: 根据sessionID,获取session
    s--&gt;&gt;u: 提供服务
</pre>
<ul>
<li>jwt方案,服务器私用secret,除过期时间之外,token不易作废</li>
</ul>
<pre class="mermaid">
sequenceDiagram
    actor u as 用户
    actor s as 服务器
    u-&gt;&gt;s: login登陆
    s--&gt;&gt;u: form填写用户名密码
    u-&gt;&gt;s: Post用户名密码
    s-&gt;&gt;s: 数据库检查,利用secret生成token
    s--&gt;&gt;u: Authorization token
    u-&gt;&gt;s: Authorization token
    s-&gt;&gt;s: 根据secret,检验token
    s--&gt;&gt;u: 提供服务
</pre>
<ul>
<li>jwt-token构成</li>
</ul>
<pre class="mermaid">
flowchart LR
  subgraph Header
        h(json对象base64编码)
    end
    subgraph Payload
        p(json对象base64编码)
    end
    subgraph Signature
        s(加密计算后base64编码)
    end

  Header--用点号.连接--&gt;Payload--用点号.连接--&gt;Signature
</pre>
<ul>
<li>Header示例</li>
</ul>
<pre><code class="language-json">{
 &quot;alg&quot;: &quot;HS256&quot;,
 &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<ul>
<li>Payload示例</li>
</ul>
<pre><code class="language-json">{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>
<ul>
<li>Signature</li>
</ul>
<pre><code class="language-js">HMACSHA256(
  base64UrlEncode(header) + &quot;.&quot; +
  base64UrlEncode(payload),
  secret)
</code></pre>
<ul>
<li>实例展示</li>
</ul>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
<h3 id="系统容错-限流-熔断-降级"><a class="header" href="#系统容错-限流-熔断-降级">系统容错 限流-熔断-降级</a></h3>
<hr />
<ul>
<li>限流,当核心服务的处理能力不能应对外部请求的突增流量时，必须采取限流的措施。</li>
<li>熔断,非核心服务</li>
</ul>
<pre class="mermaid">
  sequenceDiagram
      actor u as 用户
      actor l as 断路器
      actor s as 服务
      u-&gt;&gt;l: 请求
      l-&gt;&gt;s: 转发请求
      s--&gt;&gt;l: 成功回包
      l--&gt;&gt;u: 转发成功回包
      u-&gt;&gt;l: 请求
      l-&gt;&gt;s: 转发请求
      s--&gt;&gt;l: 失败
      l-&gt;&gt;l: 累计失败,达到阀值
      l--&gt;&gt;u: 转发失败
      u-&gt;&gt;l: 请求
      l-&gt;&gt;l: 检查服务恢复?
      l--&gt;&gt;u: 回包失败

</pre>
<ul>
<li>
<p>服务熔断是指调用方访问服务时通过断路器做代理进行访问，断路器会持续观察服务返回的成功、失败的状态，当失败超过设置的阈值时断路器打开，请求就不能真正地访问到服务了。</p>
</li>
<li>
<p>CLOSED：默认状态。断路器观察到请求失败比例没有达到阈值，断路器认为被代理服务状态良好。</p>
</li>
<li>
<p>OPEN：断路器观察到请求失败比例已经达到阈值，断路器认为被代理服务故障，打开开关，请求不再到达被代理的服务，而是快速失败。</p>
</li>
<li>
<p>HALF OPEN：断路器打开后，为了能自动恢复对被代理服务的访问，会切换到半开放状态，去尝试请求被代理服务以查看服务是否已经故障恢复。如果成功，会转成CLOSED状态，否则转到OPEN状态</p>
</li>
<li>
<p>降级-采用预设方案行动,针对非核心，非必要服务</p>
</li>
</ul>
<h3 id="webdav"><a class="header" href="#webdav">webdav</a></h3>
<hr />
<ul>
<li>WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议。</li>
<li>它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，</li>
<li>使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</li>
</ul>
<h3 id="jsonnet"><a class="header" href="#jsonnet">jsonnet</a></h3>
<hr />
<pre><code class="language-sh">brew install jsonnet
</code></pre>
<p><img src="webp/web/jsonnet.webp" alt="jsonnet" /></p>
<h3 id="优化方向"><a class="header" href="#优化方向">优化方向</a></h3>
<hr />
<ul>
<li>
<p>浏览器处理缓存,如下图所示
<img src="webp/web/%E7%BC%93%E5%AD%98.webp" alt="缓存" title="缓存" /></p>
</li>
<li>
<p>webpack打包</p>
</li>
<li>
<p>图片换格式WebP</p>
</li>
<li>
<p>浏览器处理HTML</p>
</li>
</ul>
<p><img src="webp/web/HTML%E6%B8%B2%E6%9F%93.webp" alt="HTML渲染" title="HTML渲染" />
<img src="webp/web/%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84.webp" alt="内部架构" title="内部架构" /></p>
<h3 id="优秀网站"><a class="header" href="#优秀网站">优秀网站</a></h3>
<hr />
<ul>
<li>
<p><a href="https://nodejs.org/">nodejs-前端必备</a></p>
</li>
<li>
<p><a href="https://v3.cn.vuejs.org/">Bun-更快更现化的nodejs</a></p>
</li>
<li>
<p><a href="https://v3.cn.vuejs.org/">vue3-最火的前端框架</a></p>
</li>
<li>
<p><a href="https://echarts.apache.org/zh/index.html">echarts-必备图库</a></p>
</li>
<li>
<p><a href="https://apisix.apache.org/">apisix-api管理</a></p>
</li>
<li>
<p><a href="https://apache.org">apache-大量优秀项目</a></p>
</li>
<li>
<p><a href="https://www.nginx.org/">nginx-官网</a></p>
</li>
<li>
<p><a href="https://www.nginx.org.cn/">nginx-开源社区</a></p>
</li>
<li>
<p><a href="http://openresty.org/">openresty</a></p>
</li>
<li>
<p><a href="https://konghq.com/">kong-网关</a></p>
</li>
<li>
<p><a href="https://github.com/alibaba/BizCharts">BizCharts-图形库</a></p>
</li>
<li>
<p><a href="https://antv.alipay.com/zh-cn/g2/3.x/tutorial">g2-图形库</a></p>
</li>
<li>
<p><a href="https://angular.io/">angular</a></p>
</li>
<li>
<p><a href="https://www.dartlang.org/">dart</a>, <a href="https://pub.flutter-io.cn/packages">pub-库集散地</a>,绝对值得多看看</p>
</li>
<li>
<p><a href="https://www.javascript.com/">javascript-英文学习站</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/js/">javascript-w3c</a></p>
</li>
<li>
<p><a href="https://www.bootcdn.cn/">前端cdn</a></p>
</li>
<li>
<p><a href="https://mermaidjs.github.io/">mermaidjs-代码画图库</a></p>
</li>
<li>
<p><a href="http://plantuml.com/">plantuml-代码画图库</a></p>
</li>
<li>
<p><a href="https://www.yuque.com/">团队文档-阿里出品语雀</a></p>
</li>
<li>
<p><a href="https://www.atlassian.com/">Confluence-团队文档</a>,据说现在不能私有部署</p>
</li>
</ul>
<h3 id="国内cdn介绍"><a class="header" href="#国内cdn介绍">国内cdn介绍</a></h3>
<ul>
<li>BootCDN: www.bootcdn.cn</li>
<li>七牛云: www.staticfile.org</li>
<li>360: cdn.baomitu.com</li>
<li>字节跳动: cdn.bytedance.com</li>
<li>饿了么：github.elemecdn.com npm.elemecdn.com</li>
<li>知乎：unpkg.zhimg.com</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="mac"><a class="header" href="#mac">mac</a></h1>
<hr />
<h2 id="码农必备"><a class="header" href="#码农必备">码农必备</a></h2>
<hr />
<h3 id="1-iterm2"><a class="header" href="#1-iterm2">1. iTerm2</a></h3>
<ol>
<li>
<p><a href="https://iterm2.com">官网</a>
<img src="webp/mac/iterm2_logo.webp" alt="iTerm2_logo" title="iTerm2_logo" /></p>
</li>
<li>
<p>配置cmd+u切换窗口透明
<img src="webp/mac/iterm2_windows_set.webp" alt="iTerm2_windows_set" title="iTerm2_windows_set" />
<img src="webp/mac/iterm2_shortcut_set.webp" alt="iTerm2_shortcut_set" title="iTerm2_shortcut_set" /></p>
</li>
<li>
<p>快速ssh</p>
<ol>
<li>
<p>创建一个profile脚本</p>
<pre><code class="language-sh">vim aliyun_iterm2_profile

#填写模板内容,替换主机地址和密码,有可能第一次需要手动ssh root@xxxx,添加信任主机
#!/usr/bin/expect -f
set user root
set host ip
set password pwd
set timeout -1

spawn ssh $user@$host
expect &quot;*password:*&quot;
send &quot;$password\r&quot;
interact
expect eof

#增加可执行权限
chmod a+x aliyun_iterm2_profile
</code></pre>
</li>
<li>
<p>增加profile配置
<img src="webp/mac/iterm2_add_profile.webp" alt="iterm2_add_profile" title="iterm2_add_profile" />
&gt;command要从login shell-&gt;command,上图中红色圈圈
&gt;
&gt;上图中红色方框填入第一步profile路径</p>
</li>
<li>
<p>选择执行profile
<img src="webp/mac/iterm2_select_profile.webp" alt="iterm2_select_profile" title="iterm2_select_profile" /></p>
</li>
</ol>
</li>
<li>
<p>替代品<a href="https://www.warp.dev/">wrap</a></p>
<ul>
<li>安装时需要注册帐户,目前采用github授权,最好翻墙，否则会完成不了整个过程</li>
</ul>
</li>
</ol>
<h3 id="2-brew"><a class="header" href="#2-brew">2. <a href="/other/brew">brew</a></a></h3>
<p><img src="webp/mac/brew_logo.webp" alt="brew_logo" title="brew_logo" /></p>
<h3 id="3oh-my-zsh"><a class="header" href="#3oh-my-zsh">3.oh-my-zsh</a></h3>
<ol>
<li>
<p><a href="https://ohmyz.sh">官网</a>
<img src="webp/mac/ohmyzsh_logo.webp" alt="ohmyzsh_logo" title="ohmyzsh_logo" /></p>
</li>
<li>
<p>安装命令</p>
<pre><code class="language-sh"># 如果github访问不了,导致安装不了.则采用国内源安装
# /bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;
sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
</li>
<li>
<p>常用插件</p>
<pre><code class="language-bashrc">plugins=(
 git
   docker
   extract
   dnf
   colored-man-pages
   command-not-found
   zsh-syntax-highlighting
   zsh-autosuggestions
)
历史记录采用年月日
HIST_STAMPS=&quot;yyyy-mm-dd&quot;
在~/.zshrc配置文件里设置ZSH_THEME为你的主题名称
ZSH_THEME=&quot;robbyrussell&quot;

alias cd=&quot;z&quot;
alias ping=&quot;gping&quot;
alias ps=&quot;procs -tree&quot;
alias du=&quot;dust&quot;
alias df=&quot;duf&quot;
alias ls=&quot;exa -l --header --git&quot;
alias cat=&quot;bat&quot;
eval &quot;$(mcfly init zsh)&quot;
eval &quot;$(zoxide init zsh)&quot;
</code></pre>
<ul>
<li>zsh-syntax-highlighting</li>
<li>zsh-autosuggestions</li>
<li>extract 所有类型的文件解压一个命令x全搞定，再也不需要去记tar后面到底是哪几个参数了。</li>
<li>command-not-found 当你输入一条不存在的命令时，会自动查询这条命令可以如何获得</li>
<li>zoxide代替cd,可能不用启动z</li>
<li>提供一个 z 命令，在常用目录之间跳转。类似 autojump，但是不需要额外安装软件。</li>
<li>gping图形化显示ping结果</li>
<li>colored-man-pages 给你带颜色的 man 命令</li>
<li>docker 自带插件，可以实现docker命令补全和自动提示。</li>
<li><a href="https://difftastic.wilfred.me.uk/git.html">difft</a> 自带语法比较,可以替代diff</li>
</ul>
<pre><code class="language-bash"># Set git configuration for the current repository.
git config diff.external difft

# Set git configuration for all repositories
git config --global diff.external difft
</code></pre>
<ul>
<li>官方还提供了大量插件，大部分是针对某些功能的命令补全，如golang, python, pip, ruby, vagrant等。</li>
</ul>
<pre><code class="language-bash"># 显示最近10条历史命令
history [start]  [end],正数从头,负数从尾
history -E -10
</code></pre>
<ul>
<li>禁止自动更新</li>
</ul>
<pre><code class="language-bash">打开ohmyzsh(zsh) 的配置文件: ~/.zshrc
找到DISABLE_AUTO_UPDATE一行，将行首的注释'#'去掉，则可禁用ohmyzsh 自动检查更新。
</code></pre>
</li>
</ol>
<h3 id="4-vscode"><a class="header" href="#4-vscode">4. vscode</a></h3>
<blockquote>
<p>Visual Studio Code 有一个广泛的扩展市场，可以增加你的便利度。但在安装其中一个之前，最好先看看它是否还没有原生支持。随着时间的推移，包含改进和功能的每月发布更新，越来越多的 Visual Studio Code 扩展将不再需要。“有一堆扩展是 bulitin 的，你可以禁用所有你不需要的。进入扩展面板，搜索 @builtin”</p>
</blockquote>
<ol>
<li>
<p><a href="https://code.visualstudio.com">官网</a>
<img src="webp/mac/vscode_screenshot.webp" alt="vscode_screenshot" title="vscode_screenshot" /></p>
</li>
<li>
<p>优秀插件</p>
<ul>
<li>
<p><strong>tabnine</strong> 有免费的AI助手编码,必须强赞一下</p>
</li>
<li>
<p><strong>CodeGeex</strong> 另一个自动生成代码</p>
</li>
<li>
<p>shellman shellcheck shell-format(Alt+Shift+F) Code Runner</p>
</li>
<li>
<p>NGINX Configuration Language Support</p>
</li>
<li>
<p>Go for Visual Studio Code 支持一键生成单元测试</p>
</li>
<li>
<p>Python</p>
</li>
<li>
<p>MongoDB for VS Code</p>
</li>
<li>
<p>Redis For VS Code</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>vscode-drawio 直接在vscode中画图</p>
</li>
<li>
<p>docker</p>
</li>
<li>
<p>toml</p>
</li>
<li>
<p>yaml</p>
</li>
<li>
<p>vscode-pdf</p>
</li>
<li>
<p>Markdown PDF</p>
</li>
<li>
<p>Markdown Preview Mermaid Support</p>
</li>
<li>
<p>vscode-proto3 在.vscode里面的settings.json设置protoc及相关路径</p>
</li>
<li>
<p>JumpProtobuf 在.proto文件跳转f12键</p>
</li>
<li>
<p>Git History</p>
</li>
<li>
<p><strong>GitLens — Git supercharged</strong></p>
</li>
<li>
<p><strong>indent-rainbow</strong></p>
</li>
<li>
<p><strong>vscode-icons</strong>用icon标识不同文件</p>
</li>
<li>
<p><strong>Better Comments</strong>用不同色彩展示注释</p>
</li>
<li>
<p><strong>Error Lens</strong>加强错误显示</p>
</li>
<li>
<p>Project Dashboard把经常使用project固定到仪盘表中</p>
</li>
<li>
<p>CodeSnap 是一个代码截图插件，只需选中项目中相应的代码段，即可快速创建代码的截图。</p>
</li>
<li>
<p>tabnine-AI写代码帮助<a href="https://www.tabnine.com/">https://www.tabnine.com/</a></p>
</li>
<li>
<p>Copilot-AI写代码帮助<a href="https://github.com/features/copilot/">https://github.com/features/copilot/</a>,tabnine类似</p>
</li>
<li>
<p>Output Colorizer *.log文件彩色输出</p>
</li>
<li>
<p>vscode-database-client 高级使用需要收费 <a href="https://github.com/cweijan/vscode-database-client">https://github.com/cweijan/vscode-database-client</a></p>
</li>
<li>
<p>swagger preview-可以设置端口,直接测试接口</p>
</li>
<li>
<p>Hex Editor 以16进制格式查看文件</p>
</li>
<li>
<p>Rainbow CSV</p>
</li>
<li>
<p>Rainbow Brackets</p>
</li>
<li>
<p>Excel Viewer</p>
</li>
<li>
<p>Prettify JSON</p>
</li>
<li>
<p>Path Autocomplete</p>
</li>
<li>
<p>SQL Formatter</p>
</li>
<li>
<p>Regex Previewer</p>
</li>
<li>
<p>Code Spelling checker</p>
</li>
<li>
<p>English word hint</p>
</li>
<li>
<p>vscode-fileheader 插入文件头注释,并且自动更新时间及作者</p>
</li>
</ul>
</li>
<li>
<p>自带markdown preview功能,cmd+shift+v</p>
</li>
<li>
<p>tab/shift+tab整体正/反缩进,cmd+click跳进,ctrl+-跳回</p>
</li>
<li>
<p>已知bug</p>
<ul>
<li>
<p>vscode打开<strong>目录层次不对</strong>,应该直接打开工程目录,不能打开父目录,否则报下面错误</p>
<pre><code class="language-sh">could not import github.com/gomodule/redigo/redis (cannot find package &quot;github.com/gomodule/redigo/redis&quot; in any of
/usr/local/go/src/github.com/gomodule/redigo/redis (from $GOROOT)
/Users/.../gopath/src/github.com/gomodule/redigo/redis (from $GOPATH))
</code></pre>
</li>
<li>
<p>自动保存可能会<strong>自动插入空格</strong>,在生成代码文件,需要注意,可能造成bug.</p>
</li>
</ul>
</li>
<li>
<p>修改go test timeout超时</p>
<ul>
<li>点击左下角齿轮-&gt;设置 打开用户设置</li>
<li>在搜索栏中输入 go test timeout</li>
<li>可以找到 go.testTimeout为30s</li>
</ul>
</li>
<li>
<p>工作空间 workspace多个目录一起打开，组合</p>
</li>
<li>
<p>命令行直接调用</p>
<ul>
<li>命令面板(shift+cmd+p)</li>
<li>输入shell command</li>
<li>选择Install ‘code' command in PATH</li>
<li>命令行输入code .</li>
</ul>
</li>
<li>
<p>代码片断</p>
<ul>
<li>打开vscode,file--&gt;preference(首选项)---&gt;user snippets(用户代码片断),输入python回车，添加如下代码：</li>
</ul>
<pre><code class="language-json">&quot;Print with space lines&quot;: {
      &quot;prefix&quot;: &quot;ppp&quot;,
      &quot;body&quot;: [
         &quot;print('\\n'*2, $1)&quot;,
         
      ],
      &quot;description&quot;: &quot;Print with space lines&quot;
   }
</code></pre>
</li>
</ol>
<p>然后在编写python程序 时候，连续按ppp就可以快捷输出打印变量。</p>
<h3 id="5-fig大幅度提高效率"><a class="header" href="#5-fig大幅度提高效率">5. <a href="https://fig.io/">fig</a>大幅度提高效率</a></h3>
<p><img src="webp/mac/fig.webp" alt="fig" title="fig" /></p>
<pre><code class="language-sh"># 下载安装保存位置
~/.local/bin
</code></pre>
<ul>
<li>需要<strong>填写邮箱</strong>用来同步设置,否则没有效果</li>
</ul>
<h3 id="6-webp-converter批量转换webp格式appstore免费"><a class="header" href="#6-webp-converter批量转换webp格式appstore免费">6. webp converter批量转换webp格式,appstore免费</a></h3>
<p><img src="webp/mac/webp_converter.webp" alt="webp_converter" title="webp_converter" /></p>
<h3 id="7-atomgithub开源免费文本编辑器已死掉了"><a class="header" href="#7-atomgithub开源免费文本编辑器已死掉了">7. <del><a href="https://atom.io/">Atom</a>github开源免费文本编辑器</del>,已死掉了</a></h3>
<p><img src="webp/mac/atom.webp" alt="atom" title="atom" /></p>
<p><img src="webp/mac/atom_package.webp" alt="atom_package" /></p>
<ul>
<li>优秀插件
<ul>
<li>simplified-chinese-menu</li>
<li>go-plus</li>
<li>markdown-writer</li>
<li>platformio-ide-terminal</li>
<li>file-icons</li>
<li>regex-railroad-diagram</li>
</ul>
</li>
</ul>
<h3 id="8-sublimetext闭源可免费使用文本编辑器"><a class="header" href="#8-sublimetext闭源可免费使用文本编辑器">8. <a href="https://www.sublimetext.com/">sublimetext</a>,闭源可免费使用文本编辑器</a></h3>
<p><img src="sublimetext.svg" alt="sublimetext" title="sublimetext" /></p>
<ul>
<li>
<p>安装打开终端插件 terminus</p>
<ul>
<li>
<p>cmd+shift+p 然后输入 install package 输入 <a href="https://github.com/randy3k/Terminus">terminus</a></p>
</li>
<li>
<p>配置key</p>
<pre><code class="language-json">{ 
   &quot;keys&quot;: [&quot;ctrl+`&quot;], 
   &quot;command&quot;: &quot;toggle_terminus_panel&quot;,

},
{
   &quot;keys&quot;: [&quot;ctrl+shift+`&quot;],
   &quot;command&quot;: &quot;terminus_open&quot;,
   &quot;args&quot;: {
      &quot;cwd&quot;: &quot;${file_path:${folder}}&quot;
   }
},
</code></pre>
</li>
</ul>
</li>
<li>
<p>安装语法高亮nginx配置文件插件 sublime-nginx/Nginx Log Highlighter</p>
<ul>
<li>cmd+shift+p 然后输入 install package 输入 <a href="https://github.com/brandonwamboldt/sublime-nginx">nginx</a></li>
</ul>
</li>
<li>
<p>安装shell脚本语法高亮插件 Pretty Shell</p>
<ul>
<li>cmd+shift+p 然后输入 install package 输入 <a href="https://packagecontrol.io/packages/PrettyShell">Pretty Shell</a></li>
</ul>
</li>
<li>
<p>安装markdown插件 markdown Editing</p>
<ul>
<li>cmd+shift+p 然后输入 install package 输入 [markdown Editing]</li>
</ul>
</li>
<li>
<p>Rainbow CSV</p>
</li>
<li>
<p>Rainbow Brackets</p>
</li>
<li>
<p>Git</p>
</li>
<li>
<p>AutoFileName</p>
</li>
<li>
<p>Pretty JSON</p>
</li>
<li>
<p>Pretty Protocol buf</p>
</li>
<li>
<p>Protocol Syntax Highlighting</p>
</li>
<li>
<p>FileIcons</p>
</li>
<li>
<p>SQL Formatter</p>
</li>
<li>
<p>GitSyntaxes</p>
</li>
<li>
<p>advanced CSV</p>
</li>
<li>
<p>JsFormat</p>
</li>
<li>
<p>HTMLBeautify</p>
</li>
<li>
<p>docker file lint/ docker high light</p>
</li>
<li>
<p>主题及color主题是两种，可以分开选择</p>
</li>
</ul>
<h3 id="9-chrome无google全家桶的chrome"><a class="header" href="#9-chrome无google全家桶的chrome">9. <a href="https://github.com/Eloston/ungoogled-chromium">chrome</a>,无google全家桶的chrome</a></h3>
<pre><code class="language-bash">brew install --cask eloston-chromium
</code></pre>
<h2 id="利用蓝牙传输文件"><a class="header" href="#利用蓝牙传输文件"><a href="https://support.apple.com/zh-cn/guide/mac-help/mchle7fa9e15/mac">利用蓝牙传输文件</a></a></h2>
<hr />
<ol>
<li>
<p>在&quot;系统偏好设置&quot;-&gt;“蓝牙”开启功能</p>
</li>
<li>
<p>等待发现蓝牙设备,连接设备,在设备上同意配对</p>
</li>
<li>
<p>mac向设备传输文件使用“蓝牙文件交换”(位于“应用程序”文件夹的“实用工具”文件夹中)</p>
</li>
<li>
<p>设备向mac传输文件,则mac设置蓝牙共享,&quot;系统偏好设置&quot;-&gt;“共享”</p>
</li>
<li>
<p>蓝牙传输超慢,建议采用局域网sftp,mac自带sftp服务</p>
</li>
</ol>
<h2 id="无法验证开发者"><a class="header" href="#无法验证开发者">无法验证开发者</a></h2>
<hr />
<p><img src="webp/mac/cannotrun.webp" alt="无法验证开发者" title="无法验证开发者" /></p>
<blockquote>
<p>解决办法:在Finder中找到应用程序,并找到该程序,右键-&gt;打开
<img src="webp/mac/rightopen.webp" alt="右键打开" title="右键打开" /></p>
</blockquote>
<h2 id="开机启动"><a class="header" href="#开机启动">开机启动</a></h2>
<hr />
<ul>
<li>
<p>Login Items</p>
<ul>
<li>在~/Library/Preferences/com.apple.loginitems.plist</li>
<li>在系统偏好设置的“用户与群组”下面进行设置，可以删除、添加、开启和关闭;</li>
</ul>
</li>
<li>
<p>Launchd Daemon,launchd来负责启动</p>
<ul>
<li>~/Library/LaunchAgents</li>
<li>/Library/LaunchAgents</li>
<li>/System/Library/LaunchAgents</li>
<li>~/Library/LaunchDaemons</li>
<li>/Library/LaunchDaemons</li>
<li>/System/Library/LaunchDaemons</li>
</ul>
</li>
<li>
<p>StartupItems</p>
<ul>
<li>/System/Library/StartupItems</li>
<li>/Library/StartupItems</li>
</ul>
</li>
</ul>
<h2 id="技巧"><a class="header" href="#技巧">技巧</a></h2>
<hr />
<ul>
<li>在命令行打开<strong>访达</strong>当前目录</li>
</ul>
<pre><code class="language-bash">open 特定目录
open .
</code></pre>
<ul>
<li>截屏 shift+cmd+5 非常不错,谁用知道</li>
<li>朗读-读出所选内容(option+ecs),如果没有效果,则可能系统声音选择不对，本机器上反应有点慢，要等几秒才能读。
<img src="webp/mac/mac_speak.webp" alt="mac_speak" /></li>
<li>mac字体路径 /System/Library/Fonts,/Library/Fonts,ttf是mac和freetype共同推出的字体文件,ttc是ttf的集合文件(<a href="https://www.cnblogs.com/fortunely/p/16651504.html">https://www.cnblogs.com/fortunely/p/16651504.html</a>)</li>
<li>目前苹果有intel和M1芯片两种,软件下载安装时,注意Mac silicon/arm64/aarch指明适用M1芯片</li>
<li>xcode默认只有英文界面，不支持中文界面</li>
<li>iphone采用数据线连上mac,在新版的mac上没有iTunes,在访达偏好设置中有一个显示ios设备选项，否则无法显示出来!</li>
<li>AppleID网络iCloud同步,前面打勾就会自动上传或下载同步iCloud空间中,
<ul>
<li>iCloud云盘是iCloud空间一个目录,本地也有一个对应目录</li>
<li>照片也是iCloud空间一个目录,本地也有一个对应目录</li>
<li>其他华为,小米帐号iCloud空间都是类似的
<img src="webp/mac/appleid.webp" alt="appleid" /></li>
</ul>
</li>
<li>查看端口</li>
</ul>
<pre><code class="language-sh">lsof -i tcp:8080
</code></pre>
<ul>
<li>查看本机地址</li>
</ul>
<pre><code class="language-sh"># mac把Wi-Fi称为en0
ifconfig en0
</code></pre>
<ul>
<li>
<p>修改hosts sudo vim /etc/hosts</p>
</li>
<li>
<p>深色模式,保护眼睛
<img src="webp/mac/mac_display_show.webp" alt="选择" />
<img src="webp/mac/mac_display_deep.webp" alt="设置" /></p>
</li>
<li>
<p>删除Microsoft Auto Update,烦人的更新提示</p>
<pre><code class="language-sh">cd /Library/Application Support/Microsoft/MAU2.0
sudo rm -rf Microsoft\ AutoUpdate.app
</code></pre>
</li>
<li>
<p>树状显示目录tree</p>
<pre><code class="language-sh">brew install tree
tree
</code></pre>
</li>
<li>
<p>十六进制显示文件</p>
<pre><code class="language-sh"># xxd系统自带,-l只显示开头40字节
xxd -l 40 filename
</code></pre>
</li>
<li>
<p>访达/系统按键
| 名称 | 作用 |
| -- | -- |
| 回车键 | 重命名文件夹或文件 |
| command + o | 打开文件 |
| command + ↓ | 打开文件 |
| command + ↑ | 进入当前目录的上一级目录 |
| 空格键 | 预览 |</p>
</li>
<li>
<p><a href="https://imagemagick.org/">imagemagick</a> 图像处理神器</p>
</li>
</ul>
<pre><code class="language-bash">brew install imagemagick

# 注意参数位置density是修饰pdf,否则会采用默认72dpi
magick convert -density 300 enroll-sch.pdf -resize 1330x1900 -quality 100 ./photo/enroll-sch.jpg
</code></pre>
<ul>
<li>ssh免密登录远程</li>
</ul>
<pre><code class="language-bash"># 输入密码就能实现远程免密登陆，本质上pub文件内容加到远程机器~/.ssh/authorized_keys文件中
ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.0.104 
</code></pre>
<ul>
<li>
<p>鼠标按windows滚动</p>
<ul>
<li>打开Mac系统偏好设置</li>
<li>在系统偏好设置界面，点击&quot;鼠标&quot;</li>
<li>进入鼠标的设置窗口，单击“光标与点按&quot;标签</li>
<li>在光标与点按设置面板，将&quot;滚动方向：自然&quot;的勾选去掉即可</li>
<li>然后在滑动鼠标，即和windows的滚轮一样了</li>
</ul>
</li>
<li>
<p>替换按键ctrl+alt
<img src="webp/mac/replace-ctrl_alt.webp" alt="替换按键" /></p>
</li>
<li>
<p>mac电脑的默认字体-苹方字体，中文就是-苹方-简,有专门的&quot;字体册&quot;app管理</p>
</li>
<li>
<p>编程仅好字体 Menlo, Monaco, 'Courier New', monospace 12大小</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="docker"><a class="header" href="#docker">docker</a></h1>
<hr />
<p><a href="https://www.docker.com">官网</a>
<img src="docker//webp/docker/life.webp" alt="life" /></p>
<ul>
<li>
<p>The easiest and recommended way to get Docker Compose is to install Docker Desktop. Docker Desktop includes Docker Compose along with Docker Engine and Docker CLI which are Compose prerequisites.</p>
</li>
<li>
<p>linux服务器单独安装docker,就需要单独安装docker-compose.</p>
</li>
</ul>
<h3 id="dockerfile示意图"><a class="header" href="#dockerfile示意图">dockerfile示意图</a></h3>
<p><img src="docker//webp/docker/dockerfile.webp" alt="dockerfile" /></p>
<h3 id="containerd示意图"><a class="header" href="#containerd示意图">containerd示意图</a></h3>
<p><img src="docker//webp/docker/containerd.webp" alt="containerd" /></p>
<h3 id="podman集合-开源替代品"><a class="header" href="#podman集合-开源替代品"><a href="https://github.com/containers">podman集合-开源替代品</a></a></h3>
<h3 id="阿里云"><a class="header" href="#阿里云">阿里云</a></h3>
<hr />
<pre><code class="language-sh"># 安装docker引擎
yum install docker
# 开机启动
service docker start
# repos地址
vim /etc/docker/daemon.json
{ &quot;registry-mirrors&quot;: &quot;https://registry.docker-cn.com&quot;, &quot;live-restore&quot;: true }

docker run -d -p 8090:80 docker/getting-started

# 容器日志物理目录
/var/lib/docker/containers/ID/ID-json.log

# 设置共享内存
docker --shm-size 256m

# 安装 elasticsearch
docker pull docker.elastic.co/elasticsearch/elasticsearch:7.5.2
# 启动 openjdk 内存空间有要求
docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.5.2

# 在linux至少8G,容易跑起来
# 需要继续 docker kibana rancher
# brancher 集群-多个项目,项目-多个命令空间
# rancher 主界面-&gt;右下角有个English，点击选择中文

# 单节点安装，重置密码
docker exec -ti &lt;container_id&gt; reset-password

# 必须带上-v $HOME/rancher:/var/lib/rancher/,否则跑不起来
# 导致https://192.168.8.108:8091,https://127.0.0.1:8091(不能访问)
# rancher启动慢,需要等待片刻就能浏览器访问
# docker logs -f rancher查看容器启动日志
docker run -d --restart=unless-stopped -p 8090:80 -p 8091:443 --privileged -v $HOME/rancher:/var/lib/rancher/ rancher/rancher:latest
rEWlGtFhS52EsKIa
https://127.0.0.1:8091
</code></pre>
<h3 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h3>
<hr />
<blockquote>
<p>所有images都压缩在Docker.qcow2里</p>
</blockquote>
<pre><code class="language-sh">#下载安装gerrit
docker pull gerritcodereview/gerrit

#运行gerrit
docker run -ti -p 8080:8080 -p 29418:29418 gerritcodereview/gerrit

#docker 安装(周编译,较新但可能bug)
docker pull jenkinsci/jenkins
chown -R 1000:1000 /root/jenkins_home
docker run -d -p 8080:8080 --restart=always -v /root/jenkins_home:/var/jenkins_home --name jenkins jenkins/jenkins
# 帮助文档
https://www.w3cschool.cn/jenkins/jenkins-e7bo28ol.html

Blue Ocean值得安装
nohup mdbook serve &gt;~/mdbook.nohup 2&gt;&amp;1 &amp;

docker run --name some-mysql -v /my/own/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

#安装gitlab,机器性能要好,否则卡死
docker pull gitlab/gitlab-ce

#gerrit是google开源的代码review工具
docker pull gerritcodereview/gerrit
docker run -ti -p 8080:8080 -p 29418:29418 gerritcodereview/gerrit
# http://localhost:8080

#SonarQube检测代码质量平台
docker pull sonarqube

# Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

# 查看image的产生过程,可以得到dockerfile
docker history --no-trunc alpine
</code></pre>
<h3 id="container容器管理"><a class="header" href="#container容器管理">container容器管理</a></h3>
<pre><code class="language-sh">#默认显示运行的容器
docker ps

#显示所有容器
docker ps -a

# attach模式, 类似运行于前台的进程，会占据本地的STDIN和STDOUT
docker run nginx

# 进入容器
docker exec --it containerID/containerName /bash
docker exec --it containerID/containerName redis-cli

# detach模式,可以用docker container attach id改为attach模式,类似于后台运行
docker run -d nginx

# 与容器的交互

docker run -it id(container id) command 当command运行结束之后，container的状态也变成了exited的状态
docker exec -it id command 当command运行结束之后，container的状态保持running状态不变

docker stop $(docker ps -q)

#已经停止的，正在运行的不能删除
docker rm $(docker ps -a -q)
</code></pre>
<h3 id="image管理"><a class="header" href="#image管理">image管理</a></h3>
<pre><code class="language-sh"># 注意images
docker images --help

Usage:  docker images [OPTIONS] [REPOSITORY[:TAG]]

List images

Options:
  -a, --all             Show all images (default hides intermediate images)
      --digests         Show digests
  -f, --filter filter   Filter output based on conditions provided
      --format string   Pretty-print images using a Go template
      --no-trunc        Donot truncate output
  -q, --quiet           Only show image IDs

# 删除image为none
docker images|grep none|awk '{print $3 }'|xargs docker rmi

# 注意image
docker image --help

Usage:  docker image COMMAND

Manage images

Commands:
  build       Build an image from a Dockerfile
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Display detailed information on one or more images
  load        Load an image from a tar archive or STDIN
  ls          List images
  prune       Remove unused images
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rm          Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

</code></pre>
<h3 id="volume管理"><a class="header" href="#volume管理">volume管理</a></h3>
<pre><code class="language-sh">docker volume --help

Usage:  docker volume COMMAND

Manage volumes

Commands:
  create      Create a volume
  inspect     Display detailed information on one or more volumes
  ls          List volumes
  prune       Remove all unused local volumes
  rm          Remove one or more volumes
</code></pre>
<blockquote>
<p>其实VOLUME指令只是起到了声明了容器中的目录作为匿名卷，但是并没有将匿名卷绑定到宿主机指定目录的功能。
当我们生成镜像的Dockerfile中以Volume声明了匿名卷，并且我们以这个镜像run了一个容器的时候，docker会在安装目录下的指定目录下面生成一个目录来绑定容器的匿名卷（这个指定目录不同版本的docker会有所不同），我当前的目录为：/var/lib/docker/volumes/{容器ID}。
volume只是指定了一个目录，用以在用户忘记启动时指定-v参数也可以保证容器的正常运行。
那么如果用户指定了-v，自然而然就不需要volume指定的位置了</p>
</blockquote>
<h3 id="network管理"><a class="header" href="#network管理">network管理</a></h3>
<pre><code class="language-sh">Usage:  docker network COMMAND

Manage networks

Commands:
  connect     Connect a container to a network
  create      Create a network
  disconnect  Disconnect a container from a network
  inspect     Display detailed information on one or more networks
  ls          List networks
  prune       Remove all unused networks
  rm          Remove one or more networks
Run 'docker network COMMAND --help' for more information on a command
</code></pre>
<h3 id="其他命令"><a class="header" href="#其他命令">其他命令</a></h3>
<pre><code class="language-sh">Management Commands:
  builder     Manage builds
  buildx*     Docker Buildx (Docker Inc., v0.8.1)
  compose*    Docker Compose (Docker Inc., v2.3.3)
  config      Manage Docker configs
  container   Manage containers
  context     Manage contexts
  image       Manage images
  manifest    Manage Docker image manifests and manifest lists
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  scan*       Docker Scan (Docker Inc., v0.17.0)
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes
</code></pre>
<h3 id="私有部署dockerhub"><a class="header" href="#私有部署dockerhub">私有部署dockerhub</a></h3>
<pre><code class="language-bash"># 利用docker公司提供的工具
docker pull registry

# -v 主机目录:容器目录,registry存储仓库中镜像到/var/lib/registry
docker run -d -p 5000:5000 --restart=always -v /opt/dockerhub:/var/lib/registry registry

# 从dockerhub拉取nginx最新版
docker pull nginx
# 打上特定hub的标签
docker tag nginx localhost:5000/nginx
# 推送nginx到目标hub中去
docker push localhost:5000/nginx

# http://主机ip:5000/v2/_catalog 查看信息

# 增加配置,docker默认走https，但是registry默认走http /etc/docker/daemon.json
&quot;insecure-registries&quot;:[
    &quot;主机:5000&quot;
]

</code></pre>
<h3 id="jenkins-另一个开源替代品gocd"><a class="header" href="#jenkins-另一个开源替代品gocd">jenkins 另一个开源替代品<a href="https://www.gocd.org/">gocd</a></a></h3>
<hr />
<ul>
<li>
<p>忘记密码-admin密码未更改情况</p>
<ul>
<li>cat ~/.jenkins/secrets/initialAdminPassword 就是初始化密码</li>
<li>访问jenkins页面，输入管理员admin，及刚才的密码；</li>
<li>进入后可更改其他管理员密码；</li>
</ul>
</li>
<li>
<p>brew 启动不了</p>
</li>
</ul>
<pre><code class="language-sh"># Bootstrap failed: 5: Input/output error
# Error: Failure while executing; `/bin/launchctl bootstrap gui/503 /Users/zzi/Library/LaunchAgents/homebrew.mxcl.jenkins-lts.plist` exited with 5.

# 试试
brew services restart jenkins-lts

</code></pre>
<ul>
<li>SSH remote hosts配置中Pty一定不能勾选,否则nohup需要sleep才有效</li>
<li>证书是统一管理各种,包括ssh,gitlab等等.</li>
<li>Multijob插件用来批量构建工程,过时了，改用'parallel' step along with 'BlueOcean' can basical</li>
<li>Multiple SCMs用来处理多个git/svn仓库构建一个项目</li>
</ul>
<h3 id="遇到问题"><a class="header" href="#遇到问题">遇到问题</a></h3>
<ul>
<li>Docker拉取镜像时出现Error response from daemon: Get <a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>: net/http: TLS handshake timeout问题</li>
</ul>
<pre><code class="language-json">&quot;registry-mirrors&quot;: [&quot;https://bytkgxyr.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;]
</code></pre>
<h3 id="golang示例"><a class="header" href="#golang示例"><a href="https://docs.docker.com/language/golang/">golang示例</a></a></h3>
<blockquote>
<p>docker新版本引入多阶段,主要用来优化不同阶段要求不同,例如编译时需要编译工具,但运行时不需要的.运行时只要引入编译产物就可以了.</p>
</blockquote>
<pre><code class="language-dockerfile"># syntax=docker/dockerfile:1

## Build
FROM golang:1.16-buster AS build

# 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录
WORKDIR /app
# 从构建上下文中复制文件到容器
COPY go.mod ./
COPY go.sum ./
RUN go mod download

COPY *.go ./

RUN go build -o /docker-gs-ping

## Deploy
FROM gcr.io/distroless/base-debian10

WORKDIR /

COPY --from=build /docker-gs-ping /docker-gs-ping

EXPOSE 8080

USER nonroot:nonroot

# 如果设定了ENTRYPOINT,则cmd,和run后面参数都作为entrypoint参数，
# 否则按run后面参数作用cmd运行
# 没有entrypoint,cmd都不存在，则按cmd运行
ENTRYPOINT [&quot;/docker-gs-ping&quot;]
</code></pre>
<pre><code class="language-bash">docker build -t docker-gs-ping:multistage -f Dockerfile.multistage .
</code></pre>
<h3 id="python示例"><a class="header" href="#python示例"><a href="https://docs.docker.com/language/python/">python示例</a></a></h3>
<pre><code class="language-docker"># syntax=docker/dockerfile:1

FROM python:3.8-slim-buster

WORKDIR /app

COPY requirements.txt requirements.txt
RUN pip3 install -r requirements.txt

COPY . .

CMD [ &quot;python3&quot;, &quot;-m&quot; , &quot;flask&quot;, &quot;run&quot;, &quot;--host=0.0.0.0&quot;]
</code></pre>
<pre><code class="language-bash">docker tag python-docker:latest python-docker:v1.0.0
</code></pre>
<h3 id="minikube-单机版精简k8s"><a class="header" href="#minikube-单机版精简k8s"><a href="https://minikube.sigs.k8s.io">minikube-单机版精简k8s</a></a></h3>
<blockquote>
<p>你可以使用 kubectl 命令行工具来启用 Dashboard 访问
kubectl 会使得 Dashboard 可以通过 <a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</a> 访问。</p>
</blockquote>
<pre><code class="language-bash">kubectl proxy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-1"><a class="header" href="#docker-1">docker</a></h1>
<h2 id="docker-composeyml"><a class="header" href="#docker-composeyml">docker-compose.yml</a></h2>
<pre><code class="language-bash"># 多个services之间自动创建network,并且用web,redis当作别名，加入同个network
# 并且会默认创建volume共享
docker compose up
</code></pre>
<pre><code class="language-yml">version: '3'
services:
 web:
   #冒号之后一定要空格，否则提示错误
    build: .
    ports: [&quot;3000:3000&quot;]
 redis:
    image: &quot;redis:7.0-alpine3.17&quot;
</code></pre>
<h2 id="dockerfile"><a class="header" href="#dockerfile">dockerfile</a></h2>
<pre><code class="language-dockerfile">FROM python:3.10-alpine
WORKDIR /app
COPY requirements.txt requirements.txt
COPY main.py main.py
RUN pip3 install -r requirements.txt
CMD [&quot;python3&quot;, &quot;main.py&quot;]

</code></pre>
<h2 id="mainpy"><a class="header" href="#mainpy">main.py</a></h2>
<pre><code class="language-python">
from typing import Union

from fastapi import FastAPI

from pydantic import BaseModel

# async def app(scope, receive, send):
app = FastAPI()


class Item(BaseModel):
        name: str
        price: float
        is_offer: Union[bool, None] = None


@app.get(&quot;/&quot;)
def read_root():
    return {&quot;Hello&quot;: &quot;World&quot;}

@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id: int, q: Union[str, None] = None):
        return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}


@app.put(&quot;/items/{item_id}&quot;)
def update_item(item_id: int, item: Item):
        return {&quot;item_id&quot;: item_id, &quot;item&quot;: item}

import redis

client = redis.Redis(host='redis', port=6379, db=0)

@app.get(&quot;/hit&quot;)
def hit():
    val = client.incrby('hit')
    return {&quot;hit&quot;: val}

if __name__ == &quot;__main__&quot;:
    import uvicorn

    uvicorn.run(&quot;main:app&quot;, host='0.0.0.0', port=3000)


</code></pre>
<h2 id="requirementstxt"><a class="header" href="#requirementstxt">requirements.txt</a></h2>
<pre><code class="language-txt">fastapi
redis
uvicorn[standard]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="nginx"><a class="header" href="#nginx">nginx</a></h1>
<hr />
<h3 id="nginx-中国开源社区"><a class="header" href="#nginx-中国开源社区"><a href="https://www.nginx.org.cn">Nginx-中国开源社区</a></a></h3>
<h3 id="http-v3-module"><a class="header" href="#http-v3-module"><a href="https://quic.nginx.org/">HTTP-V3-Module</a></a></h3>
<h3 id="brotli-替代gzip压缩算法更快更省时"><a class="header" href="#brotli-替代gzip压缩算法更快更省时"><a href="nginx/h%3Chttps://github.com/google/ngx_brotli">brotli-替代gzip压缩算法,更快更省时</a>&gt;</a></h3>
<h3 id="caddy-nginx替代品"><a class="header" href="#caddy-nginx替代品"><a href="https://github.com/caddyserver/caddy">caddy-nginx替代品</a></a></h3>
<h3 id="可视化配置展示-nginxconfig"><a class="header" href="#可视化配置展示-nginxconfig"><a href="https://github.com/digitalocean/nginxconfig.io">可视化配置展示-nginxconfig</a></a></h3>
<h3 id="动态配置内置应用支持-nginxunit"><a class="header" href="#动态配置内置应用支持-nginxunit"><a href="http://unit.nginx.org/">动态配置+内置应用支持-nginxunit</a></a></h3>
<h3 id="动态配置-traefik"><a class="header" href="#动态配置-traefik"><a href="http://traefik.cn/">动态配置-traefik</a></a></h3>
<h3 id="openssl爆出各种重大问题大厂都自已搞了一个分支"><a class="header" href="#openssl爆出各种重大问题大厂都自已搞了一个分支">openssl爆出各种重大问题,大厂都自已搞了一个分支</a></h3>
<ul>
<li>
<p><a href="https://github.com/google/boringssl">谷歌的openssl-boringssl</a></p>
</li>
<li>
<p><a href="https://www.libressl.org/">OpenBSD重构openssl-libressl</a></p>
</li>
<li>
<p><a href="https://github.com/google/ngx_brotli">谷歌新压缩算法-brotli</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="源码安装剖析"><a class="header" href="#源码安装剖析">源码安装剖析</a></h1>
<hr />
<pre class="mermaid">
flowchart LR
A(下载) --&gt; B(配置)
B --&gt; C(编译)
C --&gt; D(安装)
D --&gt; E(运行)
E --&gt; F(进阶)
F --&gt; G(后记)

</pre>
<h2 id="1下载"><a class="header" href="#1下载">1.下载</a></h2>
<hr />
<pre><code class="language-sh">
    wget https://nginx.org/download/nginx-1.21.6.tar.gz

    tar -zxvf nginx-1.21.6.tar.gz

    cd nginx-1.21.6

</code></pre>
<blockquote>
<p>源代码目录,如下图所示:</p>
</blockquote>
<p><img src="nginx//webp/install/nginx_src.webp" alt="源代码目录图" title="源代码目录图" /></p>
<h2 id="2-配置"><a class="header" href="#2-配置">2. 配置</a></h2>
<hr />
<pre><code class="language-sh">
    # prefix参数指定默认路径(安装，配置文件，日志目录, 临时目录等等)
    # with-debug参数增加调试日志,正式运行强烈建议不要此参数

    ./configure --prefix=/Users/Shared/nginx --with-debug

    # 更多参数及详细说明见 ./configure --help
</code></pre>
<ul>
<li>生成makefile文件,如下图所示:</li>
</ul>
<p><img src="nginx//webp/install/nginx_makefile.webp" alt="makefile文件" title="makefile文件图" /></p>
<ul>
<li>生成objs子目录,如下图所示</li>
</ul>
<p><img src="nginx//webp/install/nginx_objs.webp" alt="objs子目录" title="objs子目录图" /></p>
<ul>
<li>生成ngx_modules.c文件,如下图所示:</li>
</ul>
<p><img src="nginx//webp/install/nginx_objs_modules.webp" alt="启用模块列表文件" title="启用模块列表文件图" /></p>
<h2 id="3-编译"><a class="header" href="#3-编译">3. 编译</a></h2>
<hr />
<pre><code class="language-sh">
    # 实际上执行上一步生成的objs/makefile
    make

</code></pre>
<ul>
<li>生成启用模块目标文件,如下图所示:</li>
</ul>
<p><img src="nginx//webp/install/nginx_make.webp" alt="模块目标文件" title="模块目标文件图" /></p>
<h2 id="4-安装"><a class="header" href="#4-安装">4. 安装</a></h2>
<hr />
<pre><code class="language-sh">
    # 实际上执行上一步生成的objs/makefile
    make install

</code></pre>
<ul>
<li>安装执行代码,如下所示:</li>
</ul>
<pre><code class="language-sh">
install: build 
test -d '$(DESTDIR)/Users/Shared/nginx' || mkdir -p '$(DESTDIR)/Users/Shared/nginx'

test -d '$(DESTDIR)/Users/Shared/nginx/sbin' \
|| mkdir -p '$(DESTDIR)/Users/Shared/nginx/sbin'
test ! -f '$(DESTDIR)/Users/Shared/nginx/sbin/nginx' \
|| mv '$(DESTDIR)/Users/Shared/nginx/sbin/nginx' \
'$(DESTDIR)/Users/Shared/nginx/sbin/nginx.old'
cp objs/nginx '$(DESTDIR)/Users/Shared/nginx/sbin/nginx'

test -d '$(DESTDIR)/Users/Shared/nginx/conf' \
|| mkdir -p '$(DESTDIR)/Users/Shared/nginx/conf'

....

test -d '$(DESTDIR)/Users/Shared/nginx/logs' \
|| mkdir -p '$(DESTDIR)/Users/Shared/nginx/logs'

</code></pre>
<ul>
<li>安装目录,如下图所示:</li>
</ul>
<p><img src="nginx//webp/install/nginx_install.webp" alt="安装目录" title="安装目录图" /></p>
<h2 id="5运行"><a class="header" href="#5运行">5.运行</a></h2>
<hr />
<pre><code class="language-sh">
    # /Users/Shared/nginx为configure中prefix参数指定
    cd /Users/Shared/nginx/sbin

    # -t 表示检查配置文件是否正确
    ./nginx -t

    ./nginx

</code></pre>
<ul>
<li>日志目录,如下图所示:</li>
</ul>
<p><img src="nginx//webp/install/nginx_run.webp" alt="日志目录" title="日志目录图" /></p>
<ul>
<li>查看帮助,如下图所示:</li>
</ul>
<pre><code class="language-sh">
    ./nginx -h

</code></pre>
<p><img src="nginx//webp/install/nginx_help.webp" alt="帮助" title="帮助图" /></p>
<ul>
<li>查看调试日志,如下图所示:</li>
</ul>
<pre><code class="language-nginx">    http {
        ...
        server {
            listen       80;
            server_name  localhost;
            # 编译时需要带上--with-debug
            # 如果仅看http过程,则指定等级为debug_http
            error_log logs/error.log debug;
            location / {
                root   html;
                index  index.html index.htm;
            }
        }
        ...
    }

</code></pre>
<p><img src="nginx//webp/install/nginx_errlog_debug.webp" alt="日志图" title="日志图" /></p>
<h2 id="6-进阶"><a class="header" href="#6-进阶">6. 进阶</a></h2>
<hr />
<h3 id="1-安装第三方模块及禁启用自带模块"><a class="header" href="#1-安装第三方模块及禁启用自带模块">1. 安装第三方模块及禁/启用自带模块</a></h3>
<pre><code class="language-sh">
    # ../nginx-party-module/echo-nginx-module是echo-nginx-module模块源代码目录

    ./configure \
    --prefix=/Users/Shared/nginx \
    --without-http_empty_gif_module \
    --with-stream \
    --add-module=../nginx-party-module/echo-nginx-module

</code></pre>
<ul>
<li>--without参数禁用自带模块</li>
<li>--with参数启用自带模块</li>
<li>--add-module参数安装第三方模块</li>
</ul>
<h3 id="2-编译安装"><a class="header" href="#2-编译安装">2. 编译安装</a></h3>
<pre><code class="language-sh">
    make &amp;&amp; make install

</code></pre>
<ul>
<li>make时在objs目录产生一个addon子目录,保存echo-nginx-module模块相关文件,如下图所示:</li>
</ul>
<p><img src="nginx//webp/install/nginx_party_echo.webp" alt="party_echo图" title="party_echo图" /></p>
<h3 id="3-编辑nginxconf运行"><a class="header" href="#3-编辑nginxconf运行">3. 编辑nginx.conf,运行</a></h3>
<pre><code class="language-sh">    cd /Users/Shared/nginx/conf
    vim nginx.conf

        ....
        # echo-nginx-module模块详细见项目网址
        location /hello {
            echo &quot;hello, world!&quot;;
        }
        ...

    cd ../sbin
    ./nginx
</code></pre>
<h3 id="4-测试"><a class="header" href="#4-测试">4. 测试</a></h3>
<pre><code class="language-sh">
    curl http://localhost/hello
    hello,world!

</code></pre>
<h3 id="5-原理分析"><a class="header" href="#5-原理分析">5. 原理分析</a></h3>
<ol>
<li>
<p>configure脚本先引用auto目录下的options脚本,如下图所示:
<img src="nginx//webp/install/nginx_configure_options.webp" alt="configure_options图" title="configure_options图" /></p>
</li>
<li>
<p>options脚本设参数默认值,如下图所示:
<img src="nginx//webp/install/nginx_auto_options.webp" alt="auto_options图" title="auto_options图" /></p>
</li>
<li>
<p>configure脚本再引用auto目录下的modules脚本,如下图所示:
<img src="nginx//webp/install/nginx_configure_modules.webp" alt="configure_modules图" title="configure_modules图" /></p>
</li>
<li>
<p>modules脚本如果参数为yes则引入编译,如下图所示:
<img src="nginx//webp/install/nginx_auto_modules.webp" alt="auto_modules图" title="auto_modules图" /></p>
</li>
<li>
<p>objs目录的ngx_modules.c文件就会增加引入的模块名,如下所示:</p>
</li>
</ol>
<pre><code class="language-c">
    ...
    ngx_module_t *ngx_modules[] = {
        &amp;ngx_core_module,
        &amp;ngx_errlog_module,
        &amp;ngx_conf_module,
        &amp;ngx_regex_module,
        &amp;ngx_events_module,
        &amp;ngx_event_core_module,
        &amp;ngx_kqueue_module,
        &amp;ngx_http_module,
        ...
        &amp;ngx_stream_upstream_zone_module,
        NULL
    };
    ...

</code></pre>
<ol start="6">
<li>
<p>ngx_modules.h的声明引用ngx_modules.c中ngx_modules,如下图所示:
<img src="nginx//webp/install/nginx_core_modules.webp" alt="core_modules图" title="core_modules图" /></p>
</li>
<li>
<p>nginx.c的main函数调用nginx_module.c中ngx_preinit_modules函数,如下图所示:
<img src="nginx//webp/install/nginx_core_nginx.webp" alt="core_nginx图" title="core_nginx图" /></p>
</li>
<li>
<p>nginx_module.c中ngx_preinit_modules函数使用ngx_modules.c中ngx_modules,如下所示:</p>
</li>
</ol>
<pre><code class="language-c">
    ngx_int_t
    ngx_preinit_modules(void)
    {
        ngx_uint_t  i;

        /* 
        ngx_modules变量为ngx_modules.c中定义
        */
        for (i = 0; ngx_modules[i]; i++) {
            ngx_modules[i]-&gt;index = i;
            ngx_modules[i]-&gt;name = ngx_module_names[i];
        }

        ngx_modules_n = i;
        ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES;

        return NGX_OK;
    }

</code></pre>
<ol start="9">
<li>动态配置和静态编译执行在此完美结合起来</li>
</ol>
<h2 id="7-后记"><a class="header" href="#7-后记">7. 后记</a></h2>
<hr />
<ul>
<li>
<p><a href="https://www.nginx.com/resources/wiki/modules/index.html">这里</a>有很多优秀的nginx第三方模块,可供下载使用</p>
</li>
<li>
<p><a href="https://github.com/openresty/echo-nginx-module/">echo-nginx-module模块网址</a></p>
</li>
<li>
<p>安装ssl</p>
</li>
</ul>
<pre><code class="language-sh">    ./configure --prefix=/Users/Shared/nginx \
             --add-module=../nginx-party-module/ngx_http_redis-module \
             --with-http_v2_module \
             --with-http_ssl_module \
             --with-openssl=/opt/homebrew/Cellar/openssl@1.1/1.1.1m\
             --with-debug
</code></pre>
<ul>
<li>http_v2_module不一定需要ssl,浏览器一般强制需要</li>
<li>http_ssl_module需要ssl目录,在linux一般指ssl-devel,需要include/lib目录
<img src="nginx//webp/install/nginx_ssl.webp" alt="nginx_ssl" /></li>
<li>如果make仍然出错,移除掉路径中.openssl/,默认和系统中路径不同,多了一级.openssl/
<img src="nginx//webp/install/nginx_ssl_path.webp" alt="nginx_ssl_path" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="http模块"><a class="header" href="#http模块">HTTP模块</a></h1>
<hr />
<h2 id="核心模块阶段"><a class="header" href="#核心模块阶段">核心模块阶段</a></h2>
<hr />
<pre class="mermaid">
flowchart TD
    subgraph POST_READ
        realip(realip)
    end
    subgraph SERVER_REWRITE
        rewrite(rewrite)
    end
    subgraph FIND_CONFIG
        NULL(NULL)
    end
    subgraph REWRITE
        rewrite2(rewrite)
    end
    subgraph POST_REWRITE
        NULL2(NULL)
    end
    subgraph PREACCESS
        direction LR
        degradation(degradation) --&gt; limit_conn(limit_conn)
        limit_conn --&gt; limit_req(limit_req)
        limit_req --&gt; realip2(realip)
    end
    subgraph ACCESS
        direction LR
        access(access) --&gt; auth(auth)
    end
    subgraph POST_ACCESS
        NULL3(NULL)
    end
    subgraph PRECONTENT
        direction LR
        mirror(mirror) --&gt; try_files(try_files)
    end
    subgraph CONTENT
        direction LR
        static(static) --&gt; gzip_static(gzip_static)
        gzip_static --&gt; dav(dav)
        dav --&gt; autoindex(autoindex)
        autoindex --&gt; index(ndex)
        index --&gt; random_index(random_index)
    end
    subgraph LOG
        log(log)
    end
POST_READ --&gt; SERVER_REWRITE
SERVER_REWRITE --&gt; FIND_CONFIG
FIND_CONFIG --&gt; REWRITE
REWRITE --&gt; POST_REWRITE
POST_REWRITE --&gt; PREACCESS
PREACCESS --&gt; ACCESS
ACCESS --&gt; POST_ACCESS
POST_ACCESS --&gt; PRECONTENT
PRECONTENT --&gt; CONTENT
CONTENT --&gt; LOG

</pre>
<blockquote>
<ul>
<li>
<p>POST_REWRITE阶段如果有rewrite，则会跳回到FIND_CONFIG阶段</p>
</li>
<li>
<p>源代码中定义,如下图所示:
<img src="nginx//webp/http/http_phase.webp" alt="http_phase图" /></p>
</li>
</ul>
</blockquote>
<h2 id="fastcgi模块"><a class="header" href="#fastcgi模块">FastCGI模块</a></h2>
<hr />
<pre class="mermaid">
sequenceDiagram
    actor n as nginx进程
    actor c as CGI进程
    n-&gt;&gt;c: begin_request处理开始
    n-&gt;&gt;c: params请求参数
    n-&gt;&gt;+c: stdin请求数据内容
    c-&gt;&gt;c:请求处理
    c--&gt;&gt;-n: stdout处理结果
    c--&gt;&gt;n: end_request处理结束

</pre>
<h2 id="static模块"><a class="header" href="#static模块">static模块</a></h2>
<hr />
<blockquote>
<p>把请求url中path映射本地路径,读取本地文件返回客户端</p>
<p>核心源代码,如下图所示:
<img src="nginx//webp/http/nginx_static_module.webp" alt="static_module图" /></p>
</blockquote>
<h2 id="index模块"><a class="header" href="#index模块">index模块</a></h2>
<hr />
<blockquote>
<p>引入配置参数index,如下图所示:
<img src="nginx//webp/http/nginx_index_command.webp" alt="index_command图" title="index_command图" /></p>
</blockquote>
<blockquote>
<p>请求url为目录时,把配置参数index值附加在url上,然后内部转跳</p>
</blockquote>
<pre><code class="language-c">

static ngx_int_t
ngx_http_index_handler(ngx_http_request_t *r)
{
    ...
    if (index[i].name.data[0] == '/') {
                return ngx_http_internal_redirect(r, &amp;index[i].name, &amp;r-&gt;args);
            }
    ...

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                       &quot;open index \&quot;%V\&quot;&quot;, &amp;path);

    ...
    return ngx_http_internal_redirect(r, &amp;uri, &amp;r-&gt;args);
}

</code></pre>
<blockquote>
<p>转跳调试日志,如下图所示:
<img src="nginx//webp/http/nginx_index_redirect.webp" alt="index_redirect图" title="index_redirect图" /></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="常用技巧"><a class="header" href="#常用技巧">常用技巧</a></h1>
<hr />
<h3 id="配置片段"><a class="header" href="#配置片段">配置片段</a></h3>
<hr />
<ul>
<li>
<p>http转向https</p>
<pre><code class="language-nginx">
rewrite ^(.*) https://$server_name$1 permanent;
rewrite ^(.*) https://$host$1 permanent;

</code></pre>
<ul>
<li>两种写法,各有适合场合</li>
<li>$server_name, 由nginx配置决定</li>
<li>$host,由请求路径决定</li>
</ul>
</li>
<li>
<p>正向代理</p>
<pre><code class="language-nginx">
server {
    listen 80;
    location / {
        proxy_pass http://$host$request_uri;
    }
}

</code></pre>
<ul>
<li>配合日志,可以用来调试</li>
<li>可以过滤掉特定请求</li>
<li>可以检查http请求是否被拦截</li>
</ul>
</li>
<li>
<p>解决无法加载样式表</p>
<pre><code class="language-nginx"># 否则无法加载样式表
include /etc/nginx/mime.types;
default_type application/octet-stream;
</code></pre>
</li>
<li>
<p>支持http2</p>
<ul>
<li>
<p>自定义安装带上v2,ssl</p>
<pre><code class="language-sh">./configure --prefix=/Users/Shared/nginx \
            --with-http_v2_module \
            --with-http_ssl_module \
            --with-openssl=/opt/homebrew/Cellar/openssl@1.1/1.1.1m\
            --with-debug
</code></pre>
</li>
<li>
<p>配置增加上http2</p>
<pre><code class="language-nginx">...
server {
        # 默认情况http2都走ssl,所以在ssl加上http2
        listen 443 ssl http2;
        ...
}
...
</code></pre>
</li>
</ul>
</li>
<li>
<p>支持http3</p>
<ul>
<li>
<p>自定义安装带上v3,ssl,brotli</p>
<pre><code class="language-sh">./auto/configure --with-http_v3_module \
    --with-stream_quic_module      \
    --with-http_ssl_module \
    --with-http_v2_module \
    --add-module=../ngx_brotli \
    --with-cc-opt=&quot;-I../libressl/build/include&quot; \
    --with-ld-opt=&quot;-L../libressl/build/lib&quot;
</code></pre>
</li>
<li>
<p>配置增加上http3</p>
<pre><code class="language-nginx">...
http {
    brotli on;
    brotli_comp_level 6;
    brotli_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;
    server {
            # 默认情况http2都走ssl,所以在ssl加上http2
            listen 443 ssl http2;
            listen 443 http3 reuseport; # UDP listener for QUIC+HTTP/3,在主域名表示reuseport，否则会提示冲突
            ssl_protocols TLSv1.3; # QUIC requires TLS 1.3
            # 一定要添加头部，否则无法开启
            add_header alt-svc 'h3=&quot;:443&quot;; ma=86400;quic=&quot;:443&quot;; ma=2592000; v=&quot;46,43&quot;, h3-Q050=&quot;:443&quot;; ma=2592000, h3-Q049=&quot;:443&quot;; ma=2592000, h3-Q048=&quot;:443&quot;; ma=2592000,h3-Q046=&quot;:443&quot;; ma=2592000, h3-Q043=&quot;:443&quot;; ma=2592000, h3-23=&quot;:443&quot;; ma=2592000'; 
            ...
    }
    ...
}
...
</code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="nginx/webp/use/http3_brotli.webp" alt="效果图" title="效果图" /></p>
<ul>
<li>
<p>四层代理-stream</p>
<ul>
<li>
<p>自定义安装带上stream</p>
<pre><code class="language-sh">./configure --prefix=/Users/Shared/nginx \
            --with-stream \
            --with-debug

make &amp;&amp; make install
</code></pre>
</li>
<li>
<p>配置增加上stream</p>
<pre><code class="language-nginx">...
stream {
    server {
        listen 8411;
        proxy_timeout 3s;
        proxy_pass xxx:8411;
    }
}
...
</code></pre>
</li>
</ul>
</li>
<li>
<p>gzip-压缩支持</p>
<pre><code class="language-nginx">...
http {
    # 打开gzip指令，否则后面不会生效
    gzip on;
    # 回包头部增加content-encoding: gzip
    gzip_vary on;
    # 压缩类型
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;
}
...
</code></pre>
</li>
<li>
<p><a href="http://nginx.org/en/docs/http/ngx_http_mirror_module.html">映像/复制mirror</a></p>
<pre><code class="language-nginx">location / {
    #可以多次映像/复制,从而起到放大流量功能
    #产生一个http subrequest &quot;/mirror?&quot;,跳转到相应location
    #所以mirror结果(包括超时,服务器关闭,50x,40x等等),不影响这个本身速度及结果
    #但是占用内存,消费conn连接池之类还是要的
    #mirror /mirror;
    #mirror /mirror;
    mirror /mirror;
    #允许丢掉body
    #mirror_request_body off;
    proxy_pass http://backend;
}

location = /mirror {
    # 判断请求方法，不是GET返回403,用其他类似手段缩小流量规模
    # if ($request_method != GET) {
    #     return 403;
    # }
    internal;
    #这里的回包是忽略
    proxy_pass http://test_backend$request_uri;
    #允许丢掉body
    #proxy_pass_request_body off;
    #proxy_set_header Content-Length &quot;&quot;;
    proxy_set_header X-Original-URI $request_uri;
}
</code></pre>
</li>
<li>
<p>利用日志调试</p>
<pre><code class="language-nginx">server {
    ...
    #降低错误日志等级,例如notice,如果编译带有--with-debug,则可以debug,debug_http
    error_log  logs/error.log  info;

    #不同路径不同access日志文件,确认哪个loc使用
    location /hello {
        ...
        access_log logs/hello_access.log;
        ...
    }

    location /world {
        ...
        access_log logs/world_access.log;
        ...
    }
    ...
}
</code></pre>
</li>
<li>
<p>root与alias区别</p>
</li>
</ul>
<pre><code class="language-nginx"># 请求/abc/123 ==&gt; /var/www/app/static/abc/123
location /abc {
    # In case of the root directive, full path is appended to the root including the location part
    # 请求的path附加上root指定path,组合本地路径
    root /var/www/app/static;
    autoindex off;
}

# 请求/abc/123 ==&gt; /var/www/app/static/123
location /abc {
    # only the portion of the path NOT including the location part is appended to the alias.
    # 请求的path移除掉location的path,再附加上alias指定path,组合本地路径
    alias /var/www/app/static;
    autoindex off;
}
</code></pre>
<h3 id="常用模块"><a class="header" href="#常用模块">常用模块</a></h3>
<hr />
<ul>
<li>
<p>http_memcached模块</p>
<pre><code class="language-nginx">...
location /memcached {
    set $memcached_key &quot;$uri&quot;;
    memcached_pass 127.0.0.1:11211;
    #指示返回为html,方便浏览器直接显示
    default_type   text/html;
    error_page 404 502 504 = @notexit;
}

location @notexit {
    #echo为第三方模块引入指令,方便调试
    echo &quot;noexit$uri&quot;;
}
...
</code></pre>
</li>
</ul>
<pre class="mermaid">
sequenceDiagram
actor u as user
actor n as nginx
actor m as memcached
u-&gt;&gt;n: http请求/memcached
n-&gt;&gt;m: get命令key值为$uri(/memcached)
m-&gt;&gt;n: 存在则返回值,否则返回空
n-&gt;&gt;u: 成功获取,则直接返回,否则转跳notexit

</pre>
<ul>
<li>
<p>ngx_http_redis第三方模块,类似http_memcached</p>
<pre><code class="language-sh">./configure --prefix=/Users/Shared/nginx \
            --add-module=../nginx-party-module/ngx_http_redis-module \
            ...
            --with-debug

make &amp;&amp; make install

</code></pre>
<pre><code class="language-nginx">...
location /redis {
    set $redis_key &quot;$uri&quot;;
    redis_pass     127.0.0.1:6379;
    #指示返回为html,方便浏览器直接显示
    default_type   text/html;
    error_page 404 502 504 = @notexit;
}

location @notexit {
    #echo为第三方模块引入指令,方便调试
    echo &quot;noexit$uri&quot;;
}
...
</code></pre>
</li>
</ul>
<pre class="mermaid">
sequenceDiagram
actor u as user
actor n as nginx
actor m as redis
u-&gt;&gt;n: http请求/redis
n-&gt;&gt;m: get命令key值为$uri(/redis)
m-&gt;&gt;n: 存在则返回值,否则返回空
n-&gt;&gt;u: 成功获取,则直接返回,否则转跳notexit

</pre>
<ul>
<li>
<p>redis2-nginx-module第三方模块,更强大更多操作</p>
<pre><code class="language-sh">./configure --prefix=/Users/Shared/nginx \
            --add-module=../nginx-party-module/redis2-nginx-module \
            --with-debug


make
make install
</code></pre>
<pre><code class="language-nginx">...
location = /foo {
    set $value '&lt;html&gt;&lt;H1&gt;From Nginx Redis&lt;/H1&gt;&lt;/html&gt;';
    redis2_query set one $value;
    redis2_pass 127.0.0.1:6379;
}


location = /get {
    redis2_query get one;
    redis2_pass 127.0.0.1:6379;
}
...
</code></pre>
</li>
</ul>
<pre class="mermaid">
sequenceDiagram
actor u as user
actor n as nginx
actor r as redis
u-&gt;&gt;n: http请求/get
n-&gt;&gt;r: get命令key值为one
r-&gt;&gt;n: 标准命令处理
n-&gt;&gt;u: 返回原始键值

</pre>
<h3 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h3>
<hr />
<ul>
<li>
<p>server_names_hash问题</p>
<pre><code class="language-sh">[emerg] could not build server_names_hash, you should increase server_names_hash_bucket_size: 32
</code></pre>
</li>
<li>
<p>解决办法</p>
<pre><code class="language-nginx"># 如果不够,继续增加,大小必须是32*n
server_names_hash_bucket_size 64;
</code></pre>
</li>
<li>
<p>invalid request问题</p>
<pre><code class="language-sh"># asscess.log 有这种提示
&quot;PRI * HTTP/2.0&quot; 400 157 &quot;-&quot; &quot;-&quot;
# error.log 有这种提示
client sent invalid request while reading client request line
</code></pre>
</li>
<li>
<p>解决办法-客户端没有采用ssl,tls,但访问nginx配置需要ssl</p>
</li>
<li>
<p>php-fpm出现Primary script unknown问题</p>
<ul>
<li>
<p>尝试修改nginx配置</p>
<pre><code class="language-nginx">
# FastCGI sent in stderr: &quot;Primary script unknown&quot; while reading response header from upstream,
# fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;

</code></pre>
</li>
<li>
<p>如果仍然不行,则打开php-fpm.conf日志配置</p>
<pre><code class="language-nginx">
access.log = /var/log/php-fpm.$pool.access.log

</code></pre>
</li>
<li>
<p>再打开nginx日志配置</p>
<pre><code class="language-nginx">
# http
log_format scripts '$document_root$fastcgi_script_name &gt; $request';
# server
access_log /usr/local/nginx/scripts.log scripts;

</code></pre>
</li>
<li>
<p>重启nginx,和php-fpm 查看日志,一般是路径不对和权限不对</p>
</li>
</ul>
</li>
<li>
<p>php-fpm出现无法连接数库,可能是编译参数不对</p>
<pre><code class="language-sh">
./configure --enable-fpm --prefix=/usr/local/php --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd

</code></pre>
</li>
<li>
<p>不知道当前nginx所用配置文件</p>
<pre><code class="language-sh"># 获取nginx进程号
ps -ef | grep nginx
# 获取nginx路径
cd /proc/pid
ls -a
# 执行相应路径的语法测试,输出就能看到路径
nginx -t
</code></pre>
</li>
<li>
<p>不知道当前nginx的编译参数</p>
<pre><code class="language-sh"># 获取nginx进程号
ps -ef | grep nginx
# 获取nginx路径
cd /proc/pid
ls -a
# 执行相应路径的语法测试,输出就能看到路径
nginx -V
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="rtmp"><a class="header" href="#rtmp">rtmp</a></h1>
<hr />
<h3 id="下载安装rtmp模块"><a class="header" href="#下载安装rtmp模块"><a href="https://github.com/arut/nginx-rtmp-module">下载安装rtmp模块</a></a></h3>
<h3 id="编译"><a class="header" href="#编译">编译</a></h3>
<pre><code class="language-sh">/configure --prefix=/Users/Shared/nginx \
             --add-module=../nginx-party-module/nginx-rtmp-module \
             --with-http_ssl_module \
             --with-openssl=/opt/homebrew/Cellar/openssl@1.1/1.1.1m\
             --with-debug
make
make install
</code></pre>
<h3 id="修改配置"><a class="header" href="#修改配置">修改配置</a></h3>
<pre><code class="language-nginx">rtmp {
    server {
        listen 1935;
        application vod {
            play /Users/xxx/iCloud-archive/video;
        }
    }
}
</code></pre>
<h3 id="访问"><a class="header" href="#访问">访问</a></h3>
<pre><code class="language-sh">#vlc打开串流地址
rtmp://host/vod/xxx.mp4
</code></pre>
<h3 id="附录"><a class="header" href="#附录">附录</a></h3>
<ul>
<li>
<p>RTMP、RTSP、HTTP协议理论上都可以用来做视频直播或点播,直播一般用RTMP,RTSP,点播用 HTTP</p>
</li>
<li>
<p>RTMP协议</p>
<ul>
<li>是流媒体协议。</li>
<li>RTMP协议是 Adobe 的私有协议，未完全公开。</li>
<li>RTMP协议一般传输的是 flv，f4v 格式流。</li>
<li>RTMP一般在 TCP 1个通道上传输命令和数据。</li>
</ul>
</li>
<li>
<p>RTSP协议</p>
<ul>
<li>是流媒体协议。</li>
<li>RTSP协议是共有协议，并有专门机构做维护</li>
<li>RTSP协议一般传输的是 ts、mp4 格式的流。</li>
<li>RTSP传输一般需要 2-3 个通道，命令和数据通道分离。</li>
</ul>
</li>
<li>
<p>HTTP协议</p>
<ul>
<li>不是是流媒体协议。</li>
<li>HTTP协议是共有协议，并有专门机构做维护</li>
<li>HTTP协议没有特定的传输流</li>
<li>HTTP传输一般需要 2-3 个通道，命令和数据通道分离</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="golang"><a class="header" href="#golang">golang</a></h1>
<hr />
<h3 id="官网"><a class="header" href="#官网"><a href="https://go.dev/">官网</a></a></h3>
<hr />
<ul>
<li><a href="https://go.extension.sh/">Go Search Extension</a>浏览器扩展, 地址栏输入go+空格启用
<img src="golang//webp/golang/golang_gosearch.webp" alt="golang_gosearch" /></li>
<li>golang.org国内经常访问不了</li>
<li>通过go bulid -tags 实现编译控制</li>
<li>内置数据类型定义在runtime包,如下图所示
<img src="golang//webp/golang/golang_runtime.webp" alt="源码" /></li>
<li>吐槽一下
<ul>
<li>破坏注释不影响代码的传统,这类//go:注释,有特别含义,会影响代码作用,使用者非常容易误解</li>
<li>强制mod方式管理第三方模块
<ul>
<li>用代码库+版本解决依赖</li>
<li>带来重大著名库大量重复存在,GOPATH成垃圾桶
<img src="golang//webp/golang/golang_gopath_x.webp" alt="go path x" /></li>
<li>带来更多名词,增加心智负担,精力分散在语言之外过多</li>
<li>严重偏向开源开发模式,对闭源开发不友好</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<hr />
<pre><code class="language-sh"># 安装到默认目录
rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz
# 导出环境变量
export PATH=$PATH:/usr/local/go/bin
# 查看安装成功否
go version

#列出环境变量
go env

#GOPATH环境变量,如果没有手动设置,默认为$HOME/go
GOPATH=$HOME/go

#模块缓存是 go 命令存储下载模块文件的目录,默认是$GOPATH/pkg/mod.
GOMODCACHE
#清除mod cache,pkg目录里面全没了
go clean --modcache

#Build Cache意思就是会把编译过程的中间结果cache下来，从而实现增量编译。
#Test cache，在内容没有变化的情况下，对于同样的参数的测试，会直接使用cache的测试结果
#cache默认的存储路径是操作系统所确定的用户缓存目录，但是可以通过GOCACHE环境变量修改
GOCACHE

#清除build cache
go clean -cache
#清除test cache
go clean -testcache

#GOPROXY(公共)修改为国内代理
#全球代理https://proxy.golang.com.cn(https://goproxy.io/)
#阿里云 https://mirrors.aliyun.com/goproxy/
#七牛云 https://goproxy.cn
#direct表示直接从包路径下载
go env -w GOPROXY=https://goproxy.cn,direct

#GOPRIVATE设置私有库
#还可以设置不走 proxy 的私有仓库或组，多个用逗号相隔（可选）
#允许通配符
go env -w GOPRIVATE=git.mycompany.com,github.com/my/private,*.example.com

#GOVCS变量
#可以使用git下载带有 github.com 路径的模块；无法使用任何版本控制命令下载 evil.com上的路径
#使用 git 或 hg 下载所有其他路径（* 匹配所有内容）的模块。
GOVCS=github.com:git,evil.com:off,*:git|hg

#GOSUMDB变量
#默认的GOSUMDB=sum.golang.org验证包的有效性,经常访问不了
go env -w GOSUMDB=off
#使用国内代理
go env -w GOSUMDB=https://goproxy.cn/sumdb/sum.golang.org,sum.golang.org
</code></pre>
<ul>
<li>
<p>GOPROXY说明</p>
<ul>
<li>You can set the variable to URLs for other module proxy servers, separating URLs with either a comma or a pipe.</li>
<li>When you use a comma, Go tools will try the next URL in the list only if the current URL returns an HTTP 404 or 410.</li>
</ul>
<pre><code class="language-sh">GOPROXY=&quot;https://proxy.example.com,https://proxy2.example.com&quot;
</code></pre>
<ul>
<li>When you use a pipe, Go tools will try the next URL in the list regardless of the HTTP error code.</li>
</ul>
<pre><code class="language-sh">GOPROXY=&quot;https://proxy.example.com|https://proxy2.example.com&quot;
</code></pre>
</li>
<li>
<p>GOPRIVATE说明</p>
<ul>
<li>The GOPRIVATE or GONOPROXY environment variables may be set to lists of glob patterns matching module prefixes that are private and should not be requested from any proxy.</li>
</ul>
</li>
<li>
<p>GOVCS说明</p>
<ul>
<li>版本控制工具中的错误可能被恶意服务器利用来运行恶意代码</li>
<li>如果未设置环境变量GOVCS,或者不匹配,GOVCS的默认处理:允许 git 和 hg 用于公共模块,并且允许所有工具用于私有模块。</li>
</ul>
</li>
</ul>
<h3 id="go-mod命令指南"><a class="header" href="#go-mod命令指南"><a href="https://go.dev/doc/modules/gomod-ref">go mod命令指南</a></a></h3>
<hr />
<p><img src="golang//webp/golang/golang_package.webp" alt="golang_package" /></p>
<pre><code class="language-sh">#最后结果都是写入go.mod文件
go mod init path
go mod edit --replace modulepath=otherpath
go mod edit --exclude modulepath
#tidy整理依赖,增加没有添加或移除未引用等
go mod tidy
#整检依赖是否正解
go mod verify
</code></pre>
<ul>
<li><strong>采用mod方式管理依赖,则没有gopath/src,改到gopath/mod</strong></li>
<li><strong>go.sum不需要手工维护,也不要手工改动</strong></li>
<li><strong>所有的子目录里的依赖都组织在根目录的go.mod文件</strong></li>
<li>replace指令场景
<ul>
<li>替换无法下载的包</li>
<li>替换本地自己的包</li>
<li>替换 fork 包</li>
</ul>
</li>
<li>exclude显式的排除某个包的某个版本,例如某个版本有严重bug,如果其他包引用这个版本,就会自动跳过这个版本</li>
<li><a href="https://zhuanlan.zhihu.com/p/126561786">文章</a>介绍较直白</li>
<li><a href="https://segmentfault.com/a/1190000039359906">文章</a>介绍<strong>retract</strong>指令
<img src="golang//webp/golang/golang_mod.webp" alt="go mod" /></li>
</ul>
<h3 id="工作区-多模块"><a class="header" href="#工作区-多模块"><a href="https://go.dev/ref/mod#workspaces">工作区-多模块</a></a></h3>
<hr />
<pre><code class="language-sh">#最后结果都是写入go.work文件
Usage:
 go work &lt;command&gt; [arguments]
The commands are:
 edit        edit go.work from tools or scripts
 init        initialize workspace file
 sync        sync workspace build list to modules
 use         add modules to workspace file
</code></pre>
<ul>
<li>workspace目录</li>
</ul>
<p><img src="golang//webp/golang/golang_workspace.webp" alt="go work" /></p>
<ul>
<li>go.work内容</li>
</ul>
<pre><code class="language-sh">#go work use ./hello
#go work use ./example
#./hello,./example是本地路径,不是example,hello的module名
go 1.18

use (
 ./example
 ./hello
)
</code></pre>
<ul>
<li>hello/main.go内容</li>
</ul>
<pre><code class="language-golang">package main

import (
 &quot;fmt&quot;

 &quot;golang.org/x/example/stringutil&quot;
)

func main() {
 fmt.Println(stringutil.ToUpper(&quot;Hello&quot;))
}

</code></pre>
<ul>
<li>hello/go.mod内容</li>
</ul>
<pre><code class="language-sh">module example.com/hello
go 1.18
require golang.org/x/example v0.0.0-20220304235025-ad95e7f791d8 // indirect
</code></pre>
<ul>
<li>
<ol>
<li>在workspace目录下运行go run example.com/hello</li>
</ol>
</li>
<li>
<ol start="2">
<li>不用改动go.mod,使得golang.org/x/example由本工作区的example替代</li>
</ol>
</li>
<li>
<ol start="3">
<li>可实现多模块同时开发</li>
</ol>
</li>
</ul>
<h3 id="相关工具go-tools"><a class="header" href="#相关工具go-tools">相关工具go tools</a></h3>
<hr />
<h4 id="getinstall下载包过程"><a class="header" href="#getinstall下载包过程">get/install下载包过程</a></h4>
<pre><code class="language-golang">// import &quot;example.org/pkg/foo&quot;
//
// will result in the following requests:
//
// https://example.org/pkg/foo?go-get=1 (preferred)
// http://example.org/pkg/foo?go-get=1  (fallback, only with use of correctly set GOINSECURE)
//
// If that page contains the meta tag
//
// &lt;meta name=&quot;go-import&quot; content=&quot;example.org git https://code.org/r/p/exproj&quot;&gt;
//
// the go tool will verify that https://example.org/?go-get=1 contains the
// same meta tag and then git clone https://code.org/r/p/exproj into
// GOPATH/src/example.org.
// go get/install当服务器支持多种协议优先使用https://, 然后git+ssh://.
</code></pre>
<p><img src="golang//webp/golang/golang_go_get.webp" alt="go_get" /></p>
<pre><code class="language-sh">#包括godoc等工具
#./godoc -http :6060
go install golang.org/x/tools/...@latest.

#浏览器本地文档，如果起启目录有go.mod会继续分析提供文档,但是增加启动时间
godoc -http :6060

#安装pprof,如果不在mod目录下运行,就指明@latest最近版本
go install github.com/google/pprof@latest

#下载最新版本
go get example.com/theirmodule@vlatest
#下载指定版本
go get example.com/theirmodule@v1.3.4
go get example.com/theirmodule@4cf76c2
go get example.com/theirmodule@bugfixes
#移除指定版本模块
go get example.com/theirmodule@none
#查看所有依赖模块的最新版本
go list -m -u all
#查看指定模块的最新版本
go list -m -u example.com/theirmodule

#升级后会将新的依赖版本更新到go.mod
go get -u need-upgrade-package
#升级所有依赖
go get -u 


go tool pprof

go tool trace

#获取当前git hash
Cgithash=$(git rev-parse --short HEAD)
#获取当前时间
Ctime=$(date '+%Y-%m-%d_%H:%M:%S')

# 交叉编译
# 禁止cgo
# 设置编译目标平台
# 设置编译芯片体系
#-s: 去掉符号表; -w:去掉调试信息，不能gdb调试了;
CGO_ENABLED=0 GOARCH=amd64 GOOS=linux go build -o ${target} -ldflags &quot;-s -w -X main.GitHash=${Cgithash} -X main.CompileTime=${Ctime}&quot; main.go


#获取程序更多信息(包括-ldflags参数设置)
go version -m 二进制可执行文件

#新增inittrace指令, 用于init调试和启动时间的概要分析
GODEBUG=inittrace=1 go run main.go 

#简化代码
gofmt -s -w xxx.go
</code></pre>
<p><img src="golang//webp/golang/golang_godoc.webp" alt="golang_godoc" /></p>
<ul>
<li><a href="https://eddycjy.com/posts/go/tools/2018-09-15-go-tool-pprof/">文章</a>介绍pprof</li>
<li><a href="https://eddycjy.com/posts/go/tools/2019-07-12-go-tool-trace/">文章</a>介绍trace</li>
<li><a href="https://taoshu.in/go/create-protoc-plugin.html">创建protoc插件</a></li>
</ul>
<h5 id="golangci-lint替代品lint-静态检查库"><a class="header" href="#golangci-lint替代品lint-静态检查库"><a href="https://github.com/golangci/golangci-lint">golangci-lint</a>,替代品<a href="https://github.com/mgechev/revive">lint-静态检查库</a></a></h5>
<pre><code class="language-sh">#快速安装,会自动下载依赖安装对应的go版本,如果系统安装有go,那么注意搜索PATH
brew install golangci-lint

#手动下载,选择最新及相应的平台,最新版本在go1.18有部分lint不支持,需要适时更新
https://github.com/golangci/golangci-lint/releases


#较大规模项目,或第一次运行应该增加超时选择
#golangci-lint会采用缓存,如果环境变没有设置,则采用系统默认设置
golangci-lint run --timeout=1h

#GolangCI-Lint looks for config files in the following paths from the current working directory:

.golangci.yml
.golangci.yaml
.golangci.toml
.golangci.json

#这几个参数比较有用
  skip-dirs:
    - src/external_libs
    - autogenerated_by_my_lib
  # Enables skipping of directories:
  # - vendor$, third_party$, testdata$, examples$, Godeps$, builtin$
  # Default: true
  skip-dirs-use-default: false
  # Which files to skip: they will be analyzed, but issues from them won't be reported.
  # Default value is empty list,
  # but there is no need to include all autogenerated files,
  # we confidently recognize autogenerated files.
  # If it's not please let us know.
  # &quot;/&quot; will be replaced by current OS file path separator to properly work on Windows.
  skip-files:
    - &quot;.*\\.my\\.go$&quot;
    - lib/bad.go
</code></pre>
<h5 id="小米出品-soar-sql优化改写"><a class="header" href="#小米出品-soar-sql优化改写"><a href="https://github.com/XiaoMi/soar">小米出品-Soar-sql优化改写</a></a></h5>
<pre><code class="language-sh">
#手动下载,选择最新及相应的平台,老黄历版本啦!
https://github.com/XiaoMi/soar/releases

#源码安装,报gopath/pkg/mod/github.com/!xiao!mi/soar@v0.8.1/ast/tidb.go:24:2: ambiguous import:
#解决办法:跳过此种方式，估计没有指到最新版本,没心情找原因
go install github.com/XiaoMi/soar/cmd/soar@latest

#最原始办法
git clone https://github.com/XiaoMi/soar.git
cd soar
make

#测试使用
echo 'select * from film' | ./soar
</code></pre>
<h3 id="go-generate命令"><a class="header" href="#go-generate命令">go generate命令</a></h3>
<ul>
<li>
<p>当运行go generate时,它将扫描与当前包相关的源代码文件,找出所有包含&quot;//go:generate&quot;的特殊注释</p>
</li>
<li>
<p>提取并执行该特殊注释后面的命令,命令为可执行程序，形同shell下面执行</p>
<ul>
<li>该特殊注释必须在.go源码文件中。</li>
<li>每个源码文件可以包含多个generate特殊注释时。</li>
<li>显示运行go generate命令时，才会执行特殊注释后面的命令。</li>
<li>命令串行执行的，如果出错，就终止后面的执行。</li>
<li>特殊注释必须以&quot;//go:generate&quot;开头，双斜线后面没有空格。</li>
</ul>
</li>
<li>
<p>应用</p>
<ul>
<li>yacc：从 .y 文件生成 .go 文件。</li>
<li>protobufs：从 protocol buffer 定义文件（.proto）生成 .pb.go 文件。</li>
<li>Unicode：从 UnicodeData.txt 生成 Unicode 表</li>
</ul>
</li>
</ul>
<pre><code class="language-sh">go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
</code></pre>
<ul>
<li>
<p>参数说明如下：</p>
<ul>
<li>-run 正则表达式匹配命令行，仅执行匹配的命令；</li>
<li>-v 输出被处理的包名和源文件名；</li>
<li>-n 显示不执行命令；</li>
<li>-x 显示并执行命令；</li>
<li>command 可以是在环境变量 PATH 中的任何命令。</li>
</ul>
</li>
</ul>
<h3 id="核心语法"><a class="header" href="#核心语法">核心语法</a></h3>
<hr />
<ul>
<li>
<p>逃逸分析</p>
<ul>
<li>
<p>目标:减轻堆内存分配开销，减少gc压力，提高运行性能</p>
</li>
<li>
<p>编译器会做逃逸分析(escape analysis),变量的作用域没有跑出函数范围，在栈上，反之在堆上。</p>
</li>
<li>
<p>实践</p>
<pre><code class="language-sh">#输出分析结果
go build -gcflags '-m -l' main.go
#反汇编查看,出现runtime.newobject,就发现逃逸行为
go tool compile -S main.go
</code></pre>
<p><img src="golang//webp/golang/golang_escape.webp" alt="golang_escape" /></p>
</li>
<li>
<p>结论</p>
<ul>
<li>
<p>常见逃逸</p>
<ul>
<li>
<p>在某个函数中new或字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸（构造函数返回的指针变量一定逃逸）；
&gt;建议:调用方传入参，被调用方直接把结果存进去
&gt;
&gt;比如 read 函数的签名是 read([]byte)，而不是 read() []byte，就是为了避免堆分配.</p>
</li>
<li>
<p>被已经逃逸的变量引用的指针，一定发生逃逸；</p>
</li>
<li>
<p>被指针类型的slice、map和chan引用的指针,一定发生逃逸,所以slice,map,chan尽管传值,不使用传指针,除非超大复制量；</p>
</li>
<li>
<p>申请超大容量变量,栈空间是有限的</p>
</li>
<li>
<p>作为fmt.printxxx参数,没事少用点</p>
</li>
<li>
<p>make,new,字面量初始化变量都一样要逃逸分析</p>
</li>
</ul>
</li>
<li>
<p>常见不逃逸</p>
<ul>
<li>指针被未发生逃逸的变量引用；</li>
<li>仅仅在函数内对变量做取址操作，而未将指针传出；</li>
</ul>
</li>
<li>
<p>可能发生逃逸</p>
<ul>
<li>将指针作为入参传给别的函数；这里还是要看指针在被传入的函数中的处理过程，如果发生了上边的三种情况，则会逃逸；否则不会逃逸；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>泛型</p>
<ul>
<li>类型参数：泛型的抽象数据类型。</li>
</ul>
<pre><code class="language-sh">TypeParameters  = &quot;[&quot; TypeParamList [ &quot;,&quot; ] &quot;]&quot; .
TypeParamList   = TypeParamDecl { &quot;,&quot; TypeParamDecl } .
TypeParamDecl   = IdentifierList TypeConstraint .
</code></pre>
<ul>
<li>类型约束：确保调用方能够满足接受方的程序诉求。</li>
</ul>
<pre><code class="language-sh">TypeConstraint = TypeElem .
TypeElem       = TypeTerm { &quot;|&quot; TypeTerm } .
TypeTerm       = Type | UnderlyingType .
UnderlyingType = &quot;~&quot; Type .
</code></pre>
<pre><code class="language-golang">/*
内置comparable类型约束
comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable.*/
type comparable interface{ comparable }
</code></pre>
<ul>
<li>
<p>类型推导：避免明确地写出一些或所有的类型参数。</p>
</li>
<li>
<p>为保证GO1兼容性,标准库并没有引入泛型,试验性在golang.org/x/exp里</p>
</li>
</ul>
</li>
<li>
<p>Go 1.15 增加了一个新程序包，time/tzdata。该程序包允许将时区数据库嵌入程序中</p>
</li>
<li>
<p>Go1.16 开始禁止 import 导入的模块以 . 开头，模块路径中也不允许出现任何非 ASCII 字符</p>
</li>
<li>
<p>Go 1.16 新增的 embed 包支持资源嵌入</p>
</li>
</ul>
<pre><code class="language-golang">//把资源文件打包到二进制文件中
import (
 &quot;fmt&quot;
 //go1.16引入新的标准库
 _ &quot;embed&quot;
 &quot;runtime/debug&quot;
)
//golang特有编译器指示,类似//go:noinline,go:build
//go:embed hello.txt
var hello string

func main() {
  //调试好帮手,打印出调用栈
  debug.PrintStack()
  fmt.Println(&quot;hello:&quot;, hello)
}
</code></pre>
<ul>
<li>弃用 io/ioutil,已移至其他程序包</li>
<li>timer性能提升,defer的性能，几乎是零开销</li>
<li>合并结构体标签tag设置标识</li>
</ul>
<pre><code class="language-golang">type MyStruct struct {
  Field1 string `json:&quot;field_1,omitempty&quot; bson:&quot;field_1,omitempty&quot; xml:&quot;field_1,omitempty&quot; form:&quot;field_1,omitempty&quot; other:&quot;value&quot;`
}
// 就可以通过合并的
type MyStruct struct {
  Field1 string `json,bson,xml,form:&quot;field_1,omitempty&quot; other:&quot;value&quot;`
}
</code></pre>
<ul>
<li>
<p>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等.这篇<a href="https://zhuanlan.zhihu.com/p/425199722">文章</a>解释清楚.</p>
<ul>
<li>上游的信息共享给下游任务</li>
<li>上游可发送取消信号给所有下游任务,不会直接干涉和中断下游任务的执行,下游任务自行决定后续的处理操作.</li>
<li>下游任务自行取消不会影响上游任务</li>
<li>源码不理解?
<img src="golang//webp/golang/golang_context_why1.webp" alt="why1" />
<img src="golang//webp/golang/golang_context_why2.webp" alt="why2" /></li>
</ul>
</li>
<li>
<p>字符串,只读的切片,写入操作都是通过拷贝实现的。</p>
</li>
</ul>
<pre><code class="language-golang">// 原始,特别适合不要转义
var rawString  = `\n \b \s \u`
// 带转义
normalStr := &quot;aabbcc&quot;

// 从string转[]byte，从[]byte转string,都是拷贝数据
// 而内存拷贝的性能损耗会随着字符串和 []byte 长度的增长而增长。
</code></pre>
<ul>
<li>数字字面量,下划线只为美观</li>
</ul>
<pre><code class="language-golang">// 二进制110
var binary = 0b1_1_0
// 十进制712
var digit = 7_1_2
// 向下取整,div=3
var div = 7 / 2 
</code></pre>
<ul>
<li>数组</li>
</ul>
<pre><code class="language-golang">//明确指出
arr1 := [3]int{1, 2, 3}
//编译器推定
arr2 := [...]int{1, 2, 3}

/*
数组元素+数组大小相同才是同一类型，才能相等
*/
</code></pre>
<ul>
<li>切片</li>
</ul>
<pre><code class="language-golang">//使用下标初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片
arr[0:3] or slice[0:3]
//最终转化为上面方式
slice := []int{1, 2, 3}
//如果len/cap较小，最终转化为上面方式,否则运行时处理
slice := make([]int, 10)

/*
make([]type, len) 相当于 make([]type, len, len)

b ;= a[low : high : max]
b[0] = a[low]
len(b) = high-low
cap(b) = max - low

a[low:high] 相当于 a[low : high : cap(a)]
a[:high] 相当于 a[0:high]
a[low:] 相当于 a[low:len(a)]
a[:] 相当于 a[0:len(a)]
*/
</code></pre>
<ul>
<li>map
<ul>
<li>cap理论上都是无穷的,使用自动扩容</li>
<li>内置的map多协程操作不安全</li>
<li>sync.map是多协程安全</li>
</ul>
</li>
</ul>
<pre><code class="language-golang">//len是0
firstMap := make(map[string]int)
//len是0,10只是帮助初次cap大小
secMap := make(map[string]int, 10)
//len是2,
threeMap := map[string]int{
  &quot;one&quot;: 1,
  &quot;two&quot;: 2,
 }

// 一般建议这种访问,区别val是否有效
val, exist := threeMap[&quot;one&quot;] 
delete(threeMap, &quot;two&quot;)
</code></pre>
<ul>
<li>
<p>函数</p>
<ul>
<li>
<p>参数的计算是从左到右</p>
</li>
<li>
<p>参数是<strong>值传递</strong>,返回值也是<strong>值传递</strong>,影响深远
<img src="golang//webp/golang/golang_pass_value.webp" alt="pass_value" /></p>
</li>
<li>
<p>slice,make,chan底层实现struct中包括指针,从而实现引用效果</p>
</li>
</ul>
</li>
<li>
<p>接口</p>
<ul>
<li>runtime.iface带方法,runtime.eface不带方法,两种不同.</li>
</ul>
<pre><code class="language-golang">
type eface struct {

_type *_type
data  unsafe.Pointer

}

  type iface struct {
tab  *itab
data unsafe.Pointer
}

type itab struct {
inter *interfacetype
_type*_type
// 类型断言时使用,复制_type中hash
hash  uint32
...
fun   [1]uintptr
}

type _type struct {
...
ptrdata    uintptr
// 类型断言时使用
hash       uint32
...
equal      func(unsafe.Pointer, unsafe.Pointer) bool
...
}

</code></pre>
<ul>
<li>隐式实现,区别其他语言</li>
<li>接口本身为nil,和接口值为nil是两回事</li>
<li>直接调用OR动态派发?编译器优化会把动态派发改为直接调用,以减少性能的额外开销.</li>
</ul>
<pre><code class="language-golang">type Person interface {

Speak()
}

type Man struct {
Voice string
}

func (m *Man) Speak() {
fmt.Println(&quot;Voice:&quot;, m.Voice)
}

func main() {
m := &amp;Man{Voice: &quot;firstMan&quot;}
var p Person = m
//直接调用,类型转换是编译期完成
p.(*Man).Speak()
//动态派发,比直接调用多取出data和fun两个动作
p.Speak()
}

</code></pre>
</li>
<li>
<p>gc</p>
<ul>
<li>
<p>暂停程序（Stop the world，STW），随着程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行.</p>
</li>
<li>
<p>垃圾收集可以分成清除终止、标记、标记终止和清除</p>
</li>
<li>
<p>用户程序,分配器,gc收集器,head关系图</p>
</li>
</ul>
</li>
</ul>
<pre class="mermaid">
  sequenceDiagram
      actor m as 用户程序
      actor a as 分配器
      actor h as heap堆内存
      actor c as gc收集器
      m-&gt;&gt;a: make/new等申请内存
      a-&gt;&gt;h: malloc申请,初始化
      c--&gt;&gt;h: free释放内存

</pre>
<pre><code>
  * 栈空间,不用码农操作心, 大致了解连续栈,栈扩容,栈收缩一下

* 反射,影响性能,不必要不使用.

  * 第一原则,任意类型变量转换成反射对象

  ```mermaid

  flowchart LR
  int(int) --类型转换--&gt; i(interface对象)
  float(float) --类型转换--&gt; i
  bool(bool) --类型转换--&gt; i
  string(string) --类型转换--&gt; i
  struct(struct) --类型转换--&gt; i
  slice(slice) --类型转换--&gt; i
  array(array) --类型转换--&gt; i
  subgraph 反射对象
  subgraph TypeOf
    ri(reflect.Type)
  end
  subgraph ValueOf
    rv(reflect.Value)
  end
  i --类型转换--&gt; ri
  i --类型转换--&gt; rv
  end

</code></pre>
<ul>
<li>
<p>第二原则,反射对象可以获取 interface{} 变量</p>
<pre><code class="language-golang">v := reflect.ValueOf(&quot;st&quot;)
v.Interface().(string)
</code></pre>
</li>
</ul>
<pre class="mermaid">
  flowchart LR
  rv(reflect.Value) --Interface方法--&gt; i(interface对象)
  i --类型断言--&gt; string(string)
</pre>
<ul>
<li>第三原则,通过反射对象修改值,要传指针</li>
</ul>
<pre><code class="language-golang"> mystr := &quot;old&quot;
  //直接传mystr是不行的
vo := reflect.ValueOf(&amp;mystr)
vo.Elem().SetString(&quot;new&quot;)
fmt.Println(mystr)
</code></pre>
<ul>
<li>
<p>for</p>
<pre><code class="language-golang">for  {  } 相当于 for true  {  }
for cond { }  相当于   for ; cond ; { }

// RangeClause = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] &quot;range&quot; Expression .
</code></pre>
<ul>
<li>for-range
<ul>
<li>遍历之前都有copy数组/切片/map/chan,</li>
<li>golang里面一切都是值拷贝,注意值拷贝带来的影响</li>
<li>循环变量每次都重新copy</li>
</ul>
</li>
</ul>
</li>
<li>
<p>channel</p>
<ul>
<li>
<p>只有make一种创建方式,要不为nil,要不为有效chan</p>
</li>
<li>
<p>有无缓冲?</p>
</li>
</ul>
<pre><code class="language-golang">// 无缓冲
make(chan Type)
// 有缓冲
make(chan Type, Len(buf))
</code></pre>
<ul>
<li>
<p>读取</p>
<ul>
<li>读取nil channel永远阻塞,Receiving from a nil channel blocks forever.</li>
<li>第二值为true,表示第一值为发送值,否则表示第一值zero value,系统构造的,暗示channel已经close</li>
<li>channel关闭是指不能再写入,不影响读取.已经关闭的channel仍然能被读取</li>
</ul>
</li>
<li>
<p>先入先出,先写入数据先被读取出来</p>
</li>
<li>
<p>close一个空指针或者已经被关闭channel,运行时都会直接崩溃并抛出异常：</p>
</li>
</ul>
</li>
<li>
<p>select</p>
<ul>
<li>每个case一个Channel上非阻塞的收发操作；</li>
<li>多个case同时响应时，会随机执行一种情况；</li>
<li>如果default存在,则在case不响应时立即执行，否则阻塞等待case响应</li>
</ul>
</li>
<li>
<p>defer</p>
<ul>
<li>退出函数之前执行</li>
<li>多次调用 defer执行顺序:先进后出,后进先出</li>
<li>defer func参数在调用时求值,仍旧是值传递</li>
</ul>
</li>
<li>
<p>panic</p>
<ul>
<li>panicc后会立刻停止执行当前函数的剩余代码</li>
<li>仅执行本Goroutine中的defer</li>
<li>如果defer中没有recover处理,则整个程序退出(os.exit)</li>
<li>允许多次panic---在执行defer时,还可以再次panic</li>
</ul>
</li>
<li>
<p>recover</p>
<ul>
<li>
<p>只有在 defer 中调用才会生效,其他地方无效</p>
</li>
<li>
<p>可以中止 panic 造成的程序崩溃</p>
</li>
<li>
<p>返回值为最近的panic参数,返回值为nil情况</p>
<ul>
<li>panic's argument was nil;</li>
<li>the goroutine is not panicking;</li>
<li>recover was not called directly by a deferred function.</li>
</ul>
</li>
<li>
<p>一次recover只能恢复一个panic</p>
<pre><code class="language-golang">func main() {

defer println(&quot;main exit&quot;)
go func() {
  defer func() {
  if reply := recover(); reply != nil {
    println(&quot;recover:&quot;, reply.(string))
  }
  }()

  panic(&quot;panic another&quot;)
}()

go func() {
  defer func() {
  defer func() {
    if reply := recover(); reply != nil {
    println(&quot;recover:&quot;, reply.(string))
    }
  }()

  if reply := recover(); reply != nil {
    println(&quot;recover:&quot;, reply.(string))
  }
  panic(&quot;panic continue&quot;)
  }()
  panic(&quot;panic begin&quot;)
}()

time.Sleep(1 * time.Second)
</code></pre>
</li>
<li>
<p>sync</p>
<ul>
<li>Mutex,RWMutex</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="mermaid">
    flowchart LR
    l(Locker) --实现接口--&gt; m(Mutex)
    m --继承--&gt; rw(RWMutex)

</pre>
<pre><code>* WaitGroup
  * 一些扩展使用
    * golang/sync/errgroup.Group带错误传播
    * golang/sync/singleflight.Group限制同时产生大量相同请求

* pool临时对象复用池

* Map 多协程安全操作map,对内置map扩展

* Once 保证只执行一次

* Cond 信号量
  * 扩展使用
    * golang/sync/semaphore.Weighted带权重信号量
</code></pre>
<ul>
<li>
<p>协程调度</p>
<ul>
<li>G-M-P模型
<ul>
<li>M是操作系统线程,由操作系统管理,GOMAXPROCS(一般是当前机器的核数)个活跃线程</li>
<li>G是Go运行时中用户态提供的线程,代表待执行的任务,表现为函数执行</li>
<li>P是线程和G的中间层,一个线程一个P,一个P一个本地G的队列,优先取本地的运行队列,然后取全局的运行队列</li>
</ul>
</li>
</ul>
</li>
<li>
<p>time</p>
<ul>
<li>Timer--&gt;单次事件,The Timer type represents a single event.</li>
<li>Ticker--&gt;定时器,A Ticker holds a channel that delivers “ticks” of a clock at intervals.</li>
<li>Duration--&gt;时间长度,例如:1分钟,10天</li>
<li>Time--&gt;时间点,例如:2022年1月2日03点4分15秒</li>
<li>Location--&gt;时区,例如:北京时间</li>
<li>tzdata--&gt;子包,打包时区数据库到程序,会增加程序二进制大小</li>
<li>每个处理器单独管理计时器并通过网络轮询器触发</li>
<li>golang.org/x/time/rate扩展包带了一个令牌桶限流算法</li>
</ul>
<pre><code class="language-golang">// token自动按速率产生,通过Wait/Allow消费token
// 10是每秒可以向 Token 桶中产生多少 token
// 100是 代表 Token 桶的容量大小
limiter := rate.NewLimiter(10, 100);

</code></pre>
</li>
<li>
<p>json</p>
<ul>
<li>JSON 本身就是一种树形的数据结构，无论是序列化还是反序列化，都会遵循自顶向下的编码和解码过程，使用递归的方式处理 JSON 对象。</li>
<li>采用反射完成序列化/反序列化逻辑</li>
<li>struct对象可以tag调整json序列化/反序列化行为</li>
</ul>
</li>
<li>
<p>net</p>
<ul>
<li>
<p>listen(network, address string)</p>
<ul>
<li>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.
For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network &quot;tcp4&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port.</li>
</ul>
</li>
<li>
<p>Dial(network, address string)</p>
<ul>
<li>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only), &quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot; (IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and &quot;unixpacket&quot;.
For TCP and UDP networks, the address has the form &quot;host:port&quot;.</li>
</ul>
</li>
<li>
<p>扩展包golang.org/x/net有不少好功能实现</p>
</li>
</ul>
</li>
<li>
<p>http</p>
<ul>
<li>客户端,核心两个结构-Request,Response
<ul>
<li>net/http.Client</li>
<li>net/http.Transport</li>
<li>net/http.persistConn</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="mermaid">
      flowchart LR
      c(Client) --调用--&gt; t(Transport)
      t --调用--&gt;c(persistConn)

</pre>
<pre><code>* 服务端,核心两个结构-Request,ResponseWriter
  * net/http.Server
  * net/http.ServeMux
  * net/http.Handler
</code></pre>
<pre class="mermaid">
      flowchart LR
      c(Server) --调用--&gt; t(ServeMux)
      t --调用--&gt;c(Handler)

</pre>
<pre><code>* RoundTripper,代表一个http事务,给一个请求返回一个响应,可以自定义功能,例如:缓存responses

```golang
type RoundTripper interface {
  RoundTrip(*Request) (*Response, error)
}
```

* net/http/httptrace,net/http/httptrace
</code></pre>
<ul>
<li>
<p>golang.org/x/image扩展bmp,webp等功能实现</p>
</li>
<li>
<p>golang.org/x/text扩展不少像gbk转utf8,高级文本搜索等功能</p>
</li>
<li>
<p>io.Reader/Writer</p>
<ul>
<li>net.Conn: 表示网络连接。</li>
<li>os.Stdin, os.Stdout, os.Stderr: 标准输入、输出和错误。</li>
<li>os.File: 网络,标准输入输出,文件的流读取。</li>
<li>strings.Reader: 字符串抽象成 io.Reader 的实现。</li>
<li>bytes.Reader: []byte抽象成 io.Reader 的实现。</li>
<li>bytes.Buffer: []byte抽象成 io.Reader 和 io.Writer 的实现。</li>
<li>bufio.Reader/Writer: 带缓冲的流读取和写入（比如按行读写）。</li>
</ul>
</li>
<li>
<p>sql</p>
</li>
</ul>
<pre><code class="language-golang">type Driver interface {
  ...
}

type Conn interface {
  ...
}

type DB struct {
  // contains filtered or unexported fields
}

type Stmt struct {
  // contains filtered or unexported fields
}

type Tx struct {
  // contains filtered or unexported fields
}
</code></pre>
<ul>
<li>
<p>测试</p>
<ul>
<li>功能测试</li>
</ul>
<pre><code class="language-golang">// 文件名格式xxx_test.go
// 函数名格式TestXxx,Test开头,第一个字母必须大写
// 函数参数必须是t *testing.T
// 失败采用t.Fatalxxx,t.Errorxx输出
func TestAdd(t *testing.T) {
    if Add(10, 20) == 12 {
      t.Fatal(&quot;failure&quot;)
    }
  }
</code></pre>
<pre><code class="language-sh"># 启动
go test
</code></pre>
<ul>
<li>压力测试</li>
</ul>
<pre><code class="language-golang">// 文件名格式xxx_test.go
// 函数名格式BenchmarkXxx,Benchmark开头,第一个字母必须大写
// 函数参数必须是b *testing.B
// 测试性能前提是功能正确,所以没有失败一说
func BenchmarkAdd(b *testing.B) {
  for i := 0; i &lt; b.N; i++ {
    Add(rand.Int(), rand.Int())
  }
}
</code></pre>
<pre><code class="language-sh"># 启动, -bench pattern正则表达式，测试目标
go test -bench .
</code></pre>
<ul>
<li>随机测试</li>
</ul>
<pre><code class="language-golang">// 文件名格式xxx_test.go
// 函数名格式FuzzXxx,Fuzz开头,第一个字母必须大写
// 函数参数必须是f *testing.F
// 失败采用t.Fatalxxx,t.Errorxx输出
func FuzzAdd(f *testing.F) {
  for i := 0; i &lt; 10; i++ {
    // 随机种子语料
    // f.Add参数个数及类型及顺序，必须和后面一样
    f.Add(rand.Int(), rand.Int())
  }

  // func(t *testing.T, left, right int), 参数除t之外, 参数个数及类型及顺序，必须和f.Add一样
  f.Fuzz(func(t *testing.T, left, right int) {
    if Add(left, right) != left+right {
      t.Errorf(
        &quot;%v+%v=%v, result:%v&quot;,
        left, right, Add(left, right), left+right)
    }
  })
}
</code></pre>
<pre><code class="language-sh"># 启动,会一直执行下去,除非加上 -fuzztime 30s 指定运行时间
go test -fuzz Fuzz
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="grpc示例"><a class="header" href="#grpc示例">grpc示例</a></h1>
<hr />
<h1 id="server"><a class="header" href="#server">server</a></h1>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;context&quot;
 &quot;flag&quot;
 &quot;fmt&quot;
 &quot;log&quot;
 &quot;net&quot;

 &quot;google.golang.org/grpc&quot;
 &quot;google.golang.org/grpc/metadata&quot;
 &quot;google.golang.org/grpc/peer&quot;

 com &quot;xxx.site/myself/grpc-common&quot;
)

var (
 GitHash     = &quot;Unkown&quot;
 CompileTime = &quot;Unkown&quot;
 port        = flag.Int(&quot;port&quot;, 8411, &quot;默认端口&quot;)
)

// 定义服务端中间件
func middleware(ctx context.Context, req interface{},
 info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
 log.Printf(&quot;middleware ctx:%v&quot;, ctx)
 log.Printf(&quot;middleware req:%v&quot;, req)
 log.Printf(&quot;middleware info:%v&quot;, info)
 log.Printf(&quot;middleware handler:%v&quot;, handler)
 resp, err = handler(ctx, req)
 log.Printf(&quot;middleware resp:%v&quot;, resp)
 log.Printf(&quot;middleware err:%v&quot;, err)
 return
}

type MathServer struct {
 com.UnimplementedMathServer
}

// 各种信息都通过ctx中valueCtx传递进来
// 由不同包获取转换
func (ms *MathServer) Add(ctx context.Context, req *com.AddReq) (*com.AddRsp, error) {
 log.Printf(&quot;ctx:%v, req:%v&quot;, ctx, req)
 if client, ok := peer.FromContext(ctx); ok {
  log.Printf(&quot;client:%v&quot;, client)
 }

 if ic, ok := metadata.FromIncomingContext(ctx); ok {
  log.Printf(&quot;ic:%v&quot;, ic)
 }

 if oc, ok := metadata.FromOutgoingContext(ctx); ok {
  log.Printf(&quot;oc:%v&quot;, oc)
 }

 if oc, ok := metadata.FromOutgoingContext(ctx); ok {
  log.Printf(&quot;oc:%v&quot;, oc)
 }

 sts := grpc.ServerTransportStreamFromContext(ctx)
 log.Printf(&quot;sts:%v&quot;, sts)

 return &amp;com.AddRsp{
  Result: req.Left + req.Right,
 }, nil
}

func main() {
 flag.Parse()

 // ct, err := credentials.NewServerTLSFromFile(
 //  &quot;grpc.xxx.site.pem&quot;,
 //  &quot;grpc.xxx.site.key&quot;,
 // )
 // if err != nil {
 //  log.Fatalf(&quot;tls file;%v&quot;, err)
 // }

 // tcp表示优先使用ipv6,其次ipv4,两者都能用
 l, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;:%d&quot;, *port))
 if err != nil {
  log.Fatalf(&quot;fail listen tcp %d&quot;, *port)
 }

 // 安装中间件
 s := grpc.NewServer(
  // 默认没有采用安全传输ssl,tls
  // 增加证书认证
  //grpc.Creds(ct),
  grpc.UnaryInterceptor(middleware),
 )

 com.RegisterMathServer(s, &amp;MathServer{})
 log.Printf(
  &quot;githash:%v, compile:%v,listen:%v&quot;,
  GitHash,
  CompileTime,
  l.Addr())

 err = s.Serve(l)
 if err != nil {
  log.Fatalf(&quot;fail server:%v&quot;, err)
 }
}
</code></pre>
<h2 id="client"><a class="header" href="#client">client</a></h2>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;context&quot;
 &quot;flag&quot;
 &quot;log&quot;
 &quot;time&quot;

 &quot;google.golang.org/grpc&quot;
 &quot;google.golang.org/grpc/credentials/insecure&quot;

 com &quot;xxx.site/myself/grpc-common&quot;
)

var (
 GitHash     = &quot;unknown&quot;
 CompileTime = &quot;unknown&quot;
 // addr = flag.String(&quot;addr&quot;, &quot;dns:///grpc.xxx.site&quot;, &quot;默认服务端端口&quot;)
 addr = flag.String(&quot;addr&quot;, &quot;127.0.0.1:8411&quot;, &quot;默认服务端端口&quot;)
)

// 定义客户端中间件
func middleware(ctx context.Context, method string,
 req, reply interface{}, c *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {

 log.Printf(&quot;middleware ctx:%v&quot;, ctx)
 log.Printf(&quot;middleware method:%v&quot;, method)
 log.Printf(&quot;middleware req:%v&quot;, req)
 log.Printf(&quot;middleware reply:%v&quot;, reply)
 log.Printf(&quot;middleware conn:%v&quot;, c)
 log.Printf(&quot;middleware invoker:%v&quot;, invoker)
 for pos, opt := range opts {
  log.Printf(&quot;middleware pos:%v, opt:%v&quot;, pos, opt)
 }

 err := invoker(ctx, method, req, reply, c, opts...)

 log.Printf(&quot;middleware err:%v&quot;, err)

 return err

}

func main() {
 flag.Parse()

 // ct, err := credentials.NewClientTLSFromFile(&quot;grpc.xxx.site.pem&quot;, &quot;grpc.xxx.site&quot;)
 // if err != nil {
 //  log.Fatalf(&quot;err:%v&quot;, err)
 // }

 conn, err := grpc.Dial(
  *addr,
  // 采用禁用安全传输,即没有ssl/tls
  grpc.WithTransportCredentials(insecure.NewCredentials()),
  // 采用证书,注意跨平台，linux amd64/apple m1芯片之间可能不能通讯
  // grpc.WithTransportCredentials(ct),
  // 安装中间件
  grpc.WithUnaryInterceptor(middleware),
  grpc.WithTimeout(time.Minute),
 )
 if err != nil {
  log.Fatalf(&quot;dial:%v, %v&quot;, *addr, err)
 }
 defer conn.Close()

 client := com.NewMathClient(conn)

 req := com.AddReq{
  Left:  10,
  Right: 20,
 }

 resp, err := client.Add(context.Background(), &amp;req)
 if err != nil {
  log.Fatalf(&quot;add fail:%v&quot;, err)
 }

 log.Printf(&quot;resp:%v&quot;, resp.Result)
}

</code></pre>
<h2 id="proto"><a class="header" href="#proto">proto</a></h2>
<hr />
<ul>
<li>proto内容</li>
</ul>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

option go_package = &quot;./;common&quot;;

service Math {
    rpc Add(AddReq)returns(AddRsp){}
}

message AddReq {
    int64 left = 1;
    int64 right = 2;
}

message AddRsp {
    int64 result = 1;
}
</code></pre>
<ul>
<li>生成脚本</li>
</ul>
<pre><code class="language-sh">#!/bin/bash

#--go-grpc_out表示启动protoc-gen-go-grpc插件
# --openapiv2_out 表示产生swagger.json 
protoc --go_out=. --go-grpc_out=. *.proto
</code></pre>
<h2 id="nginx-1"><a class="header" href="#nginx-1">nginx</a></h2>
<hr />
<pre><code class="language-nginx">...
server_names_hash_bucket_size 64;
server {
        listen 443 ssl http2;
        server_name grpc.xxx.site;

        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
        ssl_certificate grpc.xxx.site.pem;
        ssl_certificate_key grpc.xxx.site.key;

        ssl_session_cache shared:SSL:1m;
        ssl_session_timeout 5m;

        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;

        location / {
            # grpc_pass localhost:9000; 等价于 grpc://127.0.0.1:8411 等价于 [::]:8411;
            # To use gRPC over SSL,就要带上grpcs:
            grpc_pass grpcs://[xxx]:8411;
            client_max_body_size 200M;
        }
    }
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="代码片断"><a class="header" href="#代码片断">代码片断</a></h1>
<hr />
<h3 id="更丰富的errors"><a class="header" href="#更丰富的errors">更丰富的errors</a></h3>
<hr />
<pre><code class="language-golang">import (
 &quot;fmt&quot;

 &quot;github.com/pkg/errors&quot;
)

func main() {
  //%+v格式输出,则带上栈调用,调试好帮手
 fmt.Printf(&quot;err:%+v&quot;, errors.New(&quot;mynew&quot;))
}
</code></pre>
<h3 id="memcached"><a class="header" href="#memcached">memcached</a></h3>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;fmt&quot;
 //连接memcached
 &quot;github.com/bradfitz/gomemcache/memcache&quot;
)

func main() {
 key := &quot;/golang&quot;
 client := memcache.New(&quot;127.0.0.1:11211&quot;)
 err := client.Set(&amp;memcache.Item{
  Key:        key,
  Flags:      0,
  Expiration: 0,
  Value:      []byte(&quot;&lt;HTML&gt;&lt;H2&gt;hello,golang&lt;/H2&gt;&lt;/HTML&gt;&quot;),
 })
 if err != nil {
  fmt.Println(err.Error())
  return
 }

 item, err2 := client.Get(key)
 if err2 != nil {
    fmt.Println(err2.Error())
  return
 }

 fmt.Println(string(item.Value))
}

</code></pre>
<h3 id="redis"><a class="header" href="#redis">redis</a></h3>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;fmt&quot;

 //连接redis
 &quot;github.com/gomodule/redigo/redis&quot;
)

func main() {
 conn, err := redis.Dial(&quot;tcp&quot;, &quot;:6379&quot;)
 if err != nil {
  fmt.Println(err.Error())
  return
 }
 defer conn.Close()

 setReply, setReplyErr := redis.String(conn.Do(&quot;set&quot;, &quot;firstKey&quot;, &quot;firstValue&quot;))
 if setReplyErr != nil {
  fmt.Println(setReplyErr.Error())
  return
 }

 fmt.Println(&quot;setReply:&quot;, setReply, reflect.TypeOf(setReply))

 mgetReplay, mgetReplyErr := redis.Strings(conn.Do(&quot;mget&quot;, &quot;firstKey&quot;, &quot;k1&quot;))
 if mgetReplyErr != nil {
  fmt.Println(mgetReplyErr.Error())
  return
 }

 fmt.Println(&quot;mgetReplay:&quot;, mgetReplay, reflect.TypeOf(mgetReplay))

 hgetallReply, hgetallReplyErr := redis.StringMap(conn.Do(&quot;hgetall&quot;, &quot;myhash&quot;))
 if hgetallReplyErr != nil {
  fmt.Println(hgetallReplyErr.Error())
  return
 }

 fmt.Println(&quot;hgetallReply:&quot;, hgetallReply, reflect.ValueOf(hgetallReply))

 lrangeReply, lrangeReplyErr := redis.Strings(conn.Do(&quot;lrange&quot;, &quot;mylist&quot;, &quot;0&quot;, &quot;-1&quot;))
 if lrangeReplyErr != nil {
  fmt.Println(lrangeReplyErr.Error())
  return
 }

 fmt.Println(&quot;lrangeReply:&quot;, lrangeReply, reflect.ValueOf(lrangeReply))

 smembersReply, smembersReplyErr := redis.Strings(conn.Do(&quot;smembers&quot;, &quot;myset&quot;))
 if smembersReplyErr != nil {
  fmt.Println(smembersReplyErr.Error())
  return
 }

 fmt.Println(&quot;smembersReply:&quot;, smembersReply, reflect.TypeOf(smembersReply))

 zrangeReply, zrangeReplyErr := redis.Int64Map(conn.Do(&quot;zrange&quot;, &quot;mySortedSet&quot;, &quot;0&quot;, &quot;-1&quot;, &quot;withscores&quot;))
 if zrangeReplyErr != nil {
  fmt.Println(zrangeReplyErr.Error())
  return
 }

 fmt.Println(&quot;zrangeReply:&quot;, zrangeReply, reflect.TypeOf(zrangeReply))
}
</code></pre>
<p><img src="golang/golang_redis.webp" alt="golang_redis" /></p>
<h3 id="mongodb"><a class="header" href="#mongodb">mongodb</a></h3>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;context&quot;
 &quot;fmt&quot;
 &quot;reflect&quot;
 &quot;time&quot;

//连接mongodb
 &quot;go.mongodb.org/mongo-driver/bson&quot;
 &quot;go.mongodb.org/mongo-driver/mongo&quot;
 &quot;go.mongodb.org/mongo-driver/mongo/options&quot;
)

func main() {
 ctx, cancel := context.WithTimeout(context.Background(), 20*time.Second)
 defer cancel()

 client, err := mongo.Connect(ctx, options.Client().ApplyURI(&quot;mongodb://localhost:27017&quot;))
 if err != nil {
  fmt.Println(&quot;connect:&quot;, err.Error())
  return
 }
 defer client.Disconnect(ctx)

// database,collection不存在,会自动创建,不必事先创建
 col := client.Database(&quot;firstDB&quot;).Collection(&quot;firstCol&quot;)

 reply, err := col.InsertOne(ctx, bson.D{{&quot;name&quot;, &quot;pai&quot;}, {&quot;value&quot;, 3.14159}})
 if err != nil {
  fmt.Println(&quot;list:&quot;, err.Error())
  return
 }

 fmt.Println(reflect.ValueOf(reply))
}
</code></pre>
<pre><code class="language-golang">package main

import (
 &quot;context&quot;
 &quot;database/sql&quot;
 &quot;fmt&quot;
 &quot;log&quot;

 _ &quot;github.com/go-sql-driver/mysql&quot;
)

func main() {
 // user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local
 db, err := sql.Open(&quot;mysql&quot;, &quot;root:@(127.0.0.1:3306)/mytest?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;)
 if err != nil {
  fmt.Println(err.Error())
  return
 }
 defer db.Close()

 ctx, stop := context.WithCancel(context.Background())
 defer stop()

 rows, err := db.QueryContext(ctx, &quot;SELECT v FROM js&quot;)
 if err != nil {
  log.Fatal(err)
 }
 defer rows.Close()

 names := make([]string, 0)
 for rows.Next() {
  var name string
  if err := rows.Scan(&amp;name); err != nil {
   log.Fatal(err)
  }
  names = append(names, name)
 }
 // Check for errors from iterating over rows.
 if err := rows.Err(); err != nil {
  log.Fatal(err)
 }
 fmt.Println(names)
}
</code></pre>
<pre><code class="language-golang">//获取当前git的hash值
gitOut, gitErr := exec.Command(&quot;bash&quot;, &quot;-c&quot;, &quot;git rev-parse --short HEAD&quot;).Output()
if gitErr != nil {
 fmt.Println(gitErr)
 return
}
</code></pre>
<h3 id="trace"><a class="header" href="#trace">trace</a></h3>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;os&quot;
 &quot;runtime/trace&quot;
)

func main() {
 trace.Start(os.Stderr)
 defer trace.Stop()

 ch := make(chan string)

 go func() {
  ch &lt;- &quot;hello,world&quot;
 }()

 &lt;-ch
}
</code></pre>
<pre><code class="language-sh">#注意2&gt;trace.out重定向,产生数据文件
go run main.go 2&gt;trace.out
#pprof,trace有些需要graphviz
brew install graphviz
#采用trace工具分析显示数据,
go tool trace trace.out
</code></pre>
<p><img src="golang/golang_trace.webp" alt="golang_trace" /></p>
<h3 id="stringstrimleft去掉连续的字符stringstrimperfix只去掉一次"><a class="header" href="#stringstrimleft去掉连续的字符stringstrimperfix只去掉一次">strings.TrimLeft去掉连续的字符,strings.TrimPerfix只去掉一次</a></h3>
<h3 id="profile"><a class="header" href="#profile">profile</a></h3>
<pre><code class="language-golang">import (
  &quot;github.com/pkg/profile&quot;
  _ &quot;net/http/pprof&quot;
)

// go http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)

func main() {
    // p.Stop() must be called before the program exits to
    // ensure profiling information is written to disk.
    p := profile.Start(profile.MemProfile, profile.ProfilePath(&quot;.&quot;), profile.NoShutdownHook)
    ...
    // You can enable different kinds of memory profiling, either Heap or Allocs where Heap
    // profiling is the default with profile.MemProfile.
    p := profile.Start(profile.MemProfileAllocs, profile.ProfilePath(&quot;.&quot;), profile.NoShutdownHook)

    // 采用web接口提供 http://localhost:8080/debug/profile
    go http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)
}
</code></pre>
<pre><code class="language-bash"># 等上步生成的的cpu.profile
go tool pprof cpu.profile

# 常见命令 top,前几个费时 web 输出临时svg图片展示
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="context"><a class="header" href="#context">context</a></h1>
<hr />
<h3 id="未完待续"><a class="header" href="#未完待续">未完待续</a></h3>
<pre class="mermaid">
classDiagram
    class Context{
        &lt;&lt; interface &gt;&gt;
        +Deadline() (deadline time.Time, ok bool)
        +Done()
        +Err() error
        +Value(key any) any
    }
    Context &lt;|.. emptyCtx

    Context &lt;|-- valueCtx

    class valueCtx{
        +Context
        ~key any
        ~val any
    }
    
    class canceler{
        &lt;&lt; interface &gt;&gt;
        ~cancel(removeFromParent bool, err error)
        +Done()
    }
    
    canceler &lt;|.. cancelCtx

    Context &lt;|-- cancelCtx
    

    class cancelCtx{
        +Context
    }

    cancelCtx &lt;|-- timerCtx

    class timerCtx{
        +timer *time.Timer
        +deadline time.Time
    }
</pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="echo"><a class="header" href="#echo">echo</a></h1>
<hr />
<h3 id="memcached中间件"><a class="header" href="#memcached中间件">memcached中间件</a></h3>
<hr />
<pre><code class="language-golang">
import (
 &quot;bytes&quot;
 &quot;net/http&quot;
 &quot;sync&quot;

 &quot;github.com/bradfitz/gomemcache/memcache&quot;
 &quot;github.com/labstack/echo/v4&quot;
)

var memcacheClientMux sync.Mutex
var memcacheClient *memcache.Client

// TODO,要不要带上http头部,例如:数据类型html/json/js,Date,Cache-control等等
type middleResp struct {
 http.ResponseWriter
 isOK       bool
 key        string
 expiration int32
 bytes.Buffer
}

var StoreErrHandler func(error)

func (mr *middleResp) writeStore() {
 if mr.Buffer.Len() &gt; 0 {
  err := memcacheClient.Set(&amp;memcache.Item{
   Key:        mr.key,
   Flags:      0,
   Expiration: mr.expiration,
   Value:      mr.Bytes(),
  })

  if StoreErrHandler != nil {
   StoreErrHandler(err)
  }
 }
}

func (mr *middleResp) Write(body []byte) (int, error) {
 if mr.isOK &amp;&amp; memcacheClient != nil {
  _, err := mr.Buffer.Write(body)
  if StoreErrHandler != nil {
   StoreErrHandler(err)
  }
 }
 return mr.ResponseWriter.Write(body)
}

func (mr *middleResp) WriteHeader(statusCode int) {
 mr.isOK = statusCode == http.StatusOK
 mr.ResponseWriter.WriteHeader(statusCode)
}

func MemcacheStore(server string, expireSecond int32) func(echo.HandlerFunc) echo.HandlerFunc {
 memcacheClientMux.Lock()
 defer memcacheClientMux.Unlock()

 if memcacheClient == nil {
  memcacheClient = memcache.New(server)
 }

 return func(next echo.HandlerFunc) echo.HandlerFunc {
  return func(c echo.Context) error {
   resp := c.Response()
   mr := &amp;middleResp{
    ResponseWriter: resp.Writer,
    key:            c.Request().RequestURI,
    expiration:     expireSecond,
   }

   resp.Writer = mr

   err := next(c)

   mr.writeStore()

   return err
  }
 }
}

func MemcacheWrap(server string, expireSecond int32, handler echo.HandlerFunc) echo.HandlerFunc {
 return MemcacheStore(server, expireSecond)(handler)
}


</code></pre>
<h3 id="main使用"><a class="header" href="#main使用">main使用</a></h3>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;fmt&quot;
 &quot;math/rand&quot;
 &quot;net/http&quot;

 &quot;github.com/labstack/echo/v4&quot;
 &quot;github.com/labstack/echo/v4/middleware&quot;
)

func main() {
 e := echo.New()

 // Middleware
 e.Use(middleware.Logger())
 e.Use(middleware.Recover())

 StoreErrHandler = func(err error) {
  e.Logger.Error(err)
 }

 // Routes
 e.GET(&quot;/echo/string&quot;, stringHandler, MemcacheStore(&quot;127.0.0.1:11211&quot;, 60))

 e.GET(&quot;/echo/html&quot;, MemcacheWrap(&quot;127.0.0.1:11211&quot;, 60, htmlHandler))

 // Start server
 e.Logger.Fatal(e.Start(&quot;:1323&quot;))
}

// Handler
func stringHandler(c echo.Context) error {
 err := c.String(http.StatusOK, fmt.Sprintf(&quot;&lt;H1&gt;path:%s&lt;/H1&gt;&quot;, c.Path()))
 if err != nil {
  return err
 }
 return c.String(http.StatusOK, fmt.Sprintf(
  &quot;&lt;H2&gt;query:%s,rand:%d&lt;/H2&gt;&quot;,
  c.QueryString(),
  rand.Int(),
 ))
}

// Handler
func htmlHandler(c echo.Context) error {
 err := c.HTML(http.StatusOK, fmt.Sprintf(&quot;&lt;H1&gt;uri:%s&lt;/H1&gt;&quot;, c.Request().RequestURI))
 if err != nil {
  return err
 }
 return c.HTML(http.StatusOK, fmt.Sprintf(
  &quot;&lt;H2&gt;query:%s,rand:%d&lt;/H2&gt;&quot;,
  c.QueryString(),
  rand.Int(),
 ))
}

</code></pre>
<h3 id="nginx转发"><a class="header" href="#nginx转发">nginx转发</a></h3>
<hr />
<pre><code class="language-nginx">...
location /echo {
    set $memcached_key &quot;$request_uri&quot;;
    memcached_pass 127.0.0.1:11211;
    #指示返回为html,方便浏览器直接显示
    default_type   text/html;
    error_page 404 502 504 = @echoServer;
}

location @echoServer {
    proxy_pass   http://127.0.0.1:1323;
}
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="freetype"><a class="header" href="#freetype">freetype</a></h1>
<hr />
<pre><code class="language-golang">package main

import (
 &quot;fmt&quot;
 &quot;image&quot;
 &quot;image/draw&quot;
 &quot;image/png&quot;
 &quot;os&quot;
 &quot;github.com/golang/freetype&quot;
)

func DrawText(text string) {
 data, err := ioutil.ReadFile(&quot;/System/Library/Fonts/STHeiti Medium.ttc&quot;)
 if err != nil {
  panic(err)
 }
 f, err := freetype.ParseFont(data)
 if err != nil {
  panic(err)
 }

 dst := image.NewRGBA(image.Rect(0, 0, 800, 600))
 draw.Draw(dst, dst.Bounds(), image.White, image.Point{}, draw.Src)

 c := freetype.NewContext()
 c.SetDst(dst)
 c.SetClip(dst.Bounds())
 c.SetSrc(image.Black)
 c.SetFont(f)
 fontSize := float64(50)
 // 字体越大, 显示越大
 c.SetFontSize(fontSize)

 // Pt是控制起点,Pt{x,y},x表示左起点,y表示下起点,y-fontSize才是上起点
 _, err = c.DrawString(text, freetype.Pt(0, int(fontSize)))
 if err != nil {
  panic(err)
 }

 pngFile, err := os.Create(&quot;draw.png&quot;)
 if err != nil {
  panic(err)
 }
 defer pngFile.Close()

 err = png.Encode(pngFile, dst)
 if err != nil {
  panic(err)
 }
}

func main() {
 DrawText(&quot;中国人golang语言教程ABC122&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<hr />
<pre><code class="language-golang">// go 1.18+
package main

import (
 &quot;fmt&quot;
)
type SubType interface {
 int | string | float32
}

// func Sub[T int | string | float32](array []T, ele T) []T {
func Sub[T SubType](array []T, ele T) []T {
 res := make([]T, 0, len(array))

 for _, a := range array {
  if a == ele {
   continue
  }
  res = append(res, a)
 }
 return res
}

func main() {
 fmt.Println(Sub([]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;}, &quot;b&quot;))

 fmt.Println(Sub([]int{10, 20, 30, 10}, 10))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="gin"><a class="header" href="#gin">gin</a></h1>
<hr />
<h3 id="context中断原理"><a class="header" href="#context中断原理">context中断原理</a></h3>
<hr />
<pre><code class="language-golang">const abortIndex int8 = math.MaxInt8 / 2

// Abort prevents pending handlers from being called. Note that this will not stop the current handler.
// Let's say you have an authorization middleware that validates that the current request is authorized.
// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers
// for this request are not called.
func (c *Context) Abort() {
    // c.index赋值很大值,从导致下次Next都不执行,达到阻断执行链目的
 c.index = abortIndex
}

// Next should be used only inside middleware.
// It executes the pending handlers in the chain inside the calling handler.
// See example in GitHub.
func (c *Context) Next() {
 c.index++
 for c.index &lt; int8(len(c.handlers)) {
  c.handlers[c.index](c)
  c.index++
 }
}
</code></pre>
<h3 id="memcache中间件"><a class="header" href="#memcache中间件">memcache中间件</a></h3>
<hr />
<pre><code class="language-golang">import (
 &quot;bytes&quot;
 &quot;net/http&quot;
 &quot;sync&quot;

 &quot;github.com/bradfitz/gomemcache/memcache&quot;
 &quot;github.com/gin-gonic/gin&quot;
)

var memcacheClientMux sync.Mutex
var memcacheClient *memcache.Client

// TODO,要不要带上http头部,例如:数据类型html/json/js,Date,Cache-control等等
type middleResp struct {
 // 匿名包括,变相继承
 gin.ResponseWriter
 isOK       bool
 key        string
 expiration int32
 // 如果匿名包括,变相继承会和ResponseWriter冲突,导致接口重复写
 b bytes.Buffer
}

var StoreErrHandler func(error)

func (mr *middleResp) writeStore() {
 if mr.b.Len() &gt; 0 {
  err := memcacheClient.Set(&amp;memcache.Item{
   Key:        mr.key,
   Flags:      0,
   Expiration: mr.expiration,
   Value:      mr.b.Bytes(),
  })

  if StoreErrHandler != nil {
   StoreErrHandler(err)
  }
 }
}

func (mr *middleResp) Write(body []byte) (int, error) {
 if mr.isOK &amp;&amp; memcacheClient != nil {
  _, err := mr.b.Write(body)
  if StoreErrHandler != nil {
   StoreErrHandler(err)
  }
 }
 return mr.ResponseWriter.Write(body)
}

func (mr *middleResp) WriteHeader(statusCode int) {
 mr.isOK = statusCode == http.StatusOK
 mr.ResponseWriter.WriteHeader(statusCode)
}

// Writes the string into the response body.
func (mr *middleResp) WriteString(s string) (int, error) {
 return mr.ResponseWriter.WriteString(s)
}

func MemcacheStore(server string, expireSecond int32) gin.HandlerFunc {
 return MemcacheWrap(server, expireSecond, func(c *gin.Context) { c.Next() })
}

func MemcacheWrap(server string, expireSecond int32, handler gin.HandlerFunc) gin.HandlerFunc {
 memcacheClientMux.Lock()
 defer memcacheClientMux.Unlock()

 if memcacheClient == nil {
  memcacheClient = memcache.New(server)
 }

 return func(c *gin.Context) {
  mr := &amp;middleResp{
   ResponseWriter: c.Writer,
   key:            c.Request.RequestURI,
   expiration:     expireSecond,
  }

  c.Writer = mr

  handler(c)

  mr.writeStore()
 }
}
</code></pre>
<h3 id="main使用-1"><a class="header" href="#main使用-1">main使用</a></h3>
<hr />
<pre><code class="language-golang">import (
 &quot;fmt&quot;
 &quot;math/rand&quot;

 &quot;github.com/gin-gonic/gin&quot;
)

func main() {

 r := gin.Default()

 r.Use(gin.Logger())

 r.GET(&quot;/gin/wrap&quot;, MemcacheWrap(&quot;127.0.0.1:11211&quot;, 100, wrap))

 group := r.Group(&quot;/gin/group&quot;)

 group.Use(MemcacheStore(&quot;127.0.0.1:11211&quot;, 100))

 group.GET(&quot;/ping&quot;, func(c *gin.Context) {
  c.JSON(200, gin.H{
   &quot;message&quot;: &quot;pong&quot;,
  })
 })

 group.GET(&quot;/gin&quot;, func(c *gin.Context) {
  c.Data(200, &quot;text/html&quot;,
   []byte(fmt.Sprintf(&quot;&lt;H1&gt;gin,%v&lt;/H1&gt;&quot;, rand.Int())),
  )
 })

 r.Run(&quot;0.0.0.0:5050&quot;)
}

func wrap(c *gin.Context) {
 c.Data(200, &quot;text/html&quot;,
  []byte(fmt.Sprintf(&quot;&lt;H1&gt;warp,%v&lt;/H1&gt;&quot;, rand.Int())),
 )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="go-git"><a class="header" href="#go-git">go-git</a></h1>
<hr />
<pre><code class="language-golang">
package main

import(
    &quot;fmt&quot;
    &quot;github.com/go-git/go-git/v5&quot;
    &quot;github.com/go-git/go-git/v5/plumbing/object&quot;
)
 

func gitWork() {
 r, err := git.PlainOpen(&quot;../wubei/wubei&quot;)
 if err != nil {
  fmt.Println(err)
  return
 }

 fmt.Println(&quot;r&quot;, r)

 // ... retrieves the branch pointed by HEAD
 ref, err := r.Head()
 if err != nil {
  fmt.Println(err)
  return
 }

 fmt.Println(&quot;ref&quot;, ref)

 // ... retrieves the commit history
 cIter, err := r.Log(&amp;git.LogOptions{From: ref.Hash()})
 if err != nil {
  fmt.Println(err)
  return
 }

 var cCount int
 err = cIter.ForEach(func(c *object.Commit) error {
  cCount++
  fmt.Println(&quot;Author&quot;, c.Author)
  fmt.Println(&quot;Message&quot;, c.Message)
  return nil
 })
 if err != nil {
  fmt.Println(err)
  return
 }

 fmt.Println(&quot;cCount&quot;, cCount)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="泛型切片分组"><a class="header" href="#泛型切片分组">泛型切片分组</a></h1>
<hr />
<pre><code class="language-golang">func GroupBy[T any, U comparable](collection []T, iteratee func(T) U) map[U][]T {
 result := map[U][]T{}

 for _, item := range collection {
  key := iteratee(item)

  result[key] = append(result[key], item)
 }

 return result
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="io包"><a class="header" href="#io包">io包</a></h1>
<hr />
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<pre class="mermaid">
flowchart TB
subgraph 单接口
    direction LR
    r1(Reader)---w1(Writer)---c1(Closer)---s1(Seeker)
end
subgraph 双接口
    direction LR
    rw(ReadWriter)---rc(ReadCloser)---rs(ReadSeeker)---wc(WriteCloser)---ws(WriteSeeker)
end
subgraph 三接口
    direction LR
    rwc(ReadWriteCloser)---rsc(ReadSeekCloser)---rws(ReadWriteSeeker)
end

单接口 --组合--&gt; 双接口 --组合--&gt; 三接口
</pre>
<ul>
<li>Reader</li>
</ul>
<pre><code class="language-golang">type Reader interface {
    // 读取len(p)字节到p里面
    // 返回读取成功字节数
    // eof表示正常结束
    Read(p []byte) (n int, err error)
}
</code></pre>
<ul>
<li>Writer</li>
</ul>
<pre><code class="language-golang">type Writer interface {
    // 写入p里面内容,len(p)字节
    // 返回写入成功字节数
    Write(p []byte) (n int, err error)
}
</code></pre>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<pre class="mermaid">
flowchart TB
subgraph Byte
    direction LR
    br(ByteReader)---bw(ByteWriter)---bc(ByteScanner)
end
subgraph Rune
    direction LR
    rr(RuneReader)---rw(ByteWriter)---rc(ByteScanner)
end
subgraph String
    direction LR
    sw(StringWriter)
end
</pre>
<h3 id="扩展"><a class="header" href="#扩展">扩展</a></h3>
<pre class="mermaid">
flowchart TB
subgraph 附加
    direction LR
    rf(ReaderFrom)---wt(WriterTo)---ra(ReaderAt)---wa(WriterAt)
end
subgraph 限制
    direction LR
    lr(LimitedReader)---sr(SectionReader)
end
subgraph 内部
    direction LR
    d(discard)---nc(nopCloser)---tr(teeReader镜像)
    mr(multiReader串联)---mw(multiWriter广播)
    pr(PipeReader就地读)--同个pipe,chan实现---pw(PipeWriter就地写)
end
</pre>
<h3 id="便利函数"><a class="header" href="#便利函数">便利函数</a></h3>
<pre><code class="language-golang">WriteString(w Writer, s string) (n int, err error)
ReadAll(r Reader) ([]byte, error)
ReadFull(r Reader, buf []byte) (n int, err error)
ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
CopyN(dst Writer, src Reader, n int64) (written int64, err error)
Copy(dst Writer, src Reader) (written int64, err error)
CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)

//扩展close接口
NopCloser(r Reader)ReadCloser
//把r读出来内容写一份到w,镜像r到w
TeeReader(r Reader, w Writer) Reader
//最多读n个字节,达到就返回eof
LimitReader(r Reader, n int64) Reader
//串联起多个源头,按顺序依次读完
MultiReader(readers ...Reader) Reader
//把w写入内容广播多个writers中
MultiWriter(writers ...Writer) Writer
//就地成双读写,通过chan []byte实现
Pipe() (*PipeReader, *PipeWriter)

// 切片扩容
if len(b) == cap(b) {
    // Add more capacity (let append pick how much).
    b = append(b, 0)[:len(b)]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="iris"><a class="header" href="#iris">iris</a></h1>
<hr />
<h3 id="context中断原理-1"><a class="header" href="#context中断原理-1">context中断原理</a></h3>
<hr />
<pre><code class="language-golang">// I don't set to a max value because we want to be able to reuse the handlers even if stopped with .Skip
const stopExecutionIndex = -1 

// StopExecution if called then the following .Next calls are ignored,
// as a result the next handlers in the chain will not be fire.
func (ctx *context) StopExecution() {
 ctx.currentHandlerIndex = stopExecutionIndex
}

// IsStopped checks and returns true if the current position of the context is -1,
// means that the StopExecution() was called.
func (ctx *context) IsStopped() bool {
 return ctx.currentHandlerIndex == stopExecutionIndex
}

func DefaultNext(ctx Context) {
 if ctx.IsStopped() {
  return
 }
 if n, handlers := ctx.HandlerIndex(-1)+1, ctx.Handlers(); n &lt; len(handlers) {
  ctx.HandlerIndex(n)
  handlers[n](ctx)
 }
}

func (ctx *context) HandlerIndex(n int) (currentIndex int) {
 if n &lt; 0 || n &gt; len(ctx.handlers)-1 {
  return ctx.currentHandlerIndex
 }

 ctx.currentHandlerIndex = n
 return n
}
</code></pre>
<h3 id="memcache中间件-1"><a class="header" href="#memcache中间件-1">memcache中间件</a></h3>
<hr />
<pre><code class="language-golang">import (
 &quot;bytes&quot;
 &quot;net/http&quot;
 &quot;sync&quot;

 &quot;github.com/bradfitz/gomemcache/memcache&quot;
 &quot;github.com/kataras/iris/v12/context&quot;
)

var memcacheClientMux sync.Mutex
var memcacheClient *memcache.Client

// TODO,要不要带上http头部,例如:数据类型html/json/js,Date,Cache-control等等
type middleResp struct {
 // 匿名包括,变相继承
 http.ResponseWriter
 isOK       bool
 key        string
 expiration int32
 // 如果匿名包括,变相继承会和ResponseWriter冲突,导致接口重复写
 b bytes.Buffer
}

var StoreErrHandler func(error)

func (mr *middleResp) writeStore() {
 if mr.b.Len() &gt; 0 {
  err := memcacheClient.Set(&amp;memcache.Item{
   Key:        mr.key,
   Flags:      0,
   Expiration: mr.expiration,
   Value:      mr.b.Bytes(),
  })

  if StoreErrHandler != nil {
   StoreErrHandler(err)
  }
 }
}

func (mr *middleResp) Write(body []byte) (int, error) {
 if mr.isOK &amp;&amp; memcacheClient != nil {
  _, err := mr.b.Write(body)
  if StoreErrHandler != nil {
   StoreErrHandler(err)
  }
 }
 return mr.ResponseWriter.Write(body)
}

func (mr *middleResp) WriteHeader(statusCode int) {
 mr.isOK = statusCode == http.StatusOK
 mr.ResponseWriter.WriteHeader(statusCode)
}

func MemcacheStore(server string, expireSecond int32) context.Handler {
 return MemcacheWrap(server, expireSecond, func(c context.Context) { c.Next() })
}

func MemcacheWrap(server string, expireSecond int32, handler context.Handler) context.Handler {
 memcacheClientMux.Lock()
 defer memcacheClientMux.Unlock()

 if memcacheClient == nil {
  memcacheClient = memcache.New(server)
 }

 return func(c context.Context) {
  mr := &amp;middleResp{
   ResponseWriter: c.ResponseWriter().Naive(),
   key:            c.Request().RequestURI,
   expiration:     expireSecond,
  }

  c.ResponseWriter().BeginResponse(mr)

  handler(c)

  mr.writeStore()
 }
}
</code></pre>
<h3 id="main使用-2"><a class="header" href="#main使用-2">main使用</a></h3>
<hr />
<pre><code class="language-golang">import (
 &quot;math/rand&quot;

 &quot;github.com/kataras/iris/v12&quot;
 &quot;github.com/kataras/iris/v12/middleware/recover&quot;
)

func main() {

 app := iris.New()

 booksAPI := app.Party(
  &quot;/iris/books&quot;,
  recover.New(),
  MemcacheStore(&quot;127.0.0.1:11211&quot;, 60),
 )
 {
  booksAPI.Get(&quot;/&quot;, list)
 }

 app.Get(&quot;/iris/other&quot;, MemcacheWrap(&quot;127.0.0.1:11211&quot;, 60, other))

 app.Listen(&quot;:9090&quot;)
}

func other(ctx iris.Context) {
 ctx.HTML(
  &quot;&lt;H1&gt;%s, %v&lt;/H1&gt;&quot;,
  ctx.Request().RequestURI,
  rand.Int(),
 )

}

// Book example.
type Book struct {
 Title string `json:&quot;title&quot;`
}

func list(ctx iris.Context) {
 books := []Book{
  {&quot;Mastering Concurrency in Go&quot;},
  {&quot;Go Design Patterns&quot;},
  {&quot;Black Hat Go&quot;},
 }

 // ctx.JSON(books)
 ctx.HTML(&quot;%v&quot;, books)
 // TIP: negotiate the response between server's prioritizes
 // and client's requirements, instead of ctx.JSON:
 // ctx.Negotiation().JSON().MsgPack().Protobuf()
 // ctx.Negotiate(books)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="log"><a class="header" href="#log">log</a></h1>
<hr />
<h3 id="日志常用示例"><a class="header" href="#日志常用示例">日志常用示例</a></h3>
<pre><code class="language-golang">package main

import (
 &quot;fmt&quot;
 &quot;io&quot;
 &quot;io/ioutil&quot;
 &quot;runtime&quot;
 &quot;strings&quot;
 &quot;time&quot;

 rotatelogs &quot;github.com/lestrrat-go/file-rotatelogs&quot;
 &quot;github.com/rifflock/lfshook&quot;
 &quot;github.com/sirupsen/logrus&quot;
)

func NewWriter(perfix string) io.Writer {
 w, err := rotatelogs.New(
  perfix+&quot;.%Y%m%d.json&quot;,
  // 建立软接
  rotatelogs.WithLinkName(perfix),
  // 最多保存一星期
  rotatelogs.WithMaxAge(7*24*time.Hour),
  // 一天切割一次
  rotatelogs.WithRotationTime(24*time.Hour),
 )
 if err != nil {
  panic(err)
 }
 return w
}

func InitLog(perfix string) {
 wm := lfshook.WriterMap{
  logrus.DebugLevel: NewWriter(perfix + &quot;_debug&quot;),
  logrus.InfoLevel:  NewWriter(perfix + &quot;_info&quot;),
  logrus.WarnLevel:  NewWriter(perfix + &quot;_warn&quot;),
  logrus.ErrorLevel: NewWriter(perfix + &quot;_error&quot;),
  logrus.FatalLevel: NewWriter(perfix + &quot;_fatal&quot;),
 }
 logrus.AddHook(lfshook.NewHook(
  wm,
  &amp;logrus.JSONFormatter{
   CallerPrettyfier: func(f *runtime.Frame) (string, string) {
    var callerName, fileName string
    names := strings.SplitAfterN(f.File, perfix, 2)
    if len(names) &gt; 1 {
     fileName = fmt.Sprintf(&quot;%v;%v&quot;, names[1], f.Line)
    }

    names = strings.SplitAfterN(f.Function, perfix, 2)
    if len(names) &gt; 1 {
     callerName = names[1]
    } else {
     callerName = f.Function
    }

    return callerName, fileName
   },
   PrettyPrint: true,
  },
 ))

 logrus.SetOutput(ioutil.Discard)
 logrus.SetReportCaller(true)
 logrus.SetLevel(logrus.InfoLevel)

 logrus.WithFields(logrus.Fields{
  &quot;perfix&quot;: perfix,
  &quot;level&quot;:  logrus.GetLevel(),
 }).Warn(&quot;日志初始化完成&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="常用包"><a class="header" href="#常用包">常用包</a></h1>
<hr />
<hr />
<ul>
<li>
<p><a href="https://github.com/avelino/awesome-go">awesome-宝库值得多看</a></p>
</li>
<li>
<p><a href="https://github.com/jobbole/awesome-go-cn">各个领域优秀库-中文版</a></p>
</li>
<li>
<p><a href="https://github.com/samber/lo">lo-基于泛型加强基础功能库</a></p>
</li>
<li>
<p><a href="https://github.com/thoas/go-funk">funk-基于泛型加强基础功能库</a></p>
</li>
<li>
<p><a href="https://github.com/google/btree">btree-google开源</a></p>
</li>
<li>
<p><a href="https://pkg.go.dev/golang.org/x/exp">exp-官方扩展库值得一看</a></p>
</li>
<li>
<p><a href="https://github.com/chen3feng/stl4go">stl4go-golang版的stl</a></p>
</li>
<li>
<p><a href="https://github.com/gorse-io/gorse">gorse-推荐系统</a></p>
</li>
<li>
<p><a href="https://github.com/looplab/fsm">goreleaser-简化打包生成各个平台的包</a></p>
</li>
<li>
<p><a href="https://github.com/sourcegraph/conc">conc-更好用的并发</a></p>
</li>
<li>
<p><a href="https://goreleaser.com/">fsm-有限状态自动机</a></p>
</li>
<li>
<p><a href="https://github.com/unidoc/unioffice">unioffice-golang读写doc/excel/ppt</a></p>
</li>
<li>
<p><a href="https://github.com/cloudwego">cludewego-字节跳动开源框架</a></p>
</li>
<li>
<p><a href="https://github.com/cloudwego/fastpb">fastpb-更快的protobuf</a></p>
</li>
<li>
<p><a href="https://github.com/gogo/protobuf">gogo-更快加强版protobuf</a></p>
</li>
<li>
<p><a href="https://github.com/valyala/quicktemplate">template-更快的格式化输出</a></p>
</li>
<li>
<p><a href="https://wails.app/">wails-打包go后端+前端成一个exe</a></p>
</li>
<li>
<p><a href="https://github.com/ochinchina/supervisord">supervisord-golang版supervisor</a></p>
</li>
<li>
<p><a href="http://github.com/go-echarts/go-echarts/">go-echarts-图形库</a></p>
</li>
<li>
<p><a href="https://github.com/gonum/gonum">go-num-golang版的numpy</a></p>
</li>
<li>
<p><a href="https://github.com/gocolly/colly">colly-爬虫框架</a></p>
</li>
<li>
<p><a href="https://github.com/go-ffmt/ffmt/">ffmt-更友好fmt</a></p>
</li>
<li>
<p><a href="https://gonum.org/v1/gonum/stat/combin">combin-排序组合</a></p>
</li>
<li>
<p><a href="https://github.com/deckarep/golang-set">set-泛型集合操作</a></p>
</li>
<li>
<p><a href="https://github.com/deckarep/golang-set">carbon-方便的日期时间库</a></p>
</li>
<li>
<p><a href="https://www.vugu.org/">vugu-纯golang的前端</a></p>
</li>
<li>
<p><a href="https://github.com/cosmtrek/air">air-有变化就编码</a></p>
</li>
<li>
<p><a href="https://github.com/go-gota/gota">gota-golang版的pands</a></p>
</li>
<li>
<p><a href="https://github.com/gonum/plot">plot-golang版plotnine</a></p>
</li>
<li>
<p><a href="https://github.com/fyne-io/fyne">fyne-跨平台gui</a></p>
</li>
<li>
<p><a href="https://github.com/go-git/go-git">go-git-纯go实现git集成</a></p>
</li>
<li>
<p><a href="golang/github.com/google/go-cmp">go-cmp-自定义比较库</a></p>
</li>
<li>
<p><a href="https://gocv.io/">golang-opencv绑定</a></p>
</li>
<li>
<p><a href="https://github.com/go-opencv/go-opencv">另一个-opencv绑定</a></p>
</li>
<li>
<p><a href="https://github.com/pdfcpu/pdfcpu">pdf-处理pdf库</a></p>
</li>
<li>
<p><a href="https://github.com/stretchr/testify/assert">assert库</a></p>
</li>
<li>
<p><a href="golang/github.com/go-ego/gse">gse-golang结巴分词</a></p>
</li>
<li>
<p><a href="https://github.com/saintfish/chardet">chardet-编码猜测</a></p>
</li>
<li>
<p><a href="https://github.com/hbollon/go-edlib">edlib-最小编辑距离及相似度</a></p>
</li>
<li>
<p><a href="https://github.com/TheAlgorithms/Go">TheAlgorithms-常见算法实现</a></p>
</li>
<li>
<p><a href="https://github.com/Workiva/go-datastructures">datastructures-数据结构实现</a></p>
</li>
<li>
<p><a href="https://go-kratos.dev">kratos-微服务</a></p>
</li>
<li>
<p><a href="https://github.com/ofabry/go-callvis">callvis-可视化调用</a></p>
</li>
<li>
<p><a href="https://github.com/sasha-s/go-deadlock">deadlock-死锁检测</a></p>
</li>
<li>
<p><a href="https://github.com/gocarina/gocsv">类似json处理csv</a></p>
</li>
<li>
<p><a href="https://github.com/spf13/cobra">cobra-优秀的命令行</a></p>
</li>
<li>
<p><a href="https://github.com/pkg/errors">更丰富的errors</a></p>
</li>
<li>
<p><a href="https://github.com/bradfitz/gomemcache/memcache">memcache</a></p>
</li>
<li>
<p><a href="https://github.com/gomodule/redigo/redis">redis</a></p>
</li>
<li>
<p><a href="https://github.com/mongodb/mongo-go-driver">mongodb</a></p>
</li>
<li>
<p><a href="golang/github.com/go-sql-driver/mysql">mysql</a></p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-go/">grpc</a></p>
</li>
<li>
<p><a href="https://grpc-ecosystem.github.io/grpc-gateway/">grpc转换http接口</a></p>
</li>
<li>
<p><a href="https://www.iris-go.com/">iris</a></p>
</li>
<li>
<p><a href="https://gin-gonic.com/">gin</a></p>
</li>
<li>
<p><a href="https://github.com/labstack/echo/">echo</a></p>
</li>
<li>
<p><a href="https://github.com/go-gorm">gorm</a></p>
</li>
<li>
<p><a href="https://gitea.com/xorm/xorm">xorm</a></p>
</li>
<li>
<p><a href="https://github.com/go-gomail/gomail">发邮件</a></p>
</li>
<li>
<p><a href="https://github.com/json-iterator/go">更快的json</a></p>
</li>
<li>
<p><a href="https://github.com/hokaccha/go-prettyjson">漂亮json输出</a></p>
</li>
<li>
<p><a href="https://github.com/tidwall/gjson">从json文档中直接读取相关值</a></p>
</li>
<li>
<p><a href="https://github.com/brahma-adshonor/gohook">gohook动态替换函数</a></p>
</li>
<li>
<p><a href="https://github.com/patrickmn/go-cache">go-cache-内存缓存</a></p>
</li>
<li>
<p><a href="https://github.com/skip2/go-qrcode">二维码</a></p>
</li>
<li>
<p><a href="https://github.com/aeden/traceroute">traceroute-路由跟踪</a></p>
</li>
<li>
<p><a href="https://github.com/otiai10/gosseract">tesseract-golang调用ocr</a></p>
</li>
<li>
<p><a href="https://github.com/fatih/color">在标准输出中彩色输出</a></p>
</li>
<li>
<p><a href="golang/github.com/mxschmitt/golang-combinations">combination-组合库</a></p>
</li>
<li>
<p><a href="golang/github.com/deltam/perm">perm-排列库</a></p>
</li>
<li>
<p><a href="https://golang.org/x/text/encoding/simplifiedchinese">中文GBK-utf8转换</a></p>
</li>
<li>
<p><a href="https://github.com/jinzhu/copier">各种跨类型-复制</a></p>
</li>
<li>
<p><a href="https://github.com/bits-and-blooms/bloom">bloom-布隆过滤器</a></p>
</li>
<li>
<p><a href="https://github.com/qax-os/excelize">操作excel</a></p>
</li>
<li>
<p><a href="https://github.com/spf13/viper">多种格式配置文件</a></p>
</li>
<li>
<p><a href="https://github.com/sirupsen/logrus">日志库-logrus</a></p>
</li>
<li>
<p><a href="https://github.com/golang/glog">日志库-glog</a></p>
</li>
<li>
<p><a href="https://github.com/silenceper/wechat">wechat-微信SDK</a></p>
</li>
<li>
<p><a href="https://github.com/google/gopacket">gopacket</a></p>
</li>
<li>
<p><a href="https://github.com/go-resty/resty">更方便httpclient</a></p>
</li>
<li>
<p><a href="https://github.com/swaggo/swag">swag文档</a></p>
</li>
<li>
<p><a href="https://github.com/GoAdminGroup/go-admin">go-admin</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/tidb">tidb数据库</a></p>
</li>
<li>
<p><a href="https://github.com/nsqio/nsq">nsq实时消息</a></p>
</li>
<li>
<p><a href="https://github.com/OpenIMSDK/Open-IM-Server">OpenIM</a></p>
</li>
<li>
<p><a href="https://github.com/smallnest/rpcx">rpcx-微服务框架</a></p>
</li>
<li>
<p><a href="https://go-zero.dev">go-zero</a></p>
</li>
<li>
<p><a href="https://github.com/qax-os/goreporter">360的goreporter,几年没更新估计死掉了</a></p>
</li>
<li>
<p><a href="http://github.com/chromedp/chromedp">Chromedp</a></p>
<ul>
<li>chromedp是一个更快、更简单的Golang库用于调用支持Chrome DevTools协议的浏览器，同时不需要额外的依赖（例如Selenium和PhantomJS)</li>
<li>Chrome DevTools其实就是Chrome浏览器按下F12之后的控制终端</li>
</ul>
</li>
<li>
<p><a href="https://github.com/carlmjohnson/requests">golang-request</a></p>
</li>
<li>
<p><a href="https://github.com/monaco-io/request">golang-另一个request</a></p>
</li>
<li>
<p><a href="golang/github.com/bingoohuang/xlsx">xlsx-另一个xlsx库</a>,已知bug,列名不能互相包含,否则出错</p>
</li>
</ul>
<h3 id="检查代码中是否包括密码密钥之类gitleaks"><a class="header" href="#检查代码中是否包括密码密钥之类gitleaks">检查代码中是否包括密码密钥之类<a href="https://github.com/zricethezav/gitleaks">gitleaks</a></a></h3>
<pre><code class="language-bash">git clone https://github.com/zricethezav/gitleaks.git
cd gitleaks
make build
# 主要可用在阻挡提交
# detect protect
gitleaks detect -s=. -r=out.json
</code></pre>
<h3 id="检查代码中sql安全gokart"><a class="header" href="#检查代码中sql安全gokart">检查代码中sql安全<a href="https://github.com/praetorian-inc/gokart">gokart</a></a></h3>
<h3 id="检查代码安全gosec"><a class="header" href="#检查代码安全gosec">检查代码安全<a href="https://github.com/securego/gosec">gosec</a></a></h3>
<h3 id="检查魔术常量检查go-mnd"><a class="header" href="#检查魔术常量检查go-mnd">检查魔术常量检查<a href="https://github.com/tommy-muehle/go-mnd">go-mnd</a></a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="exgexp包"><a class="header" href="#exgexp包">exgexp包</a></h1>
<hr />
<ul>
<li>正则语法</li>
</ul>
<pre><code class="language-golang">// 连续的汉字字母数字
var maxHanDigitAlphaReg = regexp.MustCompile(`[\p{Han}[:digit:][:alpha:]]+`)
// 单个汉字字母数字
var minHanDigitAlphaReg = regexp.MustCompile(`[\p{Han}[:digit:][:alpha:]]+?`)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="shell"><a class="header" href="#shell">shell</a></h1>
<hr />
<h3 id="编译常用示例"><a class="header" href="#编译常用示例">编译常用示例</a></h3>
<pre><code class="language-shell">#! /bin/bash

target=local

set -x #回显执行命令

GOPATH=$(go env GOPATH)
GITVERSION=$(git describe --tags --always)
GITBRANCH=$(git symbolic-ref -q --short HEAD)
DATETIME=$(date &quot;+%Y-%m-%d_%H:%M:%S&quot;)
HOSTNAME=$(hostname)

golangci-lint run --timeout=1h

revive -formatter friendly ./...

rm -rf ${target}*

go build -o ${target} -ldflags &quot;-w -s -X main.GitHash=${GITVERSION}-${GITBRANCH} -X main.CompileTime=${DATETIME} -X main.HostName=${HOSTNAME}&quot; .

./${target}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="sort包"><a class="header" href="#sort包">sort包</a></h1>
<hr />
<pre class="mermaid">classDiagram
Interface &lt;|-- IntSlice : 实现
Interface &lt;|-- Float64Slice : 实现
Interface &lt;|-- StringSlice : 实现

class Interface{
    +Len() int
    +Less(i, j int) bool
    +Swap(i, j int)
}
</pre>
<pre class="mermaid">classDiagram
Interface &lt;|.. Sort : 依赖
Sort &lt;|-- Ints : []int
Sort &lt;|-- Float64s : []float64
Sort &lt;|-- Strings : []string
Sort &lt;|-- Slice : []其他类型

</pre>
<pre class="mermaid">classDiagram
Search &lt;|-- SearchInts : []int
Search &lt;|-- SearchFloat64s : []float64
Search &lt;|-- SearchStrings : []string

</pre>
<pre><code class="language-golang">type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}

// 采用快排/堆排/插排组合
func Sort(data Interface)
func Ints(x []int)
func Float64s(x []float64)
func Strings(x []string)
//采用反射自动实现Swap(i, j int)
func Slice(x any, less func(i, j int) bool)


// 稳排采用分段插排+合并组合
func Stable(data Interface)
func SliceStable(x any, less func(i, j int) bool)

// 二分搜索有序序列
func Search(n int, f func(int) bool) int
func SearchInts(a []int, x int) int
func SearchFloat64s(a []float64, x float64) int
func SearchStrings(a []string, x string) int
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="stringer"><a class="header" href="#stringer">stringer</a></h1>
<hr />
<h3 id="官方自动生成string"><a class="header" href="#官方自动生成string">官方自动生成string</a></h3>
<ul>
<li>main.go内容</li>
</ul>
<pre><code class="language-golang">//go:generate stringer -type=Pill
type Pill int

const (
 Placebo Pill = iota
 Aspirin
 Ibuprofen
 Paracetamol
 Acetaminophen = Paracetamol
)
</code></pre>
<ul>
<li>执行命令</li>
</ul>
<pre><code class="language-sh">go generate
</code></pre>
<ul>
<li>生成的pill_string.go内容</li>
</ul>
<pre><code class="language-golang">import &quot;strconv&quot;

// 这段防止generate之后,修改后没有再次generate,通过编译错误强制提示
func _() {
 // An &quot;invalid array index&quot; compiler error signifies that the constant values have changed.
 // Re-run the stringer command to generate them again.
 var x [1]struct{}
 _ = x[Placebo-0]
 _ = x[Aspirin-1]
 _ = x[Ibuprofen-2]
 _ = x[Paracetamol-3]
}

const _Pill_name = &quot;PlaceboAspirinIbuprofenParacetamol&quot;

var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
 if i &lt; 0 || i &gt;= Pill(len(_Pill_index)-1) {
  return &quot;Pill(&quot; + strconv.FormatInt(int64(i), 10) + &quot;)&quot;
 }
 return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="python"><a class="header" href="#python">python</a></h1>
<hr />
<h3 id="重要网站"><a class="header" href="#重要网站">重要网站</a></h3>
<hr />
<ul>
<li><a href="https://www.python.org/">官网</a></li>
</ul>
<blockquote>
<p>python2已死,不要再学再用啦！！！</p>
</blockquote>
<ul>
<li><a href="https://pypi.org/">pypi</a></li>
</ul>
<blockquote>
<p>官方第三方包网站,你绝对值得拥有!</p>
</blockquote>
<ul>
<li>venv-解决不同项目依赖不同版本包,依赖冲突</li>
</ul>
<pre><code class="language-bash"># 源码编译安装
# 官网 python.org 下载压缩包，解压
# 然后，在./configure的时候，需要加上  --enable-optimizations参数，这样才能启用很多功能。

# 创建tutorial-env目录,复制一份python相关环境
python3 -m venv tutorial-env

# windows执行，激活虚拟环境
tutorial-env\Scripts\activate.bat

# Macos/unix执行，激活虚拟环境
source tutorial-env/bin/activate
</code></pre>
<h3 id="安装pip"><a class="header" href="#安装pip">安装pip</a></h3>
<hr />
<pre><code class="language-sh">#看看pip是否安装,现在一般都安装的,特别是采用brew,安装包之类
python3 -m pip --version
#手动安装,一般不用
python3 -m ensurepip --default-pip

# 升级pip
python3 -m pip install --upgrade pip

# 在某些情况下，我们需要查看第三方包的依赖包和被依赖包
# 命令输出的 Requires 和 Required-by
pip show pkg_name 
# 能显示所有的依赖包及其子包,推荐用这个
pip deptree -p pkg_name
# 永久性切换国内清华源
pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
# 换回默认源
pip3 config unset global.index-url
# 本次下载python中的Django包，这里使用的是豆瓣源
pip3 install django -i http://pypi.douban.com/simple 
</code></pre>
<h3 id="requirementstxt可以通过pip命令自动生成和安装"><a class="header" href="#requirementstxt可以通过pip命令自动生成和安装">requirements.txt可以通过pip命令自动生成和安装</a></h3>
<ul>
<li>生成requirements.txt文件</li>
</ul>
<pre><code class="language-bash"># 产生整个python环境的安装依赖,方便移值及复制
pip freeze &gt; requirements.txt
</code></pre>
<ul>
<li>安装requirements.txt依赖包：</li>
</ul>
<pre><code class="language-bash">pip install -r requirements.txt
</code></pre>
<h3 id="安装常用库"><a class="header" href="#安装常用库">安装常用库</a></h3>
<hr />
<pre><code class="language-sh"># pylint执行pep8规范
pip3 install pylint

pylint xxx.py

# 更严格的检测flake8
pip3 install flake8

flake8 xx.py

# 强制统一代码风格
pip install black

black code_dir/xxx.py

# yapf是google开源的格式化代码工具
pip install yapf 

# 统一import格式
pip3 install isort

isort xx.py

# 静态检查
pip3 install mypy

mypy xxx.py

# 比内置unittest更好用单元测试
pip3 install pytest
</code></pre>
<pre><code class="language-python"># content of test_sample.py
def inc(x):
    return x + 1


def test_answer():
    assert inc(3) == 5
</code></pre>
<pre><code class="language-bash">pytest
</code></pre>
<pre><code class="language-python">if __name__ == '__main__':
    # 我是主模块身份
  
# 列举任意对象的全部属性
dir(obj)
</code></pre>
<ul>
<li><a href="http://www.fabfile.org/">fabric</a></li>
<li><a href="https://github.com/vinta/awesome-python">awesome-python</a></li>
<li><a href="https://www.selenium.dev/">Selenium是一个用电脑模拟人操作浏览器网页</a></li>
<li><a href="https://pypi.org/project/Js2Py/">js2py纯python执行js</a></li>
<li><a href="https://github.com/Supervisor/supervisor">supervisor-进程管理</a></li>
<li><a href="https://numpy.org/">numpy</a></li>
<li><a href="https://pandas.pydata.org/">pandas</a></li>
<li><a href="https://github.com/PyGithub/PyGithub">PyGithub-封装github的api</a></li>
<li><a href="https://plotnine.readthedocs.io/en/stable/">plotnine</a></li>
<li><a href="https://python-pillow.org">pillow</a></li>
<li><a href="https://www.xlwings.org/">xlwings操作excel</a></li>
<li><a href="https://www.flet.dev/">flet-flutter的python包装</a></li>
<li><a href="https://docs.pydantic.dev/">pydantic-类型注解加强版</a></li>
<li><a href="https://www.anaconda.com/">anaconda-独立开源包管理器</a></li>
</ul>
<blockquote>
<p>Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等
Miniconda包括Conda、Python
conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换</p>
</blockquote>
<ul>
<li><a href="https://www.djangoproject.com/">Django</a></li>
</ul>
<pre><code class="language-python"># settings.py
LANGUAGE_CODE = &quot;zh-hans&quot;
TIME_ZONE = &quot;Asia/Shanghai&quot;
USE_TZ = False
</code></pre>
<ul>
<li><a href="http://flask.pocoo.org/">Flask</a></li>
<li><a href="http://docs.python-requests.org/en/master/">requests</a></li>
<li><a href="https://www.python-httpx.org/">httpx-异步版requests</a></li>
<li><a href="http://www.django-rest-framework.org/">Django-rest-framework</a></li>
<li><a href="https://scrapy.org/">scrapy</a></li>
<li><a href="https://falconframework.org/">falcon</a></li>
<li><a href="https://www.odoo.com/zh_CN">odoo以前openERP</a></li>
<li><a href="https://www.uvicorn.org/">uvicorn-快如闪电的web框架</a></li>
</ul>
<pre><code class="language-bash">docker odoo
</code></pre>
<ul>
<li><a href="https://frida.re/">frida</a></li>
<li><a href="https://github.com/vibora-io/vibora">vibora</a></li>
<li><a href="https://github.com/pipermerriam/web3.py">web3.py</a></li>
<li><a href="https://github.com/shibing624/pycorrector">pycorrector-中文纠错</a></li>
<li><a href="https://github.com/untitaker/python-atomicwrites">atomicwrites-原子写</a></li>
<li><a href="https://docs.sqlalchemy.org/en/20/">sqlalchemy2.0-sql数据库</a></li>
<li>[deepcompare-深度比较]</li>
<li>[jsonlines-jsonl文件]</li>
<li>[boltons-常见第三方工具集合]</li>
<li><a href="https://fastapi.tiangolo.com/">fastapi-后起之秀http框架</a></li>
<li><a href="https://sanic.dev/">sanic-最快的web框架</a></li>
<li><a href="https://www.python-office.com/">office-自动化系列</a></li>
<li><a href="https://pyodide.org">Pyodide-浏览器中运行python,采用webasm</a></li>
</ul>
<pre><code class="language-python">from atomicwrites import atomic_write

with atomic_write('foo.txt', overwrite=True) as f:
    f.write('Hello world.')
    # &quot;foo.txt&quot; doesn't exist yet.
# Now it does.
</code></pre>
<h3 id="特别包"><a class="header" href="#特别包">特别包</a></h3>
<pre><code class="language-bash"># import cv2
pip3 install opencv-python

pip3 install numpy

# import PIL
pip3 install pillow

pip3 install image

# No matching distribution found for onnxruntime
# 暂时不支持m1芯片
pip3 install onnxruntime
</code></pre>
<h3 id="浏览器本地文档"><a class="header" href="#浏览器本地文档">浏览器本地文档</a></h3>
<hr />
<pre><code class="language-sh">#更多命令 pydoc3 -help
pydoc3 -p 7070
</code></pre>
<p><img src="python/webp/python/python_pydoc3.webp" alt="python_pydoc" /></p>
<h3 id="说明requirementtxt"><a class="header" href="#说明requirementtxt">说明requirement.txt</a></h3>
<ul>
<li>通常我们会在项目的根目录下放置一个 requirement.txt 文件，用于记录所有依赖包和它的确切版本号。</li>
<li>每行一个依赖包,可以指定包的具体版本</li>
</ul>
<h2 id="web服务器与app协议之wsgiasgi"><a class="header" href="#web服务器与app协议之wsgiasgi">web服务器与app协议之WSGI、ASGI</a></h2>
<ul>
<li>
<p>WSGI-同步web应用</p>
<ul>
<li>python-web-app，也就是web应用层，实现WSGI接口，用作web请求的handler</li>
<li>用户向python-web-server发送web请求</li>
<li>python-web-server，又称作WSGI Server，解析请求数据，整理当前session的环境信息</li>
<li>python-web-server加载python-web-app，调用python-web-app实例的WSGI接口，处理请求</li>
<li>python-web-app处理完请求，返回结果给到python-web-server</li>
<li>python-web-server写回返回结果，给回用户</li>
</ul>
</li>
</ul>
<pre><code class="language-python">def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/plain')])
    return [b'Greetings universe']
</code></pre>
<ul>
<li>
<p>ASGI-异步web应用</p>
<ul>
<li>一方面是支持asyncio的机制</li>
<li>另一方面也能够解决WSGI难以支持WebSocket之类长连接模式的问题</li>
<li>执行流程和wsgi差不多</li>
</ul>
</li>
</ul>
<pre><code class="language-python">async def application(scope, receive, send):
    event = await receive()
    ...
    await send({&quot;type&quot;: &quot;websocket.send&quot;, ...})
</code></pre>
<pre><code class="language-bash"># 直接下载whl文件,本地安装
pip3 install xxx.whl
</code></pre>
<ul>
<li>另一个神经网络模型可视化-<a href="https://github.com/lutzroeder/Netron">Netron</a></li>
</ul>
<h3 id="wheel轮子wheel是一个zip压缩文件将whl扩展名替换为zip"><a class="header" href="#wheel轮子wheel是一个zip压缩文件将whl扩展名替换为zip">wheel(轮子),wheel是一个zip压缩文件，将.whl扩展名替换为.zip</a></h3>
<ul>
<li>
<p>wheel是python新的发行标准，旨在替代传统的egg，pip &gt;=1.4的版本均支持wheel， 使用wheel作为你python库的发行文件，有如下好处：</p>
<ul>
<li>纯Python和本机C扩展软件包的安装速度更快</li>
<li>避免执行任意代码进行安装。</li>
<li>(避免setup.py）C扩展的安装不需要在Linux，Windows或macOS上进行编译</li>
<li>允许更好地缓存以进行测试和持续集成</li>
<li>在安装过程中创建.pyc文件，以确保它们与使用的Python解释器匹配跨平台和机器的安装更加一致</li>
</ul>
<pre><code class="language-bash"># 制作wheel安装包-方式1
python setup.py bdist_wheel
# 制作wheel安装包-方式2
pip wheel --wheel-dir=/root/whl ./
</code></pre>
</li>
</ul>
<h3 id="注解解释"><a class="header" href="#注解解释"><a href="https://www.cnblogs.com/hls-code/p/15393272.html">注解解释</a></a></h3>
<ul>
<li>
<p>在 Python 3.5 中，Python PEP 484 引入了类型注解（type hints）</p>
</li>
<li>
<p>在 Python 3.6 中，PEP 526 又进一步引入了变量注解（Variable Annotations）。</p>
</li>
<li>
<p>具体的变量注解语法可以归纳为两点：</p>
<ul>
<li>在声明变量时，变量的后面可以加一个冒号，后面再写上变量的类型，如 int、list 等等。</li>
<li>在声明方法返回值的时候，可以在方法的后面加一个箭头，后面加上返回值的类型，如 int、list 等等。</li>
</ul>
</li>
<li>
<p>在PEP 8 中，具体的格式是这样规定的：</p>
<ul>
<li>在声明变量类型时，变量后方紧跟一个冒号，冒号后面跟一个空格，再跟上变量的类型。</li>
<li>在声明方法返回值的时候，箭头左边是方法定义，箭头右边是返回值的类型，箭头左右两边都要留有空格。</li>
</ul>
</li>
<li>
<p>值得注意的是，这种类型和变量注解实际上只是一种类型提示，对运行实际上是没有影响的。</p>
</li>
</ul>
<h3 id="opencvpython绑定"><a class="header" href="#opencvpython绑定">opencv,python绑定</a></h3>
<pre><code class="language-python"># OpenCV-Python接口中使用cv2.findContours ()函数来查找检测物体的轮廓。 
contours, hierarchy = cv2.findContours (image,mode,method)

# mask是与iamge一样大小的矩阵，其中的数值为0或者1，为1的地方，计算出image中所有元素的均值，为0 的地方，不计算
cv::Scalar mean = cv2.mean (image, mask)

应用cv2.warpPerspective()前需先使用cv2.getPerspectiveTransform()得到转换矩阵
cv2.warpPerspective() 叫做透视变换。

# 以彩色模式加载图片
img = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
</code></pre>
<h3 id="paddleocr"><a class="header" href="#paddleocr">paddleocr</a></h3>
<pre><code class="language-python">
self.input_tensor.copy_from_cpu(norm_img_batch)
self.predictor.run()
outputs = []
for output_tensor in self.output_tensors:
    output = output_tensor.copy_to_cpu()
    outputs.append(output)
if len(outputs) != 1:
    preds = outputs
else:
    preds = outputs[0]
  
</code></pre>
<ul>
<li>Tensor 是 Paddle Inference 的数据组织形式，用于对底层数据进行封装并提供接口对数据进行操作，包括设置 Shape、数据、LoD 信息等。 注意： 应使用 Predictor 的 get_input_handle 和 get_output_handle 接口获取输入输出 Tensor</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fabric示例"><a class="header" href="#fabric示例">fabric示例</a></h1>
<pre><code class="language-python">
#!python3
# -*- coding:utf8 -*-

# fab默认采用fabfile.py作为入口代码脚本,否则就要指定 -f xxx.py
# task函数名不要用下划线,否则task名称会改变

# pip3 install fabric2
# pip3 install pyyaml


from fabric import task
from fabric import Connection

cur_remote_data_path = &quot;/root/&quot;
cur_remote_conn = Connection(
    &quot;root@ip&quot;,
)


def upload(file_list):
    global cur_remote_conn, cur_remote_data_path

    assert cur_remote_conn, &quot;远程主机为空&quot;
    assert cur_remote_data_path, &quot;远程数据路径为空&quot;

    for file in file_list:
        print(file, &quot;put over&quot;)

    for file in file_list:
        cur_remote_conn.put(file, cur_remote_data_path)
        print(file, &quot;put over&quot;)


@task
def download(c):
    global cur_remote_conn
    assert cur_remote_conn, &quot;远程主机为空&quot;

    # 下载日志
    cur_remote_conn.get(&quot;index.html&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fastapi示例"><a class="header" href="#fastapi示例">fastapi示例</a></h1>
<pre><code class="language-python">from typing import Union

from fastapi import FastAPI

from pydantic import BaseModel

# async def app(scope, receive, send):
app = FastAPI()


class Item(BaseModel):
    name: str
    price: float
    is_offer: Union[bool, None] = None


@app.get(&quot;/&quot;)
def read_root():
    return {&quot;Hello&quot;: &quot;World&quot;}


@app.get(&quot;/items/{item_id}&quot;)
async def read_item(item_id: int, q: Union[str, None] = None):
    return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}


@app.put(&quot;/items/{item_id}&quot;)
def update_item(item_id: int, item: Item):
    return {&quot;item_id&quot;: item_id, &quot;item&quot;: item}


if __name__ == &quot;__main__&quot;:
    import uvicorn

    uvicorn.run(&quot;main:app&quot;, reload=True)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memcached示例"><a class="header" href="#memcached示例">memcached示例</a></h1>
<pre><code class="language-sh">pip3 install pymemcache
</code></pre>
<pre><code class="language-python">#!python3
from pymemcache.client.base import Client

client = Client('localhost')

memKey = '/memcached'

client.set(memKey, '&lt;HTML&gt;&lt;H1&gt;Hi, Memcached!&lt;/H1&gt;&lt;/HTML&gt;')

result = client.get(memKey)

print(result)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numpy示例"><a class="header" href="#numpy示例">numpy示例</a></h1>
<pre><code class="language-python">#!python3
# -*- coding:utf8 -*-

import numpy as np
b = np.ones((3, 4), dtype=np.int64)
# [[1 1 1 1]
#  [1 1 1 1]
#  [1 1 1 1]]
print(b)

print(&quot;b shape:&quot;, b.shape)

a = np.array([[1, 5, 5, 2],
              [9, 6, 2, 8],
              [3, 7, 9, 1]])

print(&quot;a shape:&quot;, a.shape)

# 每列最大值下标,[1 2 2 1]
print(&quot;argmax axis=0&quot;, np.argmax(a, axis=0))

# 每列最大值下标,[9 7 9 8]
print(&quot;max axis=0&quot;, np.max(a, axis=0))

# 每行最大值下标,[1 0 2]
print(&quot;argmax axis=1&quot;, np.argmax(a, axis=1))

# 每行最大值下标,[5 9 9]
print(&quot;max axis=1&quot;, np.max(a, axis=1))


a = np.array([1, 2, 3])
b = np.array([11, 22, 33])
c = np.array([44, 55, 66])
# 有效的数组拼接
abc = np.concatenate((a, b, c), axis=0)
print(&quot;abc shape:&quot;, abc)

a = np.array([[1, 5, 5, 2],
              [9, 6, 2, 8],
              [3, 7, 9, 1]])

# 用于将数组的元素沿指定的轴旋转90度
a_rot = np.rot90(a)
print(&quot;a_rot:&quot;, a_rot)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="大厂提供ocr接口"><a class="header" href="#大厂提供ocr接口">大厂提供ocr接口</a></h1>
<h2 id="阿里"><a class="header" href="#阿里">阿里</a></h2>
<pre><code class="language-python"># -*- coding: utf-8 -*-

# pip install -r requirement.txt
# pip install alibabacloud_ocr_api20210707==1.1.8
import json
from logging import exception

from alibabacloud_ocr_api20210707.client import Client as ocr_api20210707Client
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_ocr_api20210707 import models as ocr_api_20210707_models
from alibabacloud_tea_util import models as util_models

# https://help.aliyun.com/document_detail/331008.html
# https://ocr.console.aliyun.com/overview?spm=5176.12127803.J_5253785160.2.4f767813QmL9ES
# 每个月免费200次,后付费类型
def aliyun(img_url):
    config = open_api_models.Config(
        # 您的 AccessKey ID,
        access_key_id=&quot;xxxx&quot;,
        # 您的 AccessKey Secret,
        access_key_secret=&quot;yyyy&quot;,
    )
    # 访问的域名
    config.endpoint = &quot;ocr-api.cn-hangzhou.aliyuncs.com&quot;
    client = ocr_api20210707Client(config)

    recognize_general_request = ocr_api_20210707_models.RecognizeGeneralRequest(
        url=img_url
    )
    runtime = util_models.RuntimeOptions()
    try:
        # 复制代码运行请自行打印 API 的返回值
        resp = client.recognize_general_with_options(
            recognize_general_request, runtime
        ).to_map()
        data_json = json.loads(resp[&quot;body&quot;][&quot;Data&quot;])
        return data_json[&quot;content&quot;]
    except Exception as error:
        return str(error)
</code></pre>
<h2 id="tencent"><a class="header" href="#tencent">tencent</a></h2>
<pre><code class="language-shell">tencentcloud-sdk-python=3.0.720
</code></pre>
<pre><code class="language-python"># pip install tencentcloud-sdk-python=3.0.720

from tencentcloud.common import credential
from tencentcloud.common.profile.client_profile import ClientProfile
from tencentcloud.common.profile.http_profile import HttpProfile
from tencentcloud.common.exception.tencent_cloud_sdk_exception import (
    TencentCloudSDKException,
)
from tencentcloud.ocr.v20181119 import ocr_client, models

# 免费额度，每月1000次
# https://console.cloud.tencent.com/ocr/stats
def tencent(img_url):
    try:
        # 实例化一个认证对象，入参需要传入腾讯云账户secretId，secretKey,此处还需注意密钥对的保密
        # 密钥可前往https://console.cloud.tencent.com/cam/capi网站进行获取

        cred = credential.Credential(
            &quot;aaaa&quot;,
            &quot;vvvvv&quot;,
        )
        # 实例化一个http选项，可选的，没有特殊需求可以跳过
        httpProfile = HttpProfile()
        httpProfile.endpoint = &quot;ocr.tencentcloudapi.com&quot;

        # 实例化一个client选项，可选的，没有特殊需求可以跳过
        clientProfile = ClientProfile()
        clientProfile.httpProfile = httpProfile
        # 实例化要请求产品的client对象,clientProfile是可选的
        client = ocr_client.OcrClient(cred, &quot;ap-hongkong&quot;, clientProfile)

        # 实例化一个请求对象,每个接口都会对应一个request对象
        req = models.GeneralBasicOCRRequest()
        params = {&quot;ImageUrl&quot;: img_url}
        req.from_json_string(json.dumps(params))

        # 返回的resp是一个GeneralBasicOCRResponse的实例，与请求对象对应
        resp = client.GeneralBasicOCR(req)
        text_list = []
        for td in resp.TextDetections:
            text_list.append(td.DetectedText)
        return &quot;&quot;.join(text_list)

    except TencentCloudSDKException as err:
        return str(err)
</code></pre>
<h2 id="调用"><a class="header" href="#调用">调用</a></h2>
<pre><code class="language-python">
import _thread
import random


def img_to_text(img_url):
    handle = aliyun
    if random.randint(0, 3) &gt; 0:
        handle = tencent
    try:
        _thread.start_new_thread(handle, (img_url))
        return handle.__name__
    except exception as e:
        print(str(e))


if __name__ == &quot;__main__&quot;:
    img_to_text(&quot;abc&quot;)
    # tencent(
    #     &quot;http://mmbiz.qpic.cn/mmbiz_jpg/orWialEIuwfvLgnHX8t8sXpMqWlsvsSW5E8KtF985vlVxRfFX5aq0ckQnWOAeYMF1Oo7wUMqfu7oCe76v3zT2kw/0&quot;
    # )

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paddleocr示例"><a class="header" href="#paddleocr示例">paddleocr示例</a></h1>
<h3 id="百度开源paddle"><a class="header" href="#百度开源paddle"><a href="https://www.paddlepaddle.org.cn/">百度开源Paddle</a></a></h3>
<ul>
<li>安装框架</li>
</ul>
<pre><code class="language-bash">python3 -m pip install paddlepaddle==2.3.1 -i https://mirror.baidu.com/pypi/simple
</code></pre>
<ul>
<li>安装ocr</li>
</ul>
<pre><code class="language-bash">pip3 install &quot;paddleocr&gt;=2.0.1&quot; -i https://mirror.baidu.com/pypi/simple
</code></pre>
<ul>
<li>
<p><a href="https://github.com/PaddlePaddle/PaddleOCR/issues/6720">m1芯片特别安装</a></p>
<ul>
<li>Download source code locally</li>
<li>In requirements.txt, update to opencv-contrib-python==4.6.0.66</li>
<li>Pip install - r requirements.txt</li>
<li>python setup.py install</li>
<li>ppadleocr 安装在/opt/homebrew/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/bin</li>
<li>第一次运行会下载训练好的模型到~/.paddleocr目录</li>
<li>ln -s /opt/homebrew/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/bin/paddleocr paddleocr</li>
</ul>
</li>
<li>
<p>安装paddleocrlabel</p>
</li>
<li>
<p>[m1芯片源码安装]</p>
<ul>
<li>下载源码</li>
</ul>
<pre><code class="language-bash">git clone git@github.com:PaddlePaddle/PaddleOCR.git
cd PPOCRLabel
python setup.py install
# 如果出现安装pyqt5失败,则采用brew install pyqt5
Installing PPOCRLabel script to /opt/homebrew/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/bin
cd /opt/homebrew/bin
ln -s /opt/homebrew/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/bin/PPOCRLabel PPOCRLabel


# 运行,第一运行会下载必要东西~/.paddleocr目录
PPOCRLabel --lang ch
# 针对特别业务,可以事先处理图片,再传入自动标注
</code></pre>
</li>
</ul>
<pre><code class="language-bash"># applie m1 芯片安装,会有问题，因为没有直接aarch64.whl,需要重头编译,但目前没有办法成功
pip3 install pyqt5

# 幸好brew可以帮忙编译
brew install pyqt5
</code></pre>
<ul>
<li>模型结构可视化VisualDL</li>
</ul>
<pre><code class="language-bash">python3 -m pip install visualdl -i https://mirror.baidu.com/pypi/simple
# Running VisualDL at http://localhost:8040/ (Press CTRL+C to quit)
./visualdl
# 网络结构-静态，把模型文件拖进去&lt;https://www.paddlepaddle.org.cn/inference/master/guides/export_model/visual_model.html&gt;
</code></pre>
<pre><code class="language-python">#!python3
import re
from PIL import Image
from paddleocr import PaddleOCR, draw_ocr

# Paddleocr目前支持的多语言语种可以通过修改lang参数进行切换
# 例如`ch`, `en`, `fr`, `german`, `korean`, `japan`
# need to run only once to download and load model into memory
ocr = PaddleOCR(use_angle_cls=False, lang=&quot;ch&quot;, show_log=False)
img_path = '01.jpg'
result = ocr.ocr(img_path, cls=False)
# for line in result:
#     for box in line:
#         print(type(box), box)
#     break

result = result[0]
# 显示结果

image = Image.open(img_path).convert('RGB')
# boxes = [line[0] for line in result]
# txts = [line[1][0] for line in result]
# scores = [line[1][1] for line in result]
boxes = [result[0]]
txts = [result[1][0]]
scores = [result[1][1]]
im_show = draw_ocr(image, boxes, txts, scores, font_path='simfang.ttf')
im_show = Image.fromarray(im_show)
im_show.save('result.jpg')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis示例"><a class="header" href="#redis示例">redis示例</a></h1>
<pre><code class="language-sh">pip3 install redis
</code></pre>
<pre><code class="language-python">#!python3
import redis

client = redis.Redis(host=&quot;localhost&quot;, port=6379, db=0)

key = &quot;/redis&quot;

client.set(key, &quot;&lt;HTML&gt;&lt;H1&gt;Hi, Redis!&lt;/H1&gt;&lt;/HTML&gt;&quot;)

resp = client.get(key)

print(resp)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requests示例"><a class="header" href="#requests示例">requests示例</a></h1>
<pre><code class="language-python">#!python3
# -*- coding:utf8 -*-

# pip3 install requests

import requests

r = requests.get(&quot;https://www.baidu.com/&quot;)

print(r.headers)
print(r.text)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="httpx示例"><a class="header" href="#httpx示例">httpx示例</a></h1>
<pre><code class="language-python">import httpx
r = httpx.get('https://www.baidu.com/')
print(r.headers['content-type'])
print(r.text)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opencv示例"><a class="header" href="#opencv示例">opencv示例</a></h1>
<pre><code class="language-python">#!python3
# -*- coding:utf8 -*-

import cv2
import numpy as np

img = cv2.imread(&quot;01.jpg&quot;, cv2.IMREAD_COLOR)
img_org = img.copy()

print(&quot;img shape&quot;, img.shape, cv2.IMREAD_COLOR, cv2.COLOR_GRAY2BGR)

# 得到图片的高和宽
img_height, img_width = img.shape[:2]

# 定义对应的点
points1 = np.float32([[75, 55], [340, 55], [33, 435], [400, 433]])
points2 = np.float32([[0, 0], [360, 0], [0, 420], [360, 420]])

# 计算得到转换矩阵
M = cv2.getPerspectiveTransform(points1, points2)

# 实现透视变换转换
processed = cv2.warpPerspective(img, M, (360, 420))

# 读取灰度图片,转彩色
img_gray = cv2.imread(&quot;01.jpg&quot;, 0)
img_gray_rgb = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2BGR)

# 显示原图和处理后的图像
cv2.imshow(&quot;org&quot;, img_org)
cv2.imshow(&quot;processed&quot;, processed)
cv2.imshow(&quot;img_gray_rgb&quot;, img_gray_rgb)

cv2.waitKey(0)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js2py示例"><a class="header" href="#js2py示例">js2py示例</a></h1>
<pre><code class="language-python">import js2py

# 超级慢,需要改写成python
js_code = &quot;&quot;&quot;
function Add(x, y) {
    return x + y;
}
&quot;&quot;&quot;

js_add = js2py.eval_js(js_code)

if __name__ == &quot;__main__&quot;:
    print(js_add(1, 3))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="woff字体转png"><a class="header" href="#woff字体转png">woff字体转png</a></h1>
<pre><code class="language-python">from fontTools.ttLib import TTFont

import os
import shutil
from fontTools.pens.svgPathPen import SVGPathPen
from svglib.svglib import svg2rlg
from reportlab.graphics import renderPM
import io


def woff_to_pngdir(woff_file):
    base_file_name = os.path.splitext(woff_file)[0]
    if os.path.exists(base_file_name):
        # 删除非空目录
        shutil.rmtree(base_file_name, ignore_errors=True)

    try:
        os.mkdir(base_file_name)
    except Exception as e:
        print(e)

    # 读取woff文件
    font = TTFont(woff_file)
    charsdict = font.getBestCmap()

    for key, value in charsdict.items():
        # 产生svg
        pen = SVGPathPen(font.getGlyphSet())
        font.getGlyphSet()[value].draw(pen)
        xMin, xMax, yMin, yMax = (
            font[&quot;head&quot;].xMin,
            font[&quot;head&quot;].xMax,
            font[&quot;head&quot;].yMin,
            font[&quot;head&quot;].yMax,
        )
        height = yMax - yMin
        width = xMax - xMin
        # r=width/100
        svg_xml = f'&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;{xMin} {yMin} {width} {height}&quot;&gt;&lt;g transform=&quot;matrix(0.6 0 0 -0.6 {xMin+width*0.2} {yMin+yMax-height*0.2})&quot;&gt;&lt;path stroke = &quot;black&quot; fill = &quot;black&quot; d=&quot;{pen.getCommands()}&quot;/&gt;&lt;/g&gt;&lt;/svg&gt;'

        # 内存png
        drawing = svg2rlg(io.StringIO(svg_xml))

        # 保存识别结果
        renderPM.drawToFile(drawing, rf&quot;{key}-{value}.png&quot;)


if __name__ == &quot;__main__&quot;:
    woff_to_pngdir(&quot;abc.woff&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生成svg图片"><a class="header" href="#生成svg图片">生成svg图片</a></h1>
<pre><code class="language-python">
import sys
import os
from PIL import Image


def convertPixel(r, g, b, a=1):
    color = &quot;#%02X%02X%02X&quot; % (r, g, b)
    opacity = a
    return (color, opacity)


for r in sys.argv[1:]:
    root, ext = os.path.splitext(r)

    image = Image.open(r)
    mode = image.mode
    pixels = image.load()
    width, height = image.size

    print(image.mode)

    if &quot;RGB&quot; in mode:
        output = f'&lt;svg width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;'

        for r in range(height):
            for c in range(width):
                color, opacity = convertPixel(*pixels[c, r])
                output += f'&lt;rect x=&quot;{c}&quot; y=&quot;{r}&quot; width=&quot;1&quot; height=&quot;1&quot; fill=&quot;{color}&quot; fill-opacity=&quot;{opacity}&quot;/&gt;'

        output += &quot;&lt;/svg&gt;&quot;

        with open(root + &quot;.svg&quot;, &quot;w&quot;) as f:
            f.write(output)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">c++</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lz78算法"><a class="header" href="#lz78算法">LZ78算法</a></h1>
<h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<pre><code class="language-c++">#include &quot;Dictionary.h&quot;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;  

int main(int argc, char* argv[])
{
    std::ifstream file(&quot;test.txt&quot;);
    std::ofstream out(&quot;test2.lzw&quot;);
    char ch;
    std::string perfix = &quot;&quot;;
    Dictionary dict;

    while (!file.eof())
    {
        file&gt;&gt;ch;
        if (dict.is_exist(perfix+ch))
        {
            perfix += ch;
        }
        else
        {
            out&lt;&lt;dict.get_mask(perfix)&lt;&lt;ch;
            dict.add(perfix+ch);
            perfix = &quot;&quot;;
        }
    }

    if (perfix != &quot;&quot;)
    {
        out&lt;&lt;dict.get_mask(perfix);
    }

    file.close();
    out.close();
    std::cout&lt;&lt;&quot;conpress success!&quot;&lt;&lt;std::endl;
    return 0;
}


</code></pre>
<h2 id="解压"><a class="header" href="#解压">解压</a></h2>
<pre><code class="language-c++">#include &lt;fstream&gt;
#include &lt;string&gt;
#include &quot;Dictionary.h&quot;


int main(int argc, char* argv[])
{
    std::ifstream file(&quot;test2.lzw&quot;);
    std::ofstream out(&quot;test2.txt&quot;);
    std::string prefix = &quot;&quot;;
    char ch;
    long mask;
    Dictionary dict;
    
    while (!file.eof())
    {
        file&gt;&gt;mask&gt;&gt;ch;
        std::string temp = dict.get_perfix(mask)+ch;
        out&lt;&lt;temp;
        dict.add(temp);
    }

    std::cout&lt;&lt;&quot;decompress success&quot;&lt;&lt;std::endl;
    return 0;
}
</code></pre>
<h2 id="字典实现"><a class="header" href="#字典实现">字典实现</a></h2>
<pre><code class="language-c++">#include &lt;map&gt;
#include &lt;string&gt;

class Dictionary  
{
public:
    std::string get_perfix(long mask);
    long get_mask(const std::string perfix);
    bool is_exist(const std::string member);
    void add(const std::string word);
    Dictionary();
    virtual ~Dictionary();

private:
    long index;
    std::map&lt;std::string, long&gt; store; 
};

Dictionary::Dictionary()
{
    index = 0;
}

Dictionary::~Dictionary()
{
}

void Dictionary::add(const std::string word)
{
    this-&gt;store[word] = ++index;
}

bool Dictionary::is_exist(const std::string member)
{
    std::map&lt;std::string, long&gt;::iterator pos;
    pos = this-&gt;store.find(member);
    if (pos != store.end())
    {
        return true;
    }
    else
    {
        return false;
    }
}

long Dictionary::get_mask(const std::string perfix)
{
    if ((index==0) || (perfix==&quot;&quot;))
    {
        return 0;
    }
    else
    {
            std::map&lt;std::string, long&gt;::iterator pos;
            pos = this-&gt;store.find(perfix);
            if (pos != store.end())
            {
                return pos-&gt;second;
            }
            else
            {
                return 0;
            }
    }
}

std::string Dictionary::get_perfix(long mask)
{
    if (mask != 0)
    {
        std::map&lt;std::string, long&gt;::iterator pos;
        for (pos = this-&gt;store.begin(); pos != store.end(); pos++)
        {
            if (pos-&gt;second == mask)
            {
                return pos-&gt;first;
            }
        }
    }
    return &quot;&quot;;
}
</code></pre>
<h2 id="检验比较"><a class="header" href="#检验比较">检验比较</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main(int argc, char* argv[])
{
    std::ifstream file_first(&quot;test.txt&quot;);
    std::ifstream file_second(&quot;test2.txt&quot;);

    char ch_first;
    char ch_second;

    while (!file_first.eof() &amp;&amp; !file_second.eof())
    {
        file_first&gt;&gt;ch_first;
        file_second&gt;&gt;ch_second;
        if (ch_first != ch_second)
        {
            std::cout&lt;&lt;&quot;do not complete &quot;&lt;&lt;std::endl;
            return 0;
        }
    }
    std::cout&lt;&lt;&quot;complete&quot;&lt;&lt;std::endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="换位法生成全排列"><a class="header" href="#换位法生成全排列">换位法生成全排列</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;fstream&gt;
#include &lt;stdio.h&gt;

const int array_length = 30;

template &lt;typename T&gt;
int get_max_active(const int* ptr_array,
           int length,
           const T&amp; ptr_array_flag)
{
  int max_index = -1;
  for (int i=0; i&lt;length; i++)
    {
      int j;
      if (ptr_array_flag[i])//from left to right
    {
      j = i+1;
      while (j&lt;length)
        {
          if (ptr_array[i] &gt; ptr_array[j++])// has active state data
        {
          if ((max_index == -1) || (ptr_array[max_index] &lt; ptr_array[i]))
            {
              max_index = i;
            }
          break;
        }
        }
    }
      else// from right to left
    {
      j = i-1;
      while (j &gt;= 0)
        {
          if (ptr_array[i] &gt; ptr_array[j--])
        {
          if ((max_index == -1) || (ptr_array[max_index] &lt; ptr_array[i]))
            {
              max_index = i;
            }
          
          break;
        }
        }// end of while
    }// end of if
    }// end of for
  return max_index;
}

template &lt;typename T&gt;
void gen_arrange(int* ptr_array, int length, T&amp; ptr_array_flag)
{
  std::ofstream out_file(&quot;arrange.txt&quot;);
  int max_index = -1;// -1 is no active data
  int max_data;
  while ( (max_index = get_max_active(ptr_array, length, ptr_array_flag)) != -1)
    {
      for (int k=0; k&lt;length; k++)
    {
      out_file&lt;&lt;ptr_array[k]&lt;&lt;&quot;|&quot;;
    }      
                  
      out_file&lt;&lt;std::endl;
      
      max_data = ptr_array[max_index];

      //change heig
      if (ptr_array_flag[max_index])//from left to right
    {
      //change flag
      if (!ptr_array_flag[max_index+1])
        {
          ptr_array_flag.flip(max_index+1);
          ptr_array_flag.flip(max_index);
        }

        //change value      
      ptr_array[max_index]   += ptr_array[max_index+1];
      ptr_array[max_index+1] = ptr_array[max_index] - ptr_array[max_index+1];
      ptr_array[max_index]   -= ptr_array[max_index+1];
    }
      else//from right to left
    {      
      //change flag
      if (ptr_array_flag[max_index+1])
        {
          ptr_array_flag.flip(max_index);
          ptr_array_flag.flip(max_index+1);
        }
      //change value
      ptr_array[max_index]   += ptr_array[max_index-1];
      ptr_array[max_index-1] = ptr_array[max_index] - ptr_array[max_index-1];
      ptr_array[max_index]   -= ptr_array[max_index-1];
    }//end of if

      //change better than max_data flag
      for (int j=0; j&lt;length; j++)
    {
      if (ptr_array[j] &gt; max_data)
        {          
          ptr_array_flag.flip(j);//change flag          
        }
    }
    }//end of while

  for (int k=0; k&lt;length; k++)
    {
      out_file&lt;&lt;ptr_array[k]&lt;&lt;&quot;|&quot;;
    }
  out_file&lt;&lt;std::endl;
}


int main(int argc, char* argv[])
{
  int array[array_length];

  //init array data
  for (int i=0; i&lt;array_length; i++)
    {
      array[i] = i+1;
    }

  std::string str_flag;
  //init array flag from right to left
  for (int i=0; i&lt;array_length; i++)
    {
      str_flag +='0';
    }

  std::bitset&lt;array_length&gt; array_flag(str_flag);
  gen_arrange(array, array_length, array_flag);  
  return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="利用费根鲍姆迭代模型产生随机数"><a class="header" href="#利用费根鲍姆迭代模型产生随机数">利用费根鲍姆迭代模型产生随机数</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
int main(int argc, char* argv[])
{
    ofstream of(&quot;rand.txt&quot;);
    double init_seed = 0.990976548;
    double last = init_seed;
    for (int i=0; i&lt;1000; i++)
    {
        last = 4*last*(1-last);//Xn+1 = CXn(1-Xn)其中c=4
        of&lt;&lt;last&lt;&lt;endl;
    }
    cout&lt;&lt;&quot;create over&quot;&lt;&lt;endl;
    of.close();
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="memcached-1"><a class="header" href="#memcached-1">memcached</a></h1>
<hr />
<h2 id="官方文档"><a class="header" href="#官方文档"><a href="https://github.com/memcached/memcached/wiki/">官方文档</a></a></h2>
<hr />
<p><img src="webp/memcached/memcache_logo.webp" alt="软件logo" /></p>
<h3 id="安装运行"><a class="header" href="#安装运行">安装运行</a></h3>
<hr />
<pre><code class="language-sh">#memcached依赖libevent
brew install memcached
brew services start memcached
</code></pre>
<blockquote>
<p>启动选项：</p>
</blockquote>
<ol>
<li>-d是启动一个守护进程；</li>
<li>-m是分配给Memcache使用的内存数量，单位是MB；</li>
<li>-u是运行Memcache的用户；</li>
<li>-l是监听的服务器IP地址，可以有多个地址；</li>
<li>-p是设置Memcache监听的端口,默认11211；</li>
<li>-c是最大运行的并发连接数，默认是1024；</li>
<li>-P是设置保存Memcache的pid文件。</li>
<li>-h是显示帮助</li>
</ol>
<h3 id="使用"><a class="header" href="#使用">使用</a></h3>
<hr />
<pre><code class="language-sh">telnet localhost 11211
</code></pre>
<h3 id="存储命令"><a class="header" href="#存储命令">存储命令</a></h3>
<hr />
<pre><code class="language-sh">command &lt;key&gt; &lt;flags&gt; &lt;expiration time&gt; &lt;bytes&gt;
&lt;value&gt;
</code></pre>
<blockquote>
<p>参数说明如下：</p>
</blockquote>
<ol>
<li>command set|add|replace|append|prepend</li>
<li>key     key 用于查找缓存值</li>
<li>flags     可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息</li>
<li>expiration time     在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）</li>
<li>bytes     在缓存中存储的字节数</li>
<li>value     存储的值（始终位于第二行）</li>
</ol>
<h3 id="expiration-time设置影响"><a class="header" href="#expiration-time设置影响">expiration time设置影响</a></h3>
<ol>
<li>
<p><strong>缓存雪崩:短时间内大量键超时失效</strong></p>
</li>
<li>
<p><strong>缓存击穿:缓存中没有键值</strong></p>
<ol>
<li>确实不存在:用布隆过滤器优化</li>
<li>键超时:设置永不超时,受最大内存限制</li>
</ol>
</li>
</ol>
<p><img src="webp/memcached/set_example.webp" alt="示例图" /></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">命令</th><th style="text-align: center">功能</th></tr></thead><tbody>
<tr><td style="text-align: center">set</td><td style="text-align: center">没有则新增,有则更新,相当于add+replace</td></tr>
<tr><td style="text-align: center">add</td><td style="text-align: center">新增键值,有则不操作</td></tr>
<tr><td style="text-align: center">replace</td><td style="text-align: center">替换存在键值,没有则不操作</td></tr>
<tr><td style="text-align: center">append</td><td style="text-align: center">向存在键值后面追加数据,不存在则不操作</td></tr>
<tr><td style="text-align: center">prepend</td><td style="text-align: center">向存在键值前面追加数据,不存在则不操作</td></tr>
</tbody></table>
</div>
<h3 id="查找命令"><a class="header" href="#查找命令">查找命令</a></h3>
<hr />
<pre><code class="language-sh">#多个key用空格隔开
command key key key
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">命令</th><th style="text-align: center">功能</th></tr></thead><tbody>
<tr><td style="text-align: center">get</td><td style="text-align: center">如果不存在,则返回空</td></tr>
<tr><td style="text-align: center">gets</td><td style="text-align: center">返回值增加CAS令牌</td></tr>
</tbody></table>
</div>
<h3 id="删除命令"><a class="header" href="#删除命令">删除命令</a></h3>
<hr />
<pre><code class="language-sh">delete key
</code></pre>
<h3 id="增加减少命令"><a class="header" href="#增加减少命令">增加减少命令</a></h3>
<hr />
<pre><code class="language-sh">#decr incr
command key value
</code></pre>
<blockquote>
<p>已存在的 key(键) 的数字值进行自增或自减操作</p>
</blockquote>
<h3 id="清空命令"><a class="header" href="#清空命令">清空命令</a></h3>
<hr />
<pre><code class="language-sh">flush_all [time]
</code></pre>
<blockquote>
<p>可选参数 time，用于在指定的时间后执行清理缓存操作。</p>
</blockquote>
<h3 id="源代码proto_proxyc部分代码"><a class="header" href="#源代码proto_proxyc部分代码">源代码proto_proxy.c部分代码</a></h3>
<hr />
<pre><code class="language-c">static int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {
    ...
    case 4:
            if (strncmp(cm, &quot;gets&quot;, 4) == 0) {
                cmd = CMD_GETS;
                type = CMD_TYPE_GET;
                token_max = 2; // don't chew through multigets.
                ret = _process_request_simple(pr, 2);
            } else if (strncmp(cm, &quot;incr&quot;, 4) == 0) {
                cmd = CMD_INCR;
                ret = _process_request_simple(pr, 4);
            } else if (strncmp(cm, &quot;decr&quot;, 4) == 0) {
                cmd = CMD_DECR;
                ret = _process_request_simple(pr, 4);
            } else if (strncmp(cm, &quot;gats&quot;, 4) == 0) {
                cmd = CMD_GATS;
                type = CMD_TYPE_GET;
                ret = _process_request_gat(pr);
            } else if (strncmp(cm, &quot;quit&quot;, 4) == 0) {
                cmd = CMD_QUIT;
            }
            break;
        case 5:
            if (strncmp(cm, &quot;touch&quot;, 5) == 0) {
                cmd = CMD_TOUCH;
                ret = _process_request_simple(pr, 4);
            } else if (strncmp(cm, &quot;stats&quot;, 5) == 0) {
                cmd = CMD_STATS;
                // Don't process a key; fetch via arguments.
                _process_tokenize(pr, token_max);
            } else if (strncmp(cm, &quot;watch&quot;, 5) == 0) {
                cmd = CMD_WATCH;
                _process_tokenize(pr, token_max);
            }
            break;
        case 6:
            if (strncmp(cm, &quot;delete&quot;, 6) == 0) {
                cmd = CMD_DELETE;
                ret = _process_request_simple(pr, 4);
            } else if (strncmp(cm, &quot;append&quot;, 6) == 0) {
                cmd = CMD_APPEND;
                ret = _process_request_storage(pr, token_max);
            }
            break;
        case 7:
            if (strncmp(cm, &quot;replace&quot;, 7) == 0) {
                cmd = CMD_REPLACE;
                ret = _process_request_storage(pr, token_max);
            } else if (strncmp(cm, &quot;prepend&quot;, 7) == 0) {
                cmd = CMD_PREPEND;
                ret = _process_request_storage(pr, token_max);
            } else if (strncmp(cm, &quot;version&quot;, 7) == 0) {
                cmd = CMD_VERSION;
                _process_tokenize(pr, token_max);
            }
            break;
    ...
}
</code></pre>
<h3 id="集群"><a class="header" href="#集群">集群</a></h3>
<hr />
<ol>
<li>
<p>多个节点,依赖代码库配合实现集群
<img src="webp/memcached/memcache_nodes.webp" alt="集群图" /></p>
</li>
<li>
<p>减少扩容缩小节点影响，代码算法优化
<img src="webp/memcached/memcache_hash.webp" alt="哈希图" /></p>
</li>
</ol>
<h3 id="内部结构"><a class="header" href="#内部结构">内部结构</a></h3>
<hr />
<p><img src="webp/memcached/memcache_slab.webp" alt="内部图" /></p>
<blockquote>
<p><em>Slab Allocator解决了<strong>内存碎片</strong>,但由于分配的是特定长度的内存，因此<strong>浪费内存</strong></em></p>
</blockquote>
<h3 id="通讯协议"><a class="header" href="#通讯协议">通讯协议</a></h3>
<hr />
<ul>
<li>文本协议</li>
</ul>
<blockquote>
<p><strong>直接用telnet,nc等工具都可以发送,\r\n表示换行,[]表示可选,会影响回包内容</strong></p>
</blockquote>
<pre><code class="language-sh">#存储类命令(set,add等)
&lt;command_name&gt; &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt;\r\n
#存储内容
&lt;data_block&gt;\r\n
#服务端回包,STORED成功,NOT_STORED失败
STORED\r\n
NOT_STORED\r\n
</code></pre>
<pre><code class="language-sh">#删除
delete &lt;key&gt; [&lt;time&gt;] [noreply]\r\n
#服务端回包
DELETED\r\n ：表明执行成功
NOT_FOUND\r\n ：表明这个键没有找到
</code></pre>
<pre><code class="language-sh">#自增减命令(incr,decr)
&lt;command_name&gt; &lt;key&gt; &lt;value&gt; [noreply]\r\n
#服务端回包
NOT_FOUND\r\n ：没有找到数据项
&lt;value&gt;\r\n ：数据项的新数值，自增或自减以后的值
</code></pre>
<ul>
<li>二进制协议</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="redis-1"><a class="header" href="#redis-1">redis</a></h1>
<hr />
<h3 id="安装运行-1"><a class="header" href="#安装运行-1">安装运行</a></h3>
<hr />
<pre><code class="language-sh">brew install redis
brew services start redis
</code></pre>
<hr />
<pre><code class="language-sh">wget https://download.redis.io/redis-stable.tar.gz
tar -xzvf redis-stable.tar.gz
cd redis-stable
make

# If the compile succeeds, you'll find several Redis binaries in the src directory, including:
# redis-server: the Redis Server itself
# redis-cli is the command line interface utility to talk with Redis.
# To install these binaries in /usr/local/bin, run:
make install
</code></pre>
<h3 id="自带客户端"><a class="header" href="#自带客户端">自带客户端</a></h3>
<hr />
<pre><code class="language-sh">#Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]
#Examples:
#  cat /etc/passwd | redis-cli -x set mypasswd
#  redis-cli get mypasswd
#  redis-cli -r 100 lpush mylist x
#  redis-cli -r 100 -i 1 info | grep used_memory_human:
#  redis-cli --quoted-input set '&quot;null-\x00-separated&quot;' value
#  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3
#  redis-cli --scan --pattern '*:12345*'
#When no command is given, redis-cli starts in interactive mode
#redis-cli的命令提示非常有帮助,比其他终端好用的多
redis-cli
</code></pre>
<h3 id="redisinsight是redis官方出品的可视化管理工具可用于设计开发优化你的redis应用"><a class="header" href="#redisinsight是redis官方出品的可视化管理工具可用于设计开发优化你的redis应用">RedisInsight是Redis官方出品的可视化管理工具，可用于设计、开发、优化你的Redis应用</a></h3>
<h3 id="redis4引入自动内存碎片整理"><a class="header" href="#redis4引入自动内存碎片整理">redis4引入自动内存碎片整理</a></h3>
<hr />
<pre><code class="language-sh"># 开启自动内存碎片整理(总开关),默认no
activedefrag yes
# 当碎片达到 100mb 时，开启内存碎片整理
active-defrag-ignore-bytes 100mb
# 当碎片超过 10% 时，开启内存碎片整理
active-defrag-threshold-lower 10
# 内存碎片超过 100%，则尽最大努力整理
active-defrag-threshold-upper 100
# 内存自动整理占用资源最小百分比
active-defrag-cycle-min 1
# 内存自动整理占用资源最大百分比
active-defrag-cycle-max 25
</code></pre>
<blockquote>
<p><strong>Notice:开启后,可能特定时间影响redis响应速度</strong></p>
</blockquote>
<h3 id="redis5带来了stream"><a class="header" href="#redis5带来了stream">redis5带来了Stream</a></h3>
<hr />
<blockquote>
<p>Redis对消息队列（MQ，Message Queue）的完善实现
<img src="webp/redis/redis_stream.webp" alt="redis_stream" /></p>
</blockquote>
<h3 id="redis6增加了多线程"><a class="header" href="#redis6增加了多线程">redis6增加了多线程</a></h3>
<hr />
<pre><code class="language-sh"># io-threads 4
# Setting io-threads to 1 will just use the main thread as usual.
# io-threads-do-reads no
# Note that Gopher is not currently supported when 'io-threads-do-reads'
</code></pre>
<blockquote>
<p>Redis实例占用相当大的CPU耗时的时候才建议采用,否则使用多线程没有意义。基本上我们都是<strong>观众</strong>!!!</p>
</blockquote>
<h3 id="常用功能"><a class="header" href="#常用功能">常用功能</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>功能</th><th>命令</th><th>备注</th></tr></thead><tbody>
<tr><td>String</td><td>set,get,setnx,mget,mset,msetnx</td><td>最大512MB,可存任何数据</td></tr>
<tr><td>List</td><td>lpush,lpop,rpush,rpop,blpop,brpop,llen,lpushx,lrem,lrange</td><td>超过40亿个元素</td></tr>
<tr><td>Hash</td><td>hget,hset,hdel,hgetall,hkeys,hvals,hlen,hmset,hmget</td><td>超过40亿个元素</td></tr>
<tr><td>Set</td><td>sadd,spop,srem,scard,smembers,sismember,sdiff,sinter,sunion</td><td>超过40亿个成员</td></tr>
<tr><td>SortedSet</td><td>zadd,zrem,zcard,zcount,zscore,zrange</td><td>超过40亿个成员</td></tr>
<tr><td>Pub/Sub</td><td>subscribe,publish,unsubscribe</td><td>消息不会保存,广播型</td></tr>
<tr><td>Stream</td><td>xadd,xdel,xlen,xread,xgroup,xreadgroup,xinfo,xtrim</td><td>消息会保存,每个消息都是一组键值对,同组竞争,组间广播</td></tr>
<tr><td>Key</td><td>del,keys,type,object,ttl,persist,randomkey,rename</td><td>针对键操作</td></tr>
<tr><td>Pipelining</td><td>优点:减少RTT(往返时间),多次网络IO,系统调用的消耗</td><td>缺点:独占链接,占用redis内存缓存命令结果</td></tr>
<tr><td>Auth</td><td>auth password</td><td>验证密码</td></tr>
<tr><td>HyperLogLog</td><td>pfadd,pfcount</td><td>基数估计</td></tr>
</tbody></table>
</div>
<p><img src="webp/redis/redis_string.webp" alt="string" />
<img src="webp/redis/redis_list.webp" alt="list" />
<img src="webp/redis/redis_hash.webp" alt="hash" />
<img src="webp/redis/redis_set.webp" alt="set" />
<img src="webp/redis/redis_sortedSet.webp" alt="sortedSet" />
<img src="webp/redis/redis_pubsub.webp" alt="pub/sub" />
<img src="webp/redis/redis_key.webp" alt="key" />
<img src="webp/redis/redis_hl.webp" alt="hl" /></p>
<ul>
<li>xreadgroup和xack配合使用</li>
</ul>
<pre><code class="language-c">WHILE true
    entries = XREADGROUP $GroupName $ConsumerName BLOCK 2000 COUNT 10 STREAMS mystream &gt;
    if entries == nil
        puts &quot;Timeout... try again&quot;
        CONTINUE
    end

    FOREACH entries AS stream_entries
        FOREACH stream_entries as message
            process_message(message.id,message.fields)

            # ACK the message as processed
            XACK mystream $GroupName message.id
        END
    END
END
</code></pre>
<h3 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h3>
<hr />
<ol>
<li>
<p><strong>缓存雪崩:短时间内大量键超时失效</strong></p>
</li>
<li>
<p><strong>缓存击穿:缓存中没有键值</strong></p>
<ol>
<li>确实不存在:用布隆过滤器优化</li>
<li>键超时:设置永不超时,受最大内存限制</li>
</ol>
</li>
</ol>
<h3 id="批量删除"><a class="header" href="#批量删除">批量删除</a></h3>
<hr />
<pre><code class="language-lua">--批量删除msg开始的键值
EVAL &quot;return redis.call('del', unpack(redis.call('keys', ARGV[1])))&quot; 0 'msg*'
</code></pre>
<h3 id="redis通讯协议-resp"><a class="header" href="#redis通讯协议-resp">redis通讯协议-RESP</a></h3>
<hr />
<ul>
<li>请求协议
<ol>
<li>*后面数量表示存在几个$</li>
<li>$后面数量表示字符串的长度</li>
<li>每项用\r\n分隔</li>
</ol>
</li>
</ul>
<pre><code class="language-sh">*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n
</code></pre>
<blockquote>
<p><strong>pipeline实现就是连接发送命令,不用每个都等</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="mysql"><a class="header" href="#mysql">mysql</a></h1>
<hr />
<h3 id="sql"><a class="header" href="#sql">SQL</a></h3>
<ul>
<li>
<p>mysql没有完全实现<a href="https://datacadamia.com/data/type/relation/sql/ansi">sql标准</a></p>
</li>
<li>
<p>不区分大小写,一般内置关键词,函数等采用大写,用户表,列,参数采用小写</p>
</li>
<li>
<p>用分号作为结束语句标识,允许一行多条语句,一条语句多行.</p>
</li>
<li>
<p>有不同模式,建议采用strict mode</p>
</li>
<li>
<p>默认autocommit,除非显式取消</p>
</li>
<li>
<p>注释</p>
<ul>
<li>单行: 以#开头,到行结束</li>
<li>单行: 以-- 开头,到行结束</li>
<li>多行: /<em>开头，</em>/结束,c风格</li>
</ul>
</li>
<li>
<p>字符集(Character)与校对规则(Collation)</p>
<ul>
<li>字符集都对应着一个默认的校对规则,也可以对应多个规则</li>
<li>变量character_set_server记录服务器默认值,mysql8.0默认是utf8mb4(可储各种表情符号,最长4字节)</li>
<li>每个库/表/字段可单独指定,库不指定则用服务器,表不指定则用库,字段不指定则用表</li>
<li>character_set_client服务器认为客户端发送过来的sql语句的编码</li>
<li>character_set_conneciton执行sql内部编码,所以服务器把客户端发送的sql从character_set_client转为character_set_conneciton</li>
<li>character_set_results 返回结果集</li>
<li>客户端用连接参数一次性指定这三个值character_set_client, character_set_results, character_set_connection</li>
</ul>
</li>
<li>
<p>自带4个数据库</p>
<ul>
<li>information_schema 保存所有数据库/表/列/索引/权限等信息</li>
<li>performance_schema 收集数据库服务器性能参数，资源消息，资源等待</li>
<li>sys 存储来自performance_schema,简化说明，易于DBA理解</li>
<li>mysql 存储库用户，权限，关键字等mysql自已需要必要信息</li>
</ul>
</li>
<li>
<p>程序表</p>
<p>| 名称 | 作用 |
| -- | -- |
| mysqld | 服务器 |
| mysqld_safe | 用来启动mysqld的脚本 |
| mysql.server | 系统启动脚本,调用mysqld_safe脚本 |
| mysqld_multi | 允许同时多个mysqld进程 |
| mysql | 客户端 |
| mysqladmin | 客户端管理数据库 |
| mysqldump | 客户端导出数据 |
| mysqlimport | 客户端导入数据 |</p>
</li>
<li>
<p>联表</p>
</li>
</ul>
<pre><code class="language-sql">...
joined_table: {
table_reference {[INNER | CROSS] JOIN | STRAIGHT_JOIN} table_factor [join_specification]
 | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_specification
 | table_reference NATURAL [INNER | {LEFT|RIGHT} [OUTER]] JOIN table_factor
}
join_specification: {
 ON search_condition
 | USING (join_column_list) }
 ...
</code></pre>
<ul>
<li>
<p>JOIN, CROSS JOIN, and INNER JOIN等价,和sql标准不相同</p>
<pre><code class="language-c">// 简化翻译sql逻辑
// select tbl1.col1, tbl2.col2 from tbl1 inner join tbl2 using(col3) where tbl1.col1 in (5, 6);
// 内联没有指明驱动表,优化器会根据过滤行数少作为驱动表,这里假设选择tbl1作为驱动表
// STRAIGHT_JOIN用来指定哪个表作为驱动表,示例如下:
// select tbl1.col1, tbl2.col2 from tbl1 STRAIGHT_JOIN tbl2 using(col3) where tbl1.col1 in (5, 6);
outer_iter = iterator over tbl1 where col1 in (5, 6)
outer_row = outer_iter.next
while outer_row
    inner_iter = iterator over tbl2 where col3 = outer_row.col3
    inner_row = inner_iter.next
    while inner_row
        output [ outer_row.col1, inner_row.col2]
        inner_row = inner_iter.next
    end
    outer_row = outer_iter.next
end
</code></pre>
</li>
<li>
<p>LEFT, RIGHT [OUTER] JOIN,外连关键词(outer)可省略,写不写都是一样功能</p>
<pre><code class="language-c">// 简化翻译sql逻辑
// select tbl1.col1, tbl2.col2 from tbl1 left outer join tbl2 using(col3) where tbl1.col1 in (5, 6); 
// left,right表明了哪个表作为驱动表
outer_iter = iterator over tbl1 where col1 in (5, 6)
outer_row = outer_iter.next
while outer_row
    inner_iter = iterator over tbl2 where col3 = outer_row.col3
    inner_row = inner_iter.next
    if inner_row
        while inner_row
            output [ outer_row.col1, inner_row.col2]
            inner_row = inner_iter.next
        end
    else
        output [ outer_row.col1, null]
    end
        outer_row = outer_iter.next
end
</code></pre>
</li>
<li>
<p>FULL OUTER JOIN暂不支持</p>
</li>
<li>
<p>NATURAL表示join_specification采用USING(join_column_list),不用手动写出来,join_column_list选取两个表都有的列名</p>
</li>
<li>
<p>EXPLAIN/DESCRIBE/DESC 作用一样的</p>
<pre><code class="language-sql">-- 获取表结构/信息
{EXPLAIN | DESCRIBE | DESC}
tbl_name [col_name | wild]

-- 获取执行计划信息
{EXPLAIN | DESCRIBE | DESC}
[explain_type]
{explainable_stmt | FOR CONNECTION connection_id}

-- 获取更详执行计划细信息
{EXPLAIN | DESCRIBE | DESC} ANALYZE [FORMAT = TREE] select_statement
explain_type: {
FORMAT = format_name
}
format_name: {
TRADITIONAL
| JSON
| TREE
}
explainable_stmt: {
SELECT statement
| TABLE statement
| DELETE statement
| INSERT statement
| REPLACE statement
| UPDATE statement
}
</code></pre>
</li>
<li>
<p>help语句</p>
</li>
</ul>
<pre><code class="language-sql">-- 显示select语句语法,较便利
HELP 'select'
</code></pre>
<h3 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h3>
<hr />
<ul>
<li>
<p>数字,默认是有符号(SIGNED),无符号(UNSIGNED)要特别指定</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>字节数</th></tr></thead><tbody>
<tr><td>TINYINT</td><td>1</td></tr>
<tr><td>SMALLINT</td><td>2</td></tr>
<tr><td>MEDIUMINT</td><td>3</td></tr>
<tr><td>INT</td><td>4</td></tr>
<tr><td>BIGINT</td><td>8</td></tr>
<tr><td>FLOAT</td><td>4</td></tr>
<tr><td>DOUBLE</td><td>8</td></tr>
<tr><td>DECIMAL</td><td>二进制存储</td></tr>
</tbody></table>
</div>
<ul>
<li>其他有一些别名</li>
<li>All arithmetic is done using signed BIGINT or DOUBLE values</li>
</ul>
</li>
<li>
<p>时间</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>范围</th><th>零值</th><th>说明</th></tr></thead><tbody>
<tr><td>DATE</td><td>'1000-01-01'到'9999-12-31'</td><td>'0000-00-00'</td><td>年月日</td></tr>
<tr><td>TIME</td><td>'-838:59:59.000000'到'838:59:59.000000'</td><td>'00:00:00'</td><td>时分秒</td></tr>
<tr><td>DATETIME</td><td>'1000-01-01 00:00:00'到'9999-12-31 23:59:59'</td><td>0000-00-00 00:00:00</td><td>年月日时分秒</td></tr>
<tr><td>TIMESTAMP</td><td>'1970-01-01 00:00:01.000000'到'2038-01-19 03:14:07.999999'</td><td>0000-00-00 00:00:00</td><td>时间戳</td></tr>
<tr><td>YEAR</td><td>别用</td><td>'0000'</td><td>别用,有坑</td></tr>
</tbody></table>
</div>
<ul>
<li>TIME,DATETIME,TIMESTAMP默认精确到秒,增加参数指定精确小数,最多到6位</li>
</ul>
<pre><code class="language-sql">create table mytime (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  --  '00:00:00.000000'
  t TIME(6) not null,
  --   '1000-01-01 00:00:00.00000'
  dt DATETIME(5) not null,
  ts TIMESTAMP(4) not null,
  t2 TIME(3) not null,
  dt2 DATETIME(2) not null,
  ts2 TIMESTAMP(1) not null
);
</code></pre>
<ul>
<li>DATETIME,TIMESTAMP都可以用DEFAULT CURRENT_TIMESTAMP指定默认值</li>
</ul>
</li>
<li>
<p>字符串</p>
<ul>
<li>
<p>char</p>
<ul>
<li>CHAR(len),VARCHAR(len)最多储存len个char字符,储存占用字节由字符集处理</li>
<li>char固定大小,varchar变化大小,指消费储存占用字节</li>
<li>varchar默认去尾空格空白</li>
</ul>
</li>
<li>
<p>binary</p>
<ul>
<li>BINARY(len),VARCHAR(len)最多储存len个字节,字符集转化字符后字节</li>
</ul>
</li>
<li>
<p>短字符串
| 字符存储 | 字节存储 |
| -- | -- |
| char | binary |
| varchar | varbinary |</p>
</li>
<li>
<p>长字符串
| text(字符存储,类似char) | blob(字节存储,类似binary) |
| -- | -- |
| tinytext | tinyblob |
| mediumtext | mediumblob |
| text | blob |
| longtext | longblob |</p>
</li>
</ul>
</li>
<li>
<p>json</p>
<pre><code class="language-sql">create table js(v json);
insert into js(v) values('[10, 20, 30]');
insert into js(v) values('{&quot;a&quot;:10}');
</code></pre>
</li>
</ul>
<h3 id="分区表"><a class="header" href="#分区表">分区表</a></h3>
<ul>
<li>
<p>分类类型</p>
<ul>
<li>RANGE,分区必须指定范围</li>
</ul>
<pre><code class="language-sql">CREATE TABLE employees (
  id INT NOT NULL,
  fname VARCHAR(30),
  lname VARCHAR(30),
  hired DATE NOT NULL DEFAULT '1970-01-01',
  separated DATE NOT NULL DEFAULT '9999-12-31',
  job_code INT NOT NULL,
  store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
  PARTITION p0
  VALUES
    LESS THAN (6),
    PARTITION p1
  VALUES
    LESS THAN (11),
    PARTITION p2
  VALUES
    LESS THAN (16),
    PARTITION p3
  VALUES
    LESS THAN MAXVALUE
);
</code></pre>
<ul>
<li>LIST,分区必须指定集合,每条记录只能属于其中一个集合</li>
</ul>
<pre><code class="language-sql">CREATE TABLE person (
  id INT NOT NULL,
  fname VARCHAR(30),
  lname VARCHAR(30),
  hired DATE NOT NULL DEFAULT '1970-01-01',
  separated DATE NOT NULL DEFAULT '9999-12-31',
  job_code INT,
  store_id INT
) PARTITION BY LIST(store_id) (
  PARTITION pNorth
  VALUES
    IN (3, 5, 6, 9, 17),
    PARTITION pEast
  VALUES
    IN (1, 2, 10, 11, 19, 20),
    PARTITION pWest
  VALUES
    IN (4, 12, 13, 14, 18),
    PARTITION pCentral
  VALUES
    IN (7, 8, 15, 16)
);
</code></pre>
<ul>
<li>HASH,注意hash分布,造成热点分区</li>
</ul>
<pre><code class="language-sql">CREATE TABLE worker (
  id INT NOT NULL,
  fname VARCHAR(30),
  lname VARCHAR(30),
  hired DATE NOT NULL DEFAULT '1970-01-01',
  separated DATE NOT NULL DEFAULT '9999-12-31',
  job_code INT,
  store_id INT
) PARTITION BY [LINEAR] HASH(store_id) PARTITIONS 4;
-- LINEAR 带上则指定hash算法
</code></pre>
<ul>
<li>KEY,隐式hash,服务器采用hash(key)实现,可任意类型</li>
</ul>
<pre><code class="language-sql">CREATE TABLE tm1 (s1 CHAR(32) PRIMARY KEY) PARTITION BY KEY(s1) PARTITIONS 10;
</code></pre>
</li>
<li>
<p>分区pruning</p>
</li>
</ul>
<pre><code class="language-sql">#  where子句能够转化为下面两种,optimizer优化器就能选定分区,省去不必要查找
partition_column = constant
partition_column IN (constant1, constant2, ..., constantN)

# select update delete 都需要注意
# insert 只会影响一个分区,不必考虑分区修剪
</code></pre>
<ul>
<li>
<p>Subpartitioning 子分区</p>
</li>
<li>
<p>select语法</p>
</li>
</ul>
<pre><code class="language-sql">SELECT
 [ALL | DISTINCT | DISTINCTROW ]
 [HIGH_PRIORITY]
 [STRAIGHT_JOIN]
 [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
 [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
select_expr [, select_expr] ...
 [into_option]
 [FROM table_references
 [PARTITION partition_list]]
 [WHERE where_condition]
 [GROUP BY {col_name | expr | position}, ... [WITH ROLLUP]]
 [HAVING where_condition]
 [WINDOW window_name AS (window_spec)
 [, window_name AS (window_spec)] ...]
 [ORDER BY {col_name | expr | position}
 [ASC | DESC], ... [WITH ROLLUP]]
 [LIMIT {[offset,] row_count | row_count OFFSET offset}]
 [into_option]
 [FOR {UPDATE | SHARE}
 [OF tbl_name [, tbl_name] ...]
 [NOWAIT | SKIP LOCKED]
 | LOCK IN SHARE MODE]
 [into_option]
into_option: {
 INTO OUTFILE 'file_name'
 [CHARACTER SET charset_name]
export_options
 | INTO DUMPFILE 'file_name'
 | INTO var_name [, var_name] ...
}
</code></pre>
<ul>
<li>insert</li>
</ul>
<pre><code class="language-sql"> [INTO] tbl_name
 [PARTITION (partition_name [, partition_name] ...)]
 [(col_name [, col_name] ...)]
 { {VALUES | VALUE} (value_list) [, (value_list)] ... }
 [AS row_alias[(col_alias [, col_alias] ...)]]
 [ON DUPLICATE KEY UPDATE assignment_list]

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name
 [PARTITION (partition_name [, partition_name] ...)]
 [AS row_alias[(col_alias [, col_alias] ...)]]
 SET assignment_list
 [ON DUPLICATE KEY UPDATE assignment_list]

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name
 [PARTITION (partition_name [, partition_name] ...)]
 [(col_name [, col_name] ...)]
 [AS row_alias[(col_alias [, col_alias] ...)]]
 {SELECT ... 
 | TABLE table_name
 | VALUES row_constructor_list
 }
 [ON DUPLICATE KEY UPDATE assignment_list]
</code></pre>
<ul>
<li>
<p>实例解释</p>
<pre><code class="language-sql">-- 每列采用默认值插入
INSERT INTO tbl_name () VALUES();

-- 允许后面出现的列引用前面列值
-- AUTO_INCREMENT在列赋值之后,所以引用此列值会为0
INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);

-- With INSERT ... SELECT插入多行,速度较快,ta表中AUTO_INCREMENT仍然自增,先赋值才执行AUTO_INCREMENT
-- 等价于 INSERT INTO ta SELECT * FROM tb

INSERT INTO ta TABLE tb;

-- 附上DUPLICATE,要求a,b,c至少一个是唯一或主键
-- 当多个是唯一或主键时,任选一个执行
-- UPDATE t1 SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;
INSERT INTO t1 (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;

-- VALUES(colname)用来引用指定列插入值,相当于下面两句结果
-- INSERT INTO t1 (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=3;
-- INSERT INTO t1 (a,b,c) VALUES (4,5,6) ON DUPLICATE KEY UPDATE c=9;
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6)
ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
</code></pre>
</li>
<li>
<p>delete</p>
<ul>
<li>
<p>删除自增字段不会重用</p>
</li>
<li>
<p>单表</p>
</li>
</ul>
<pre><code class="language-sql">DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [[AS] tbl_alias]
[PARTITION (partition_name [, partition_name] ...)]
[WHERE where_condition]
-- 删除顺序,配合limit可用来分段删除
[ORDER BY ...]
-- 限制删除行数,通常用来防止删除影响其他业务,每次只删除部分,多次删除
[LIMIT row_count]
</code></pre>
<ul>
<li>多表</li>
</ul>
<pre><code class="language-sql">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
-- 删除在from之前的表中行
tbl_name[.*] [, tbl_name[.*]] ...
FROM table_references
[WHERE where_condition]

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
-- 删除在from子句中表的行
FROM tbl_name[.*] [, tbl_name[.*]] ...
USING table_references
[WHERE where_condition]
</code></pre>
<ul>
<li>大表删除多行,InnoDB引擎优化</li>
</ul>
<pre><code class="language-sql">-- 把不删除数据插入一张新表中
INSERT INTO t_copy SELECT * FROM t WHERE ... ;
-- 新表,老表互换名字
RENAME TABLE t TO t_old, t_copy TO t;
-- 删除老表,但名字为改名后
DROP TABLE t_old;
</code></pre>
</li>
<li>
<p>replace</p>
</li>
</ul>
<pre><code class="language-sql">REPLACE [LOW_PRIORITY | DELAYED]
 [INTO] tbl_name
 [PARTITION (partition_name [, partition_name] ...)]
 [(col_name [, col_name] ...)]
 { {VALUES | VALUE} (value_list) [, (value_list)] ...
 |
 VALUES row_constructor_list
 }
REPLACE [LOW_PRIORITY | DELAYED]
 [INTO] tbl_name
 [PARTITION (partition_name [, partition_name] ...)]
 SET assignment_list
REPLACE [LOW_PRIORITY | DELAYED]
 [INTO] tbl_name
 [PARTITION (partition_name [, partition_name] ...)]
 [(col_name [, col_name] ...)]
 {SELECT ... | TABLE table_name}
</code></pre>
<ul>
<li>update</li>
</ul>
<pre><code class="language-sql">UPDATE [LOW_PRIORITY] [IGNORE] table_reference
 SET assignment_list
 [WHERE where_condition]
 [ORDER BY ...]
 [LIMIT row_count]
</code></pre>
<h3 id="特有功能"><a class="header" href="#特有功能">特有功能</a></h3>
<hr />
<pre><code class="language-sql">show databases;
use databasename;
show tables;
describe tablename;

#从本地导入数据
#windows用\r\n,mac用\r,linux用\n
LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE tablename LINES TERMINATED BY '\r\n';

#mysql查变量,获取mysql默认行为,各种参数值
SHOW VARIABLES;
#只关注想要的
SHOW VARIABLES LIKE '%timeout%'

# 查看客户端连接详情,用来检查执行客户端的sql情况，特别慢查询,多连接
show full processlist;

#客户端连接数
select client_ip,count(client_ip) as client_num 
from (select substring_index(host,':' ,1) as client_ip from information_schema.processlist ) as connect_info 
group by client_ip order by client_num desc;

#执行sql时间倒序
select * from information_schema.processlist where Command != 'Sleep' order by Time desc;

# 查看表创建语句
show create table xx;

#mysql关闭安全模式
show variables like 'SQL_SAFE_UPDATES';
SET SQL_SAFE_UPDATES = 0;

#通用日志,调试好帮手,需要root权限
show variables like '%general%';
set @@global.general_log=1;
set @@global.general_log=0;

# 设置连接超时时间,下次登陆有效
show variables like '%timeout%';
--604800=60*60*24
set @@GLOBAL.interactive_timeout=604800;
set @@GLOBAL.wait_timeout=604800;

# 查看默认引擎
show engines;

# 查询表中重复数据
select col from table group by col having count(col) &gt; 1;

# 带忽略重复的插入
insert ignore into table(name)  value('xx')

# 常用时间函数
FROM_UNIXTIME(unix_timestamp)是MySQL里的时间函数。
UNIX_TIMESTAMP('2018-09-17') 是与之相对正好相反的时间函数 。

# IF条件表达式
IF(expr1,expr2,expr3)
--如果 expr1 为真(expr1 &lt;&gt; 0 以及 expr1 &lt;&gt; NULL)，那么 IF() 返回 expr2，否则返回 expr3。IF() 返回一个数字或字符串，这取决于它被使用的语境：

#concat把int转varchar类型
update user set nickname = concat(id,'号') where id &gt; 0;

# 字符串替换
update user set nickname = REPLACE(id,'old', 'now') where id &gt; 0

# 查询数据库占用空间及索引空间
# Binlog,阿里云的rds默认把它也计算在内,要手动设置控制大小.大量数据删除时,会突然增加Binlog文件
select TABLE_NAME, concat(truncate(data_length/1024/1024,2),' MB') as data_size,
concat(truncate(index_length/1024/1024,2),' MB') as index_size
from information_schema.tables where TABLE_SCHEMA = 'databaseName'
</code></pre>
<pre><code class="language-bash"># 修改root密码
killall mysqld
mysqld_safe --skip-grant-tables &amp;
update mysql.user set password=PASSWORD('newpassword') where user='root';
flush privileges;
mysqld_safe &amp;

# 设置默认字符集
mysql -u user -D db --default-character-set=utf8 -p
</code></pre>
<h3 id="explain优化sql"><a class="header" href="#explain优化sql">explain优化sql</a></h3>
<hr />
<pre><code class="language-sql">
explain select col from table where con group by xx order by yy;  

</code></pre>
<p>输出说明:</p>
<ol>
<li>table 显示该语句涉及的表</li>
<li>type 这列很重要，显示了连接使用了哪种类别,有无使用索引，反映语句的质量。</li>
<li>possible_keys 列指出MySQL能使用哪个索引在该表中找到行</li>
<li>key 显示MySQL实际使用的键（索引）。如果没有选择索引，键是NULL。</li>
<li>key_len 显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>ref 显示使用哪个列或常数与key一起从表中选择行。</li>
<li>rows 显示MySQL认为它执行查询时必须检查的行数。</li>
<li>extra 包含MySQL解决查询的详细信息。</li>
<li>其中：Explain的type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：
system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL（优--&gt;差）　一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题</li>
</ol>
<h3 id="碎片产生的原因"><a class="header" href="#碎片产生的原因">碎片产生的原因</a></h3>
<hr />
<ul>
<li>表的存储会出现碎片化，每当删除了一行内容，该段空间就会变为空白、被留空，而在一段时间内的大量删除操作，会使这种留空的空间变得比存储列表内容所使用的空间更大；</li>
<li>当执行插入操作时，MySQL会尝试使用空白空间，但如果某个空白空间一直没有被大小合适的数据占用，仍然无法将其彻底占用，就形成了碎片；</li>
<li>当MySQL对数据进行扫描时，它扫描的对象实际是列表的容量需求上限，也就是数据被写入的区域中处于峰值位置的部分；</li>
<li>清除不要数据,记得要optimize table xx;不然空间仍旧占用.</li>
</ul>
<blockquote>
<p>例如：
一个表有1万行，每行10字节，会占用10万字节存储空间，执行删除操作，只留一行，实际内容只剩下10字节，但MySQL在读取时，仍看做是10万字节的表进行处理，所以，碎片越多，就会越来越影响查询性能。</p>
</blockquote>
<h3 id="免密码登陆"><a class="header" href="#免密码登陆">免密码登陆</a></h3>
<ol>
<li>
<p>利用.my.cnf</p>
<pre><code class="language-bash">vi ~/.my.cnf
[client]
# 注意mysql的库中user表,localhost和127.0.0.1区别
host = &quot;127.0.0.1&quot;
user = &quot;user&quot;
password = &quot;pwd&quot;
database = &quot;xx&quot;
</code></pre>
</li>
<li>
<p>利用命令行参数,或者别名</p>
<pre><code class="language-bash">mysql -h localhost -u root -p xxx
</code></pre>
</li>
</ol>
<h3 id="小知识"><a class="header" href="#小知识">小知识</a></h3>
<hr />
<ul>
<li>哪个是JOIN，哪个是过滤器?</li>
</ul>
<pre><code class="language-sql">-- 隐式内联,不好理解容易出错,不建议
-- a,b ==&gt; inner join 简写
-- a.ID = b.ID ==&gt; 用来关联,不是过滤,
SELECT * FROM a,b WHERE a.ID = b.ID
-- 显示内联,建议这种
-- a JOIN b ==&gt; inner join
SELECT * FROM a JOIN b ON a.ID = b.ID
-- USING(ID) == &gt; ON a.ID = b.ID
-- 要求两个表都存在ID列
SELECT * FROM a JOIN b USING(ID)
</code></pre>
<ul>
<li>分组连接</li>
</ul>
<pre><code class="language-sql">select sch_id, count(sch_id) as c, GROUP_CONCAT(sch_name) from sch_basic_info sbi group by sch_id HAVING count(sch_id) &gt; 1 order by c desc;
select  GROUP_CONCAT(sch_name) from sch_basic_info sbi group by sch_id HAVING count(sch_id) &gt; 1;
</code></pre>
<ul>
<li>支持opengis,geometry
<img src="webp/ysql/mysql_opengis.webp" alt="opengis" />
<ul>
<li>Geometry (noninstantiable)</li>
<li>Point (instantiable)</li>
<li>Curve (noninstantiable)</li>
<li>LineString (instantiable)</li>
<li>Line</li>
<li>LinearRing</li>
<li>Surface (noninstantiable)</li>
<li>Polygon (instantiable)</li>
<li>GeometryCollection (instantiable)</li>
<li>MultiPoint (instantiable)</li>
<li>MultiCurve (noninstantiable)</li>
<li>MultiLineString (instantiable)</li>
<li>MultiSurface (noninstantiable)</li>
<li>MultiPolygon (instantiable)</li>
</ul>
</li>
</ul>
<h3 id="附录-1"><a class="header" href="#附录-1">附录</a></h3>
<ul>
<li><a href="https://my.oschina.net/u/4090830/blog/5559454">表一般不超过2000万行</a></li>
<li><a href="https://www.postgresql.org/">postgresql-开源替代品</a></li>
<li><a href="https://www.nebula-graph.io/">c++-图数据库</a></li>
<li><a href="https://github.com/dgraph-io/dgraph">golang-图数据库</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="markdown"><a class="header" href="#markdown">markdown</a></h1>
<hr />
<h3 id="标准化语法"><a class="header" href="#标准化语法"><a href="https://commonmark.org/help/">标准化语法</a></a></h3>
<p><img src="webp/markdown/commonmark_example.webp" alt="语法标记简介" /></p>
<h3 id="github的扩展gfm"><a class="header" href="#github的扩展gfm"><a href="https://github.github.com/gfm">github的扩展GFM</a></a></h3>
<p><img src="webp/markdown/gfm_table.webp" alt="表格扩展" />
<img src="webp/markdown/gfm_task_list.webp" alt="任务列表" />
<img src="webp/markdown/gfm_autolinks.webp" alt="自动链接" />
<img src="webp/markdown/gfm_del.webp" alt="删除" /></p>
<h3 id="表情符号网站"><a class="header" href="#表情符号网站"><a href="https://emojipedia.org/">表情符号网站</a></a></h3>
<blockquote>
<p>语法： &amp;#xCODE; 其中，CODE 可以从 Emoji Unicode Tables中查到。
例子： 查到了 表情对应的 Unicode 编码为 U+1F34E，则与此表情对应的 CODE 为 1F34E (舍弃前面的 U+)。
我们只需在 Markdown 文档中输入 🍎</p>
</blockquote>
<hr />
<h3 id="笔记"><a class="header" href="#笔记">笔记</a></h3>
<ul>
<li>
<p><del>+1</del></p>
</li>
<li>
<p>🍎</p>
</li>
<li>
<p>www.baidu.com</p>
</li>
<li>
<p>gitbook写书工具，有各种插件</p>
</li>
<li>
<p>markdown here写邮件</p>
</li>
<li>
<p>pandoc 不同标记语言间格式转换工具</p>
</li>
<li>
<p>markdown有工具直接生成ppt</p>
</li>
<li>
<p>有工具可以把markdown转成微信公众号需要的格式</p>
</li>
<li>
<p>石墨文档，腾讯文档，语雀文档在线多人协作工具</p>
</li>
<li>
<p>gitbook写书工具，有各种插件</p>
</li>
<li>
<p><a href="https://github.com/rust-lang/mdBook">mdBook-rust实现的gitbook</a></p>
</li>
<li>
<p>mkdocs,python开发的静态站点生成器</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<hr />
<ul>
<li><a href="https://www.rust-lang.org/">官网</a></li>
</ul>
<pre><code class="language-sh">Rustup metadata and toolchains will be installed into the Rustup
home directory, located at:

$HOME/.rustup

This can be modified with the RUSTUP_HOME environment variable.

The Cargo home directory located at:

  $HOME/.cargo

This can be modified with the CARGO_HOME environment variable.

The cargo, rustc, rustup and other commands will be added to
Cargo s bin directory, located at:

  $HOME/.cargo/bin

This path will then be added to your PATH environment variable by
modifying the profile files located at:

  $HOME/.profile
  $HOME/.bashrc
  $HOME/.zshenv

You can uninstall at any time with rustup self uninstall and
these changes will be reverted.
</code></pre>
<ul>
<li>
<p><a href="https://www.rust-lang.org/zh-CN">中文官网</a></p>
</li>
<li>
<p><a href="https://rocket.rs/">rocket-web框架</a></p>
</li>
<li>
<p>小知识</p>
<ul>
<li>升级rust及相关工具链</li>
</ul>
<pre><code class="language-shell">rustup update
</code></pre>
<ul>
<li>本地查看文档</li>
</ul>
<pre><code class="language-shell">rustup doc
</code></pre>
<ul>
<li>每隔一段时间就发布一个版次,主要有2015,2018,2021,主程序和库代码可以依赖不同版次的.</li>
</ul>
</li>
<li>
<p><a href="https://salvo.rs/">强大的rust的web框架</a></p>
</li>
</ul>
<h3 id="mdbook-快速安心写书"><a class="header" href="#mdbook-快速安心写书">mdbook-快速安心写书</a></h3>
<ul>
<li>安装</li>
</ul>
<pre><code class="language-bash">cargo install mdbook
cargo install mdbook-pdf
cargo install mdbook-mermaid
cargo install mdbook-toc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="unity"><a class="header" href="#unity">unity</a></h1>
<hr />
<h3 id="清除启动界面工程"><a class="header" href="#清除启动界面工程">清除启动界面工程</a></h3>
<pre><code class="language-bash">cd /Users/&lt;yourUserName&gt;/Library/Preferences/

cat com.unity3d.UnityEditor5.x.plist

defaults read com.unity3d.UnityEditor5.x.plist
defaults delete com.unity3d.UnityEditor5.x &quot;RecentlyUsedProjectPaths-0&quot;
</code></pre>
<h3 id="打印调用堆栈"><a class="header" href="#打印调用堆栈">打印调用堆栈</a></h3>
<pre><code class="language-c#">string trackStr = new System.Diagnostics.StackTrace().ToString();
Debug.Log (&quot;Stack Info:&quot; + trackStr);
</code></pre>
<h3 id="积累"><a class="header" href="#积累">积累</a></h3>
<ol>
<li>Unity是单线程设计的游戏引擎,子线程中无法运行Unity SDK</li>
<li>Unity主循环是单线程,游戏脚本MonoBehavior有着严格的生命周期</li>
<li>倾向使用time slicing（时间分片）的协程（coroutine）去完成异步任务</li>
</ol>
<h3 id="组件图"><a class="header" href="#组件图">组件图</a></h3>
<p><img src="unity//webp/unity/component.webp" alt="组件图" title="组件图" /></p>
<h3 id="常见热更方案"><a class="header" href="#常见热更方案">常见热更方案</a></h3>
<h4 id="利用c反射动态加载程序集实现代码更新"><a class="header" href="#利用c反射动态加载程序集实现代码更新">利用c#反射,动态加载程序集,实现代码更新</a></h4>
<pre><code class="language-c#">// 从指定网址下载
Assembly assembly = Assembly.LoadFile(assemblyFile);
</code></pre>
<h4 id="创建lua虚拟机动态加载lua脚本"><a class="header" href="#创建lua虚拟机动态加载lua脚本">创建Lua虚拟机,动态加载Lua脚本</a></h4>
<ol>
<li>
<p><a href="https://github.com/Tencent/xLua">腾讯-xLua方案</a></p>
<pre><code class="language-c#">XLua.LuaEnv luaenv = new XLua.LuaEnv();
luaenv.DoString(&quot;CS.UnityEngine.Debug.Log('hello world')&quot;);
luaenv.Dispose();
</code></pre>
</li>
<li>
<p><a href="https://github.com/topameng/tolua">tolua-号称最快</a></p>
<pre><code class="language-C#">LuaState lua = new LuaState();
lua.Start();
lua.DoString(&quot;print('hello world')&quot;);
lua.Dispose();
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="et框架"><a class="header" href="#et框架">ET框架</a></h1>
<hr />
<h2 id="游戏热更目前主流的解决方案"><a class="header" href="#游戏热更目前主流的解决方案">游戏热更目前主流的解决方案</a></h2>
<ol>
<li>
<p>分Lua(ulua/slua/xlua/tolua)系</p>
</li>
<li>
<p>ILRuntime代表的c#系</p>
</li>
</ol>
<h2 id="et框架介绍"><a class="header" href="#et框架介绍">ET框架介绍</a></h2>
<ol>
<li>
<p>热更采用了基于C#的ILRuntime</p>
<p><img src="unity//webp/et/et.webp" alt="et图" title="et图" /></p>
</li>
<li>
<p>客户端目录结构
<img src="unity//webp/et/client.webp" alt="client图" title="client图" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="git"><a class="header" href="#git">git</a></h1>
<hr />
<h3 id="优秀文档"><a class="header" href="#优秀文档">优秀文档</a></h3>
<ul>
<li>[git-scm]<a href="https://git-scm.com/book/zh/">https://git-scm.com/book/zh/</a>)</li>
</ul>
<h3 id="文件状态变迁图"><a class="header" href="#文件状态变迁图">文件状态变迁图</a></h3>
<pre class="mermaid">
flowchart LR
    subgraph WorkDirectory
        ut(Untracked)
        um(Unmodified)--编辑修改--&gt;md(Modified)
    end
    subgraph Staged
        s(Staged/Index)
    end
    subgraph Repo
        r(Commit对象)
    end
WorkDirectory --add--&gt; Staged
Staged --restore或checkout--&gt; WorkDirectory

Staged --commit--&gt; Repo
Repo --restore或reset或checkout--&gt; Staged

</pre>
<p><img src="webp/git/git_lint.webp" alt="git_lint" /></p>
<pre class="mermaid">sequenceDiagram
    actor ut as Untracked
    actor um as Unmodified
    actor m as Modified
    actor s as Staged/Index
    actor r as Repo

    opt 未跟踪新文件
      ut-&gt;&gt;s: add 跟踪
      ut--&gt;&gt;um: 自动转为
      r--&gt;&gt;s: 放弃跟踪 restore --staged或rm --cached
      um--&gt;&gt;ut: 放弃跟踪后自动转为
    end

    opt 已跟踪
      opt 已跟踪编辑
        um-&gt;&gt;m: 编辑
        s--&gt;&gt;um: 放弃编辑 restore或checkout
      end

      opt 提交到stage/index
        m-&gt;&gt;s: add
        r--&gt;&gt;s: 放弃add restore --staged或reset
      end
      r--&gt;&gt;um: 放弃add和编辑 restore --staged --worktree或checkout head
    end
    
    opt 提交repo
      s-&gt;&gt;r: commit
      r--&gt;&gt;s: 放弃commit restore --source=HEAD~1 --staged或reset head~1
    end
    r--&gt;&gt;um: 放弃commit和add和编辑 restore --source=HEAD~1 --staged --worktree或checkout head~1或reset --hard head~1

</pre>
<h3 id="命令介绍"><a class="header" href="#命令介绍">命令介绍</a></h3>
<ul>
<li>
<p>git rm, 删除WorkDictory,Staged/Index的文件</p>
<ul>
<li>命令快照</li>
</ul>
<pre><code class="language-bash">git rm [--cached] &lt;pathspec&gt;...
</code></pre>
<ul>
<li>带上--cached，则只删除Staged/Index,否则WorkDictory也删除</li>
</ul>
</li>
<li>
<p>restore,从指定源恢复</p>
<ul>
<li>命令快照</li>
</ul>
<pre><code class="language-sh"> git restore [&lt;options&gt;] [--source=&lt;tree&gt;] [--staged] [--worktree] [--] &lt;pathspec&gt;...
</code></pre>
<ul>
<li>没有带上--staged,则直接从Staged/Index恢复到WorkDictory</li>
<li>带上--staged,则从repo(head或者source指定commit或tag)恢复到Staged/Index.如果同时要恢复WorkDictory,则带上--worktree</li>
<li>--source默认值为head</li>
<li>命令是试验性的,行为可能会改变.THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.</li>
</ul>
</li>
<li>
<p>reset,设置head,Reset current HEAD to the specified state</p>
<ul>
<li>命令快照-格式1</li>
</ul>
<pre><code class="language-sh"> git reset [-q] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;
</code></pre>
<ul>
<li>
<p>从指定的tree-ish恢复到staged/index,tree-ish不指定就采用head</p>
</li>
<li>
<p>命令快照-格式2</p>
</li>
</ul>
<pre><code class="language-sh"> git reset [&lt;mode&gt;] [&lt;commit&gt;]
         This form resets the current branch head to &lt;commit&gt; and possibly updates the index (resetting it to the tree of &lt;commit&gt;) and the working tree depending on &lt;mode&gt;. If
         &lt;mode&gt; is omitted, defaults to --mixed. The &lt;mode&gt; must be one of the following:
</code></pre>
<ul>
<li>把head指向tree-ish</li>
<li>mode不同值不同含义
<ul>
<li>--soft,仅改动head</li>
<li>--mixed(默认值),改动head并且staged/index恢复为指定tree-ish里面,workdictory不改</li>
<li>--herd,改动head并且staged/index,workdictory恢复为指定tree-ish里面</li>
</ul>
</li>
</ul>
</li>
<li>
<p>checkout,切换分支或恢复出指定文件</p>
<ul>
<li>命令快照-格式1</li>
</ul>
<pre><code class="language-sh">git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;
</code></pre>
<ul>
<li>
<p>没有带上tree-ish,则直接从Staged/Index恢复到WorkDictory</p>
</li>
<li>
<p>带上tree-ish,则从repo(tree-ish)恢复到Staged/Index和WorkDictory</p>
</li>
<li>
<p>tree-ish 通常是head,commit值或tag之类</p>
</li>
<li>
<p>命令快照-格式2</p>
</li>
</ul>
<pre><code class="language-sh">git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;]
</code></pre>
<ul>
<li>
<p>没有带上-b,则直接切换指定分支,分支必须存在</p>
</li>
<li>
<p>带上-b,则创建新分支,并且立即切换过去</p>
</li>
<li>
<p>命令快照-格式3</p>
</li>
</ul>
<pre><code class="language-sh">#从远程仓库/分支,创建本地分支,分支名同远程分支一样,两者建立跟踪关系
#切换到新分支,简化操作
git checkout --track remoteRepo/repoBranch
</code></pre>
</li>
<li>
<p>revert返祖,产生新的提交commit来返回过去的特定提交</p>
<ul>
<li>命令快照</li>
</ul>
<pre><code class="language-sh"> git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;
 git rever -m 1 head
</code></pre>
</li>
</ul>
<pre class="mermaid">
flowchart LR
m1(commitXXXX) --commit--&gt; m2(commitYYYY)
m2 --commit--&gt; m3(commitZZZZ)
m3 --rever -m 1 head--&gt; m4(commitNNNN,但内容和commitYYYY一样)

</pre>
<ul>
<li>
<p>标签</p>
<pre><code class="language-sh">#列出标签
git tag
#查看指定标签
git show vxxx
#打轻量标签
git tag v1.0
#打附注标签
git tag -a v2.0 -m &quot;附加信息&quot;
#把标签vxxx推送到远程
git push origin vxxx
</code></pre>
</li>
<li>
<p>commit对象</p>
</li>
</ul>
<pre class="mermaid">
flowchart LR
    subgraph commitXXXX
        direction TB
        cx(CommitXXXX)--包含--&gt;tx(Tree对象)
        tx--包含--&gt;bxa(Blob对象A)
        tx--包含--&gt;bxb(Blob对象b)
        tx--包含--&gt;bxc(Blob对象c)
    end
    subgraph commitYYYY
        direction TB
        cy(commitYYYY)--包含--&gt;ty(Tree对象)
        ty--包含--&gt;by1(Blob对象1)
        ty--包含--&gt;by2(Blob对象2)
    end
    subgraph commitZZZZ
        direction TB
        cz(commitZZZZ)--包含--&gt;tz(Tree对象)
        tz--包含--&gt;bzl(Blob对象l)
        tz--包含--&gt;bzm(Blob对象m)
        tz--包含--&gt;bzn(Blob对象n)
        tz--包含--&gt;bzo(Blob对象o)
    end
commitXXXX --父对象--&gt; commitYYYY
commitYYYY --父对象--&gt; commitZZZZ

</pre>
<ul>
<li>分支</li>
</ul>
<pre><code class="language-bash">#列出分支
git branch
#查看分支详情
git branch -vv
#创建分支issue100
git branch issue100
#跳到分支issue100
git checkout issue100
#创建hotfix并且立即切过去
git checkout -b hotfix
#删除分支issue100
git branch -d issue100
#指定分支的跟踪远程分支
git branch --set-upstream-to=remote/branch branch
#基于远程分支创建新分支并设置跟踪关系
git checkout --trace -b feature origin/feature
#把hotfix分支合并到当前分支里
git merge hotfix
# 合并没有历史交并的分支
git merge gitee master --allow-unrelated-histories
#如果合并冲突,则编辑修改冲突文件,再提交
git commit -am &quot;人工修改冲突&quot;
#变基是改变-指定分支(不指出则采用当前分支)的起点,并且起点后的提交重播一次
#以hotfix分支为起点,本分支已有提交重播一次,达到合并目的
git rebase hotfix
#如果重播冲突,则编辑修改冲突文件,再提交
git commit -am &quot;人工修改冲突&quot;
#解决冲突后提交,再继续完成变基操作
git rebase --continue
</code></pre>
<p><img src="webp/git/git_rebase.webp" alt="git_rebase" /></p>
<ul>
<li>
<p>rebase变基原则</p>
<ul>
<li>只对尚未推送或分享给别人的本地修改执行变基操作清理历史.</li>
<li>从不对已推送至别处的提交执行变基操作.</li>
</ul>
</li>
<li>
<p>合并提交</p>
</li>
</ul>
<pre><code class="language-bash">git commit -am &quot;first&quot;
# 编辑修改...
git commit -am &quot;second&quot;
# 编辑修改...
git commit -am &quot;three&quot;
# 交互式合并最近三个提交,如下图所示
# 默认从上到下，从旧到新列出来,可以编辑顺序
# 合并时从上到下执行，第一个一般是pack(基础)，其他的为s(合并到基础去,pack改为s)
# 退出保存后,会继续编辑合并信息.
git rebase -i head~3
</code></pre>
<p><img src="webp/git/git_rebase_head.webp" alt="git_rebase" /></p>
<pre><code class="language-bash">git commit
git branch dev
git checkout dev
git commit
git commit
git checkout master
git commit
git commit
git commit
git merge dev
</code></pre>
<pre class="mermaid">gitGraph
  commit
  branch dev
  checkout dev
  commit
  commit
  # 默认master不存在,现在都采用main
  checkout main
  commit
  commit
  commit
  merge dev
</pre>
<ul>
<li>远程仓库</li>
</ul>
<pre class="mermaid">
flowchart LR
    subgraph 本地仓库前
      lm(master)
      ld(dev)
    end
    subgraph 远程仓库
      rm(master)
      rd(dev)
      rh(hotfix)
    end
    subgraph 本地仓库后
      am(master)
      ad(dev)

      arm(origin/master)
      ard(origin/dev)
      arh(origin/hotfix)
    end
本地仓库前 --remote add orgin--&gt; 远程仓库
本地仓库前 --fetch origin--&gt; 本地仓库后

</pre>
<pre><code class="language-sh">#添加远程库
git remote add name url
# 如果远程库有意外提交,可以强行合并进来,再推上去
git pull origin master --allow-unrelated-histories
#拉取远程库内容
git fetch name
#查看远程分支日志
git log name/branch
#创建本地分支branch并且跟踪到远程分支
git checkout --track name/branch
#推送到远程
git push
#删除远程分支
git push name -d branch
#查看本地分支与远程分支设置
git branch -vv
</code></pre>
<ul>
<li>集中式工作流程</li>
</ul>
<pre class="mermaid">sequenceDiagram
    actor da as 开发者A
    actor r as 仓库
    actor db as 开发者B

    da-&gt;&gt;r: clone

    db-&gt;&gt;r: clone

    da-&gt;&gt;da: commit

    db-&gt;&gt;db: commit

    da-&gt;&gt;r: push

    db-&gt;&gt;r: pull

    db-&gt;&gt;r: push

</pre>
<ul>
<li>pull-request工作流程,同一个仓库用不同分支替代仓库,类似流程</li>
</ul>
<pre class="mermaid">sequenceDiagram
    actor da as 开发者A
    actor dar as 开发者A仓库
    actor r as 仓库
    actor rw as 仓库维护者
    actor db as 开发者B
    actor dbr as 开发者B仓库

    opt 开发者A流程
      da-&gt;&gt;r: fork
      r--&gt;&gt;dar: 自动创建
      da-&gt;&gt;dar: clone
      da-&gt;&gt;da: commit
      da--&gt;&gt;dar: push
      dar--&gt;&gt;r: pull requestA
      dar--&gt;&gt;rw: 通知
    end

    opt 开发者B流程
      db-&gt;&gt;r: fork
      r--&gt;&gt;dbr: 自动创建
      db-&gt;&gt;dbr: clone
      db-&gt;&gt;db: commit
      db--&gt;&gt;dbr: push
      dbr--&gt;&gt;r: pull requestB
      dbr--&gt;&gt;rw: 通知
    end

    opt 仓库维护者流程
      rw-&gt;&gt;r: merge pull requestA
      rw-&gt;&gt;r: merge pull requestB
    end

</pre>
<ul>
<li>储存栈</li>
</ul>
<pre><code class="language-sh">#把workdirectory已跟踪修改+staged/index储存到一个栈上,
git stash
#可以在任何一个干净状态恢复出来,不一定需要原来保存的分支里
#不带上--index,则只恢复workdirectory已跟踪修改,
#带上--index,则staged/index也一起恢复
git stash apply [--index]
#apply可以多次重复
#删除就用drop
git stash drop
</code></pre>
<ul>
<li>杂项</li>
</ul>
<pre><code class="language-sh">#配置本项目用户
git config user.name 'username'
git config user.email 'username@xx.com'

# 配置默认的分支名称
git config --global init.defaultBranch master   

#修改最近提交的author
#amend纠正最近一次提交
#此次也会提交stage/index内容,如果stage/index没有修改,则直修改提交信息
git commit --amend --reset-author

# 查看最近3次提交文件变化情况
git log -3 --stat

#查看指定文件提交记录
git log -p filename
# 查看该文件的相关commit
git log -- filename

# 查看指定提交特定文件的变化
git show commit_id filename
# 查看指定提交的变化
git show commit_id

#比较两次提交之间指定目录的区别
git diff 26be34b 934d76fd flow/proto_file

# 有时候git status显示有变化,但是git diff没有,可能是文件换行符及文件权限属性变化了
git diff --cached filename

#当前指定提交commit值
rem 'git rev-parse --short HEAD'

#记录本项目git版本,获取当前git版本值
Cgithash=`git rev-parse --short HEAD`
#获取当前时间
Ctime=`date '+%Y-%m-%d_%H:%M:%S'`

# 强制退回指定commit
#fa2850...是commit的hash值
git reset --hard fa285014d635190e74cd40fc798ce26243766a09

#带用户名及密码的git clone
git clone http://uer:pwd@xxx.git


# 本地修改不提交到远程仓库
git update-index --skip-worktree filePath

# post-receive钩子
# git pull引入$GIT_DIR变量,因此需要取消变量
unset $(git rev-parse --local-env-vars);
git pull


# 查看特定提交在哪里分支
git branch --contains xxxx -all

# 创建一个空分支,没有任何父节点
git checkout --orphan newBranch
git rm -rf .
# 如何没有任何文件提交，看不到新建的分支
git commit -am &quot;newBranch&quot;
</code></pre>
<h3 id="积累-1"><a class="header" href="#积累-1">积累</a></h3>
<hr />
<ul>
<li>
<p><strong><a href="https://git-scm.com/">官网</a></strong></p>
</li>
<li>
<p>Git gc一般情况不用手动,gc主要把无用的内部对象回收,一般都自动处理</p>
</li>
<li>
<p>Git钩子都被存储在 Git 目录下的 hooks 子目录中.</p>
</li>
<li>
<p>.git目录内容
<img src="webp/git/git_dir.webp" alt="git_dir" /></p>
</li>
<li>
<p>git引用
<img src="webp/git/git_refs.webp" alt="git_refs" /></p>
</li>
<li>
<p>查看项目本地仓库,远程仓库,标签等</p>
</li>
</ul>
<pre><code class="language-sh">  tree .git/refs
</code></pre>
<p><img src="webp/git/git_tree_refs.webp" alt="git_tree_refs" /></p>
<ul>
<li>
<p>Git 可以使用四种不同的协议来传输资料：</p>
<ul>
<li>本地协议（Local）</li>
</ul>
<pre><code class="language-sh">#本机clone,尽量采用不带file://前缀,加快速度
git clone /srv/git/project.git
git clone file:///srv/git/project.git
</code></pre>
<ul>
<li>HTTP 协议，现在git一般采用智能 HTTP 协议</li>
</ul>
<pre><code class="language-sh">git clone https://example.com/gitproject.git
</code></pre>
<ul>
<li>SSH（Secure Shell）协议</li>
</ul>
<pre><code class="language-sh">git clone ssh://[user@]server/project.git
git clone [user@]server:project.git
</code></pre>
<ul>
<li>Git 协议
<ul>
<li>Git里的一个特殊的守护进程,它监听在一个特定的端口（9418）</li>
<li>速度最快的</li>
<li>缺乏授权机制</li>
<li>git://</li>
</ul>
</li>
</ul>
</li>
<li>
<p>利用post-receive钩子自动更新</p>
</li>
</ul>
<pre><code class="language-sh">  #!/usr/bin/env bash

  # post-receive脚本代码
  cd ~
  target=xxx
  # 简单粗暴,删除旧目录
  if [ -d ${target} ]; then
      rm -rf ${target}
  fi
  # 重新建立,从git代码库目录
  git clone gogs-repositories/yyy/${target}.git
  # 杀死进程
  pkill ${target}
  cd ${target}
  # 后台运行进程
  nohup ./${target} &gt;${target}.nohup 2&gt;&amp;1 &amp;
</code></pre>
<ul>
<li>
<p>push碰到HTTP 413</p>
<ul>
<li>问题表现</li>
</ul>
<pre><code class="language-sh">Git push error: error: RPC failed; HTTP 413 curl 22 the requested URL returned error: 413
</code></pre>
<ul>
<li>解决办法</li>
</ul>
<pre><code class="language-sh"># 增加最大http长度
git config –global http.postBuffer 524288000
</code></pre>
<pre><code class="language-nginx">location / {
  ...
  # 如果有nginx转发
  client_max_body_size 200M;
  ...
}
</code></pre>
</li>
</ul>
<h3 id="多项目-一个项目采用git管理使用另一个项目采用git管理"><a class="header" href="#多项目-一个项目采用git管理使用另一个项目采用git管理">多项目-一个项目(采用git管理)使用另一个项目(采用git管理)</a></h3>
<hr />
<ul>
<li>
<p>Git Submodule</p>
<ul>
<li>
<p>添加子目录</p>
<pre><code class="language-sh"># 默认在目录下建立repo子目录,并且克隆仓库,并且创建.gitmodules
git submodule add  https://xxx/repo.git
# 提交到仓库
git commit -am &quot;submodule&quot;

# 如果子项目有更新,直接取更新
git submodule update --remote
# 然后更新父目录,子项目引用到更新后的
git commit -am &quot;更新submodule&quot;

#可以直接在子目录修改提交,和正常git操作一样
</code></pre>
</li>
<li>
<p>其他人使用</p>
<pre><code class="language-sh"># 一次性克隆项目及子项目
git clone --recursive https://xxx/repo.git

# 或者先克隆项目
git clone  https://xxx.git
# 手动更新子项目
git submodule init
git submodule update --remote

#可以直接在子目录修改提交,和正常git操作一样
</code></pre>
</li>
<li>
<p>子项目.git目录储存到父项目的.git/modules目录
<img src="webp/git/git_submodules.webp" alt="git_submodules" /></p>
</li>
<li>
<p>用引用方式,显式操作</p>
</li>
</ul>
</li>
<li>
<p>Git Subtree</p>
<ul>
<li>
<p>添加子目录，建立与git项目的关联</p>
<pre><code class="language-sh">#-f在添加远程仓库之后，立即执行fetch
git remote add -f &lt;子仓库名&gt; &lt;子仓库地址&gt;

#–squash意思是把subtree的改动合并成一次commit，不用拉取子项目完整的历史记录。
#–prefix之后的=等号也可以用空格。
git subtree add --prefix=&lt;子目录名&gt; &lt;子仓库名&gt; &lt;分支&gt; --squash
</code></pre>
</li>
<li>
<p>从远程仓库更新子目录</p>
<pre><code class="language-sh">git fetch &lt;远程仓库名&gt; &lt;分支&gt;
git subtree pull --prefix=&lt;子目录名&gt; &lt;远程分支&gt; &lt;分支&gt; --squash
</code></pre>
</li>
<li>
<p>从子目录push到远程仓库（确认你有写权限）</p>
<pre><code class="language-sh">git subtree push --prefix=&lt;子目录名&gt; &lt;远程分支名&gt; 分支
</code></pre>
</li>
<li>
<p>用复制方式,隐式操作</p>
</li>
</ul>
</li>
<li>
<p>GitSlave</p>
</li>
</ul>
<h3 id="清除大文件"><a class="header" href="#清除大文件">清除大文件</a></h3>
<ul>
<li>
<p>采用工具</p>
</li>
<li>
<p>清理仓库大文件需要修改仓库的提交历史，git-filter-repo 是 Git 官方社区推荐的修改仓库提交历史的工具，本文介绍使用 git-filter-repo 来清理仓库大文件的方法。
<a href="https://help.aliyun.com/document_detail/369469.htm?spm=a2c4g.11186623.0.0.43d46980JHMUZq#topic-2156461">看他</a></p>
<pre><code class="language-bash">  pip3 install git-filter-repo
</code></pre>
</li>
<li>
<p>手动执行</p>
</li>
</ul>
<pre><code class="language-bash">
# 完全清除git中大文件提交
# 查看大文件
# 使用verify-pack命令查看, pack包里面的最大的10个文件对应的hash值
# 根据rev-list命令来查看, 最大的文件的文件名是什么
git rev-list --objects --all | grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}')&quot;

# 删除大文件
git filter-branch --force --index-filter &quot;git rm -rf --cached --ignore-unmatch linux_x86_64/zinc_upx&quot; --prune-empty --tag-name-filter cat -- --all

# 回收空间，清理本地仓库不可达对象;
git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
rm -rf .git/refs/original/
rm -rf .git/logs/
git reflog expire --expire=now --all
git gc --prune=now
git gc --aggressive --prune=now

# 强制推到远程
git push origin --force --all 
# git push origin –-force --tag
git remote prune origin 

# ！！清理完之后,每个人一定要删掉之前拉取的项目, 重新从git上拉项目。不要使用之前的项目了！否则会不降反升。
</code></pre>
<h3 id="清除未跟踪文件"><a class="header" href="#清除未跟踪文件">清除未跟踪文件</a></h3>
<pre><code class="language-bash"># 清除文件
git clean -f
# 连目录也一起清除文件
git clean -fd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="grpc"><a class="header" href="#grpc">grpc</a></h1>
<hr />
<h3 id="相关网站"><a class="header" href="#相关网站">相关网站</a></h3>
<hr />
<ul>
<li><a href="https://developers.google.com/protocol-buffers/">官网</a></li>
<li><a href="https://github.com/protocolbuffers/protobuf/releases">github下载</a></li>
<li><a href="https://github.com/protocolbuffers/protobuf-go/releases/">protobuf-go插件</a></li>
<li><a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway-http转grpc</a></li>
<li><a href="https://docs.buf.build/">buf-强化pb生成</a></li>
<li><a href="https://www.rkdev.info/">rk-golang微服务框架</a></li>
<li><a href="https://github.com/grpc/grpc-swift">grpc-swift语言实现</a></li>
</ul>
<pre><code class="language-sh">#mac系统中采用brew,很可能已安装过
brew list | grep protobuf
brew info protobuf
</code></pre>
<h3 id="golang使用图示"><a class="header" href="#golang使用图示">golang使用图示</a></h3>
<hr />
<pre class="mermaid">
sequenceDiagram
    actor u as user
    actor pf as proto文件
    actor pc as protoc
    actor pgg as protoc-gen-go
    actor pb as .pb.go文件
    u-&gt;&gt;pf: 编写message
    u-&gt;&gt;pc: 启动
    pc-&gt;&gt;pf: 读取
    pc-&gt;&gt;pgg: 调用
    pgg-&gt;&gt;pb: 生成
    u-&gt;&gt;pb: 使用

</pre>
<ul>
<li>生成文件</li>
</ul>
<pre class="mermaid">
sequenceDiagram
    actor u as user
    actor pf as proto文件
    actor pc as protoc
    actor pgg as protoc-gen-go
    actor pb as .pb.go文件
    actor pggg as protoc-gen-go-grpc
    actor gpb as grpc.pb.go文件
    u-&gt;&gt;pf: 编写message,service
    u-&gt;&gt;pc: 启动
    pc-&gt;&gt;pf: 读取
    pc-&gt;&gt;pgg: 调用
    pgg-&gt;&gt;pb: 生成
    pc-&gt;&gt;pggg: 调用
    pggg-&gt;&gt;gpb: 生成
    u-&gt;&gt;pb: 使用
    u-&gt;&gt;gpb: 使用

</pre>
<ul>
<li>客户端使用</li>
</ul>
<pre class="mermaid">
sequenceDiagram
    actor u as user
    actor gpb as grpc.pb.go文件
    actor r as rpc服务器
    u-&gt;&gt;r: Dial()conn
    u-&gt;&gt;gpb: Newclient(conn)
    u-&gt;&gt;gpb: client.XXX()
    gpb-&gt;&gt;+r: conn发送请求
    r--&gt;&gt;-gpb: return
    gpb--&gt;&gt;u: return

</pre>
<ul>
<li>服务端使用</li>
</ul>
<pre class="mermaid">
sequenceDiagram
    actor u as user
    actor t as tcp
    actor g as grpc
    actor gpb as grpc.pb.go文件
    u-&gt;&gt;t: Listen()conn
    u-&gt;&gt;g: NewServer
    u-&gt;&gt;gpb: NewService
    u-&gt;&gt;g: RegService
    u-&gt;&gt;+g: Serve(conn)
    g-&gt;&gt;g: 等待客户端

</pre>
<h3 id="实践示例"><a class="header" href="#实践示例">实践示例</a></h3>
<hr />
<pre><code class="language-sh">protoc --proto_path=IMPORT_PATH \
--cpp_out=DST_DIR \
--java_out=DST_DIR \
--python_out=DST_DIR \ 
--go_out=DST_DIR \
--ruby_out=DST_DIR \ 
--objc_out=DST_DIR \
--csharp_out=DST_DIR \
path/to/file.proto

#--go_out表示启动protoc-gen-go插件
#proto文件和本脚本在同一目录,执行前要cd到本目录,防止出现各种相对路径找不到
#Could not make proto path relative: *.proto: No such file or directory
protoc --cpp_out=../cpp --python_out=../python --go_out=../event *.proto

#--go-grpc_out表示启动protoc-gen-go-grpc插件
protoc --go_out=../event --go-grpc_out=../event *.proto
</code></pre>
<ul>
<li>user.proto内容</li>
</ul>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

option go_package = &quot;./;event&quot;;

import &quot;person.proto&quot;;

service User {
    rpc Reg(Person)returns(Person){}
}
</code></pre>
<ul>
<li>example.proto内容</li>
</ul>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package example;

//protoc-gen-go The import path must contain at least one period ('.') or forward slash ('/') character.
//https://developers.google.com/protocol-buffers/docs/reference/go-generated
//表示直接生成文件到go_out目录
option go_package = &quot;./;event&quot;;

//vscode中vscode-proto3插件import提示无法找到other.proto
//vscode直接打开other.proto所在目录,不要打开父目录
import &quot;other.proto&quot;;

//单行注释
message Person {
    string name = 1;
    int32 id = 2;
    repeated string emails = 3;
    map&lt;string, int32&gt; dict = 4;
    repeated Order orders = 5;
  }
  
  /*
  多行注释
  */
  message SearchResponse {
    message Result {
      string url = 1;
      string title = 2;
      repeated string snippets = 3;
    }
    repeated Result results = 1;
  }
</code></pre>
<ul>
<li>other.proto内容</li>
</ul>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

package example;

option go_package = &quot;./;event&quot;;

message Order {
    int64 id = 1;
    uint64 date = 2;
    string customer = 3;
    double price = 4;
    string goods = 5;
    string remark = 6;
}
</code></pre>
<h3 id="数据类型-1"><a class="header" href="#数据类型-1">数据类型</a></h3>
<hr />
<p><img src="webp/grpc/protobuf_type1.webp" alt="类型1" />
<img src="webp/grpc/protobuf_type2.webp" alt="类型2" />
<img src="webp/grpc/protobuf_default.webp" alt="默认值" /></p>
<h3 id="更多"><a class="header" href="#更多">更多</a></h3>
<hr />
<ul>
<li>gRPC + Opentracing + Zipkin 分布式链路追踪系统</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="brew-酿制"><a class="header" href="#brew-酿制">brew-酿制</a></h1>
<hr />
<h3 id="官网-1"><a class="header" href="#官网-1"><a href="https://brew.sh/">官网</a></a></h3>
<p><img src="webp/brew/brew_logo.webp" alt="brew_logo" title="brew_logo" /></p>
<ul>
<li>Homebrew 类似于一个软件中心，你可以理解成 App Store 或者 Google Play 那样的软件商店，只不过，Homebrew 比前者以及 Mac App Store 来说有着更丰富的资源与更高效的管理。</li>
<li>Homebrew Cask，它是一套建立在 Homebrew 基础之上的 OS X 软件安装命令行工具，是 Homebrew 的扩展.</li>
<li>homebrew-自家酿酒</li>
<li>formula-配方</li>
<li>key-桶酒,编译完成的套件资料夹</li>
<li>Cellar-地窖</li>
</ul>
<h3 id="安装命令"><a class="header" href="#安装命令">安装命令</a></h3>
<pre><code class="language-sh"># 如果很慢,可能切换国内源
/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<h3 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h3>
<pre><code class="language-sh"># 在 .zshrc 文件中添加
# Homebrew 取消自动更新
export HOMEBREW_NO_AUTO_UPDATE=true


# 安装hugo,nginx,memcached,redis,mongodb-community,mysql,jenkins-lts等等
brew install hugo

# 查看
brew info memcached

# 搜索
brew search redis

# 查看支持的命令
brew commands 

# 列出常用帮助
brew help

# 运行后台服务 start restart stop
brew services start nginx

#unbound is a validating, recursive, caching DNS resolver.
brew services start unbound

# unrar已经被删除了,只能安装私人的
brew install unrar
brew install carlocab/personal/unrar
</code></pre>
<h3 id="附录-2"><a class="header" href="#附录-2">附录</a></h3>
<ul>
<li>
<p>HOMEBREW_NO_INSTALL_CLEANUP参数说明</p>
<pre><code class="language-sh">Unless HOMEBREW_NO_INSTALL_CLEANUP is set, brew cleanup will be run for the installed formulae or, every 30 days, for all formulae
</code></pre>
</li>
<li>
<p>brew install xxx过程</p>
</li>
</ul>
<pre class="mermaid">sequenceDiagram
    actor b as brew
    actor f as github源
    actor ph as $Home/Library/Caches/Homebrew
    actor pc as /opt/homebrew/Cellar
    actor pb as /opt/homebrew/bin
    actor p as $PATH

    b-&gt;&gt;f: 下载 xxx.rb
    b-&gt;&gt;b: 执行xxx.rb
    b-&gt;&gt;ph: 下载依赖及源码xxx.tar.gz到
    b-&gt;&gt;b: 解压编译
    b-&gt;&gt;pc:编译结果保存到
    pc-&gt;&gt;pb:软链接
    pb--&gt;&gt;p:事先加入到

</pre>
<ul>
<li><a href="https://github.com/Homebrew/homebrew-core/tree/master/Formula">github源</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="代码托管"><a class="header" href="#代码托管">代码托管</a></h1>
<hr />
<h4 id="总览"><a class="header" href="#总览">总览</a></h4>
<pre class="mermaid">
flowchart LR
A(域名解析) --&gt; B(配置Nginx)
B --&gt; C(配置gogs)
C --&gt; D(git提交)
D --&gt; E(golang使用)

</pre>
<pre class="mermaid">
sequenceDiagram
    actor u as 用户
    actor h as hosts
    actor n as Nginx
    actor g as Gogs
    actor f as 文件系统
    u-&gt;&gt;h: mydomain.site
    h--&gt;&gt;u: 127.0.0.1
    n-&gt;&gt;n: 监听127.0.0.1
    u-&gt;&gt;n: `https://mydomain.site/what/up....`
    n-&gt;&gt;+g: `http://xx.xx.xx.xx:3000/what/up...`
    g-&gt;&gt;f: 读写
    g--&gt;&gt;-n: http回包
    n--&gt;&gt;u: https回包

</pre>
<h4 id="域名解析"><a class="header" href="#域名解析">域名解析</a></h4>
<ol>
<li>
<p>修改hosts</p>
<pre><code class="language-sh">vim /etc/hosts

#配置mydomain.site的dns为本机
#如果域名有备案,可以跳过此步,直接增加域名的A记录
127.0.0.1 mydomain.site
</code></pre>
</li>
<li>
<p>申请域名证书</p>
<p>现在都不走http,都走https.个人项目,所以申请免费证书.生产环境还是要收费证书.免费申请证书途径:</p>
<ul>
<li><a href="https://freessl.cn">freessl</a>网站</li>
<li><a href="https://letsencrypt.org/zh-cn">letsencrypt</a>网站</li>
<li>阿里云SSL证书服务</li>
<li>又拍云SSL 证书服务</li>
<li>七牛云免费SSL证书</li>
<li>百度云SSL证书服务</li>
<li>腾讯云SSL证书服务</li>
<li>华为云SSL证书管理SCM</li>
</ul>
</li>
</ol>
<h4 id="配置nginx"><a class="header" href="#配置nginx">配置Nginx</a></h4>
<ol>
<li>
<p>安装nginx</p>
<pre><code class="language-sh">brew install nginx
# 如果遇到不能启动，尝试启动sudo brew services start nginx
brew services start nginx
</code></pre>
<ul>
<li>nginx源码安装,点<a href="/nginx/install">这里</a></li>
<li>其他方式安装,看<a href="https://nginx.org/en/docs/install.html">这里</a></li>
</ul>
</li>
<li>
<p>修改配置文件</p>
</li>
</ol>
<pre><code class="language-nginx">...
server {
        listen       443 ssl;
        server_name  mydomain.site;

        #mydomain.site.pem/mydomain.site.key
        #就是申请域名证书后,网站提供的相关文件
        ssl_certificate      ssl/mydomain.site.pem;
        ssl_certificate_key  ssl/mydomain.site.key;

        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;

        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;

        location / {
            #直接转发gogs目录
            proxy_pass http://xx.xx.xx.xx:3000;
        }
    }
...
</code></pre>
<h4 id="配置gogs"><a class="header" href="#配置gogs">配置gogs</a></h4>
<ol>
<li>
<p>安装gogs</p>
<pre><code class="language-sh">wget https://dl.gogs.io/$VERSION/gogs_$VERSION_$OS_$ARCH.tar.gz
tar -zxvf gogs_$VERSION_$OS_$ARCH.tar.gz
cd gogs_$VERSION_$OS_$ARCH

</code></pre>
<ul>
<li>其他方式安装,看<a href="https://gogs.io/docs/installation/install_from_binary.html">这里</a></li>
</ul>
</li>
<li>
<p>修改配置</p>
<pre><code class="language-sh">[server]
DOMAIN           = mydomain.site
HTTP_PORT        = 3000
//旧版本是修改ROOT_URL
EXTERNAL_URL     = https://mydomain.site/
</code></pre>
</li>
<li>
<p>运行</p>
<pre><code class="language-sh">#后台守护进程运行
nohup ./gogs web &amp;
</code></pre>
</li>
<li>
<p>创建仓库(可以导入其他的repos，快速创建)</p>
<pre><code class="language-sh">#假设用户名为what,仓库名为up,仓库必须为公开,则仓库地址:
https://mydomain.site/what/up.git
</code></pre>
</li>
</ol>
<h4 id="git使用"><a class="header" href="#git使用">git使用</a></h4>
<pre><code class="language-sh">#git下载
git clone https://mydomain.site/what/up.git

#增加代码及其他
....

#提交代码
git push
</code></pre>
<h4 id="golang使用"><a class="header" href="#golang使用">golang使用</a></h4>
<ol>
<li>
<p>设置私域名,不走代理</p>
<pre><code class="language-sh">go env -w GOPRIVATE=mydomain.site
</code></pre>
</li>
<li>
<p>代码使用</p>
<pre><code class="language-golang">package main

import (
    &quot;fmt&quot;

    &quot;mydomain.site/what/up&quot;
)

func main() {
    fmt.Println(up.Add(10, 10))
    fmt.Println(up.Power(10, 10))
}            
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="mermaid-美人鱼示例"><a class="header" href="#mermaid-美人鱼示例"><a href="https://mermaid-js.github.io/mermaid/">mermaid-美人鱼</a>示例</a></h1>
<hr />
<h3 id="flowchart"><a class="header" href="#flowchart">Flowchart</a></h3>
<hr />
<pre><code class="language-mmd">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre>
<pre class="mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</pre>
<h3 id="sequence-diagram"><a class="header" href="#sequence-diagram">Sequence diagram</a></h3>
<hr />
<pre><code class="language-mmd">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!
</code></pre>
<pre class="mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!
</pre>
<h3 id="pie"><a class="header" href="#pie">pie</a></h3>
<hr />
<pre><code class="language-mmd">pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5

</code></pre>
<pre class="mermaid">pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5

</pre>
<h3 id="mindmap"><a class="header" href="#mindmap">mindmap</a></h3>
<hr />
<pre><code class="language-mmd">mindmap
Root
    A
      B
      C
</code></pre>
<pre class="mermaid">mindmap
Root
    A
      B
      C
</pre>
<pre><code class="language-mmd">mindmap
  root((mindmap))
    Origins
      Long history
      ::icon(fa fa-book)
      Popularisation
        British popular psychology author Tony Buzan
    Research
      On effectiveness&lt;br/&gt;and features
      On Automatic creation
        Uses
            Creative techniques
            Strategic planning
            Argument mapping
    Tools
      Pen and paper
      Mermaid
</code></pre>
<pre class="mermaid">mindmap
  root((mindmap))
    Origins
      Long history
      ::icon(fa fa-book)
      Popularisation
        British popular psychology author Tony Buzan
    Research
      On effectiveness&lt;br/&gt;and features
      On Automatic creation
        Uses
            Creative techniques
            Strategic planning
            Argument mapping
    Tools
      Pen and paper
      Mermaid
</pre>
<h3 id="timeline"><a class="header" href="#timeline">timeline</a></h3>
<hr />
<pre><code class="language-mmd">timeline
    title 时间图
    2002 : LinkedIn
    2004 : Facebook
         : Google
    2005 : Youtube
    2006 : Twitter
</code></pre>
<pre class="mermaid">timeline
    title 时间图
    2002 : LinkedIn
    2004 : Facebook
         : Google
    2005 : Youtube
    2006 : Twitter
</pre>
<pre><code class="language-mmd">timeline
    title MermaidChart 2023 Timeline
    section 2023 Q1 &lt;br&gt; Release Personal Tier
        Buttet 1 : sub-point 1a : sub-point 1b
            : sub-point 1c
        Bullet 2 : sub-point 2a : sub-point 2b
    section 2023 Q2 &lt;br&gt; Release XYZ Tier
        Buttet 3 : sub-point &lt;br&gt; 3a : sub-point 3b
            : sub-point 3c
        Bullet 4 : sub-point 4a : sub-point 4b
</code></pre>
<pre class="mermaid">timeline
    title MermaidChart 2023 Timeline
    section 2023 Q1 &lt;br&gt; Release Personal Tier
        Buttet 1 : sub-point 1a : sub-point 1b
            : sub-point 1c
        Bullet 2 : sub-point 2a : sub-point 2b
    section 2023 Q2 &lt;br&gt; Release XYZ Tier
        Buttet 3 : sub-point &lt;br&gt; 3a : sub-point 3b
            : sub-point 3c
        Bullet 4 : sub-point 4a : sub-point 4b
</pre>
<h3 id="journey"><a class="header" href="#journey">journey</a></h3>
<pre><code class="language-mmd">journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me
</code></pre>
<pre class="mermaid">journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me
</pre>
<h3 id="gantt-diagram"><a class="header" href="#gantt-diagram">Gantt diagram</a></h3>
<hr />
<pre><code class="language-mmd">gantt
dateFormat  YYYY-MM-DD
title Adding GANTT diagram to mermaid
excludes weekdays 2014-01-10

section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d
</code></pre>
<pre class="mermaid">gantt
dateFormat  YYYY-MM-DD
title Adding GANTT diagram to mermaid
excludes weekdays 2014-01-10

section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d
</pre>
<h3 id="git-graph"><a class="header" href="#git-graph">Git graph</a></h3>
<hr />
<pre><code class="language-mmd">gitGraph:
options
{
    &quot;nodeSpacing&quot;: 150,
    &quot;nodeRadius&quot;: 10
}
end
commit
branch newbranch
checkout newbranch
commit
commit
checkout main
commit
commit
merge newbranch

</code></pre>
<pre class="mermaid">gitGraph:
options
{
    &quot;nodeSpacing&quot;: 150,
    &quot;nodeRadius&quot;: 10
}
end
commit
branch newbranch
checkout newbranch
commit
commit
checkout main
commit
commit
merge newbranch

</pre>
<h3 id="class-diagram"><a class="header" href="#class-diagram">Class diagram</a></h3>
<hr />
<pre><code class="language-mmd">classDiagram
Class01 &lt;|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --&gt; C2 : Where am i?
Class09 --* C3
Class09 --|&gt; Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 &lt;--&gt; C2: Cool label
</code></pre>
<pre class="mermaid">classDiagram
Class01 &lt;|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --&gt; C2 : Where am i?
Class09 --* C3
Class09 --|&gt; Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 &lt;--&gt; C2: Cool label
</pre>
<h3 id="entity-relationship-diagram"><a class="header" href="#entity-relationship-diagram">Entity Relationship Diagram</a></h3>
<hr />
<pre><code class="language-mmd">erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses

</code></pre>
<pre class="mermaid">erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses

</pre>
<h3 id="user-journey-diagram"><a class="header" href="#user-journey-diagram">User Journey Diagram</a></h3>
<hr />
<pre><code class="language-mmd">journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me
</code></pre>
<pre class="mermaid">journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me
</pre>
<h3 id="state-diagrams"><a class="header" href="#state-diagrams">State diagrams</a></h3>
<hr />
<pre><code class="language-mmd">stateDiagram-v2
    [*] --&gt; Still
    Still --&gt; [*]

    Still --&gt; Moving
    Moving --&gt; Still
    Moving --&gt; Crash
    Crash --&gt; [*]
</code></pre>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Still
    Still --&gt; [*]
    Still --&gt; Moving
    Moving --&gt; Still
    Moving --&gt; Crash
    Crash --&gt; [*]
</pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="shell-1"><a class="header" href="#shell-1">shell</a></h1>
<hr />
<h2 id="升级替换系统命令-modern-unix"><a class="header" href="#升级替换系统命令-modern-unix">升级替换系统命令-<a href="https://github.com/ibraheemdev/modern-unix">modern-unix)</a></a></h2>
<ul>
<li>bat代替cat, bat 相比 cat 增加了行号和颜色高亮 👍</li>
<li>duf代替df</li>
<li>exa代替ls</li>
<li>dust代替du</li>
<li>procs代替ps</li>
<li>difft替代diff</li>
<li>McFly(<a href="https://github.com/cantino/mcfly">https://github.com/cantino/mcfly</a>)</li>
<li>zoxide代替cd,可能不用启动z</li>
<li>tldr替代man, <a href="https://github.com/tldr-pages/tldr">tldr-github</a> pip install tldr</li>
<li>ctrl+r 搜索历史命令</li>
</ul>
<pre><code class="language-bash"># 或者ctrl+r
mcfly search
</code></pre>
<h3 id="并发启动命令"><a class="header" href="#并发启动命令">并发启动命令</a></h3>
<pre><code class="language-bash">for var in {0..2}
do
    #用{}把循环体括起来，后加一个&amp;符号，代表每次循环都把命令放入后台运行
    #一旦放入后台，就意味着{}里面的命令交给操作系统的一个线程处理了
    {
        echo ${var}
    }&amp;
done
wait

#wait命令的意思是，等待（wait命令）上面的命令（放入后台的）都执行完毕了再往下执行
</code></pre>
<h3 id="常用源目录"><a class="header" href="#常用源目录">常用源目录</a></h3>
<ul>
<li>/etc/yum.repos.d</li>
</ul>
<h3 id="systemd新时代linux服务管理软件就是平时使用systemctl-start-stop-enable-disable-status-xxx"><a class="header" href="#systemd新时代linux服务管理软件就是平时使用systemctl-start-stop-enable-disable-status-xxx">systemd新时代linux服务管理软件,就是平时使用(systemctl start stop enable disable status) xxx</a></h3>
<ul>
<li>systemd是一个服务管理器,它使管理服务器变得更加容易。</li>
<li>对于支持 systemd 的软件，安装的时候，它会自动的在 /usr/lib/systemd/system 目录添加一个配置文件</li>
<li>/lib -&gt; /usr/lib 通常路径被软链接
<img src="webp/shell/link.webp" alt="link" /></li>
</ul>
<h3 id="curl带用户名密码的pos提交"><a class="header" href="#curl带用户名密码的pos提交">curl带用户名密码的pos提交</a></h3>
<pre><code class="language-bash">curl -i -X POST \
 http://localhost:4080/api/test/_doc \
 -u user:pwd \
  -H 'Content-Type: application/json' \
  -d '{&quot;name&quot;:&quot;中文12344&quot;, &quot;value&quot;:&quot;https://abc.iste/&quot;}'

curl -X DELETE \
 http://127.0.0.1:4080/api/index/xxx/ \
 -u user:pwd

# 获取本机外网ip
curl ifconfig.me
</code></pre>
<h2 id="查看哪个命令在哪个包中"><a class="header" href="#查看哪个命令在哪个包中">查看哪个命令在哪个包中</a></h2>
<pre><code class="language-bash"># dnf是yum的继承者,更好用
# 查找提供指定内容的软件包
dnf provides '*/chsh'
# 以 Fedora 为基准的安装包如下
dnf install -y util-linux-user
# 搜索一定要加引号
dnf search 'keyword'

# 修改默认的shell
chsh [option] user

# 带调试查看ssh登陆过程,用于卡
ssh -vvv xxxx

# 后来ssh -v 登录查看了下日志，发现一直卡在debug1: SSH2_MSG_KEXINIT sent。直到最后链接失败。
# 网上查了很多，发现是因为mtu设置的数值太大。网络-&gt;高级-&gt;手动(平时是自动)-&gt;指定1500
</code></pre>
<h2 id="sshconfig管理多个ssh密钥"><a class="header" href="#sshconfig管理多个ssh密钥">.ssh/config管理多个ssh密钥</a></h2>
<hr />
<ol>
<li>
<p>~/.ssh/config如果不存在,则创建.</p>
<pre><code class="language-sh">...

# Host可以自定义
Host github2
    # github.com这个是真实远程服务器,不能修改
    # id_ecdsa.pub内容要在github相应帐户添加为ssh密钥
    HostName github.com
    PreferredAuthentications publickey
    # 指明用哪个文件
    IdentityFile ~/.ssh/id_ecdsa

...
</code></pre>
<ul>
<li>Host的定义可以有多组,用指定哪个ssh密钥对应哪个HostName/Host</li>
<li>一般不同域名不同ssh密钥不用配置config,能自动查找对应</li>
</ul>
</li>
<li>
<p>测试config</p>
<pre><code class="language-sh">
#github2为config文件中的Host值
ssh -T git@github2

# 查看ssh登陆详情
ssh -vvvT git@github2

</code></pre>
<ul>
<li>如果github.com的帐户username设置了id_ecdsa.pub</li>
<li>则会回包Hi username! You've successfully authenticated, but GitHub does not provide shell access</li>
</ul>
</li>
<li>
<p>修改远程仓库url</p>
<pre><code class="language-sh">#git@github.com:username/reposname.git==&gt;git@github2:username/reposname.git
#github2为config文件中的Host值,表明reposname要采用id_ecdsa密钥
git clone git@github2:username/reposname.git

</code></pre>
</li>
<li>
<p>本地reposename配置.git/config</p>
<pre><code class="language-sh">cd reposname
git config user.name 'username'
git config user.email 'username@xx.com'
</code></pre>
<ul>
<li>github根据配置文件的user.email来获取github帐号显示author信息</li>
</ul>
</li>
</ol>
<h2 id="在连接远程ssh服务的时候经常会发生长时间后的断线或者无响应无法再键盘输入"><a class="header" href="#在连接远程ssh服务的时候经常会发生长时间后的断线或者无响应无法再键盘输入">在连接远程SSH服务的时候,经常会发生长时间后的断线，或者无响应（无法再键盘输入)</a></h2>
<ul>
<li>客户端定时发送心跳,添加修改本机~/ssh/config</li>
</ul>
<pre><code class="language-bash">vim config

# 即每隔30秒，向服务器发出一次心跳
ServerAliveInterval 30
# 若超过100次请求，都没有发送成功，则会主动断开与服务器端的连接。
ServerAliveCountMax 100
</code></pre>
<ul>
<li>服务器端定时向客户端发送心跳,修改服务器端 ssh配置 /etc/ssh/sshd_config</li>
</ul>
<pre><code class="language-bash">vim /etc/ssh/sshd_config
# 表示每隔多少秒，服务器端向客户端发送心跳
ClientAliveInterval 30
# 表示上述多少次心跳无响应之后，会认为Client已经断开
ClientAliveCountMax 6
</code></pre>
<h2 id="xargs命令行参数和标准输入"><a class="header" href="#xargs命令行参数和标准输入">xargs(命令行参数)和|(标准输入)</a></h2>
<hr />
<pre><code class="language-sh">#find标准输出为每行一个文件名

#直接通过管道转为grep的标准输入,则grep搜索标准输入包括protobuf的
#输出结果:文件名以.mod结束且包括protobuf
find . -name &quot;*.mod&quot; | grep protobuf

#管道转为xargs的标准输入,
#xargs把标准输入转化为grep的参数
#grep指定的文件名里内容包括protobuf的
#输出结果:文件名以.mod结束且文件内容包括protobuf
find . -name &quot;*.mod&quot; | xargs grep protobuf

# 搜索名字叫html目录
find . -type d -name 'html'
</code></pre>
<ul>
<li>管道(|)的作用是将前面命令的标准输出作为后面命令的标准输入</li>
<li>xargs将标准输入转成各种格式化的参数</li>
</ul>
<h2 id="常用命令-2"><a class="header" href="#常用命令-2">常用命令</a></h2>
<hr />
<pre><code class="language-sh">
set -v 回显命令，但不替换变量值
set -x 回显命名，替换变量值

# 用双引号处理带空格的文件
cp &quot;带空格的文件&quot; newfile

ls -l | grep &quot;^-&quot; | wc -l 当前目录下文件总数

# linux网络共享网盘nfs，/etc/exports文件增加一个共享目录

#产生ssh密钥对,注意-C大写,保存id_rsa文件名,ssh会默认读取,否则就要明确指出
#-b：指定密钥长度；-C：添加注释；-f：指定用来保存密钥的文件名；-t：指定要创建的密钥类型。
#现在很多地方都不支持rsa,建议采用ed25519/ecdsa
# -t [dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]
ssh-keygen -t rsa -C &quot;xxx@aliyun.com&quot; -f id_rsa
# 注意-t之后的空格,有可能提示不识别参数
ssh-keygen -t ed25519 -C &quot;xxx@aliyun.com&quot; -f id_ed25519

# 显示正在使用的shell
echo $SHELL

# 快速切换目录, vim .bashrc/.zshrc source .bashrc/.zshrc
export $CDPATH=.:~:/xxx/

#获取历史命令
#zsh
cat  $HOME/.zsh_history
#bsh
cat  $HOME/.bash_history

# 查看磁盘占用情况
df -h
#查看当前一级目录文件大小
du -h --max-depth=1

# 清空./var/journalctl日志
journalctl --vacuum-size=10M

# ls人性化阅读
ls -lh

# 复制到粘贴板
#windows
clip &lt; ~/.ssh/id_ed25519.pub
#mac
pbcopy &lt; ~/.ssh/id_ed25519.pub
#linux
xclip -sel clip &lt; ~/.ssh/id_ed25519.pub

# 获取脚本所在目录
dirname $0
cd `dirname $0`
pwd

# 获取home目录
echo $HOME


# 当前时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。
uptime

# 解决ssh超级慢(去除服务端利用dns反查客户端)
vi /etc/ssh/sshd_config
UseDNS no
GSSAPIAuthentication no

# 列出所有监听tcp端口程序
netstat -ltpn
#查看所有服务监听端口
netstat -a

# 监听tcp指定端口
tcpdump tcp port xxx

#查看网卡流量:每1秒 显示 1次 显示 10次
sar -n DEV 1 10

# 查看命令执行情况
set -V

#防火墙:
#查看是否打开端口:
firewall-cmd --list-all
#添加端口:
firewall-cmd --permanent --add-port=3000/tcp
#批量增加端口:
firewall-cmd --permanent --zone=public --add-port=7000-8000/tcp
#移除端口:
firewall-cmd --permanent --remove-port=7780/tcp
#重新加载规则生效
firewall-cmd --reload

#查找前20名占用内存较大:
ps aux | head -1;ps aux |grep -v PID |sort -rn -k +4 | head -20

# 建立软连接
ln -s 真实存在目录 软链接
</code></pre>
<h2 id="积累-2"><a class="header" href="#积累-2">积累</a></h2>
<pre><code class="language-sh"># 使用-j参数 不处理压缩文件中原来目录路径
zip -qj file.zip /xxx/xx/xx
</code></pre>
<h2 id="示例脚本"><a class="header" href="#示例脚本">示例脚本</a></h2>
<hr />
<ul>
<li>linux 普通用户实现sudo免密</li>
</ul>
<pre><code class="language-bash">vim /etc/sudoers.d
增加一个文件，添加以下内容
username ALL=(ALL) NOPASSWD:ALL
</code></pre>
<ul>
<li>利用git部署更新脚本</li>
</ul>
<pre><code class="language-bash">#!/usr/bin/env bash

cd ${gitdir}
# 批量杀死监控进程 shell脚本或专用管理程序
ps -ef|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9
# 批量杀死目标进程
ps -ef|grep yyy | grep -v grep | awk '{print $2}' | xargs kill -9
# 拉取最新程序
git pull
# 跑起监控进程
nohup ./xxx.sh &gt;/dev/null 2&gt;&amp;1 &amp;
</code></pre>
<ul>
<li>监控脚本</li>
</ul>
<pre><code class="language-bash">#!/usr/bin/env bash

while true
do
   # 查看目标进程还在不在
   procnum=` ps -ef|grep &quot;yyy$&quot;|grep -v grep|wc -l`
   if [ $procnum -eq 0 ]; then
     cd ${basedir}
     nohup ./yyy &gt;/dev/null 2&gt;&amp;1 &amp;
   fi

   # 延时30秒
   sleep 30
done
</code></pre>
<ul>
<li>编译脚本</li>
</ul>
<pre><code class="language-bash">#!/usr/bin/env bash
# 批量杀死目标进程
ps -ef|grep yyy | grep -v grep | awk '{print $2}' | xargs kill -9
hash=`git rev-parse --short HEAD`
rc=`date &quot;+%Y-%m-%d_%H:%M:%S&quot;`
target=yyy
go build -ldflags &quot;-s -w -X main.GitHash=${hash} -X main.CompileTime=${rc}&quot; -tags=jsoniter -o ${target} ${target}.go
chmod a+x ${target}
rundir=${target}_run
rm -rf ${rundir}
mkdir ${rundir}
mv ${target} ${rundir}
cp -r conf ${rundir}/
nohup ./${target} &gt;/dev/null 2&gt;&amp;1 &amp;
exit
</code></pre>
<ul>
<li>设置北京时间</li>
</ul>
<pre><code class="language-bash">sudo timedatectl set-timezone Asia/Shanghai
</code></pre>
<h3 id="常见包管理"><a class="header" href="#常见包管理">常见包管理</a></h3>
<ul>
<li>apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。</li>
<li>dnf 是 yum的升级版</li>
</ul>
<h3 id="显卡"><a class="header" href="#显卡">显卡</a></h3>
<pre><code class="language-bash">sudo lshw -numeric -C display显示显卡信息，lspci | grep -i vga
</code></pre>
<p><img src="webp/shell/vga.webp" alt="vga" /></p>
<h3 id="权限错误"><a class="header" href="#权限错误">权限错误</a></h3>
<pre><code class="language-bash"># Permissions 0644 for '/root/.ssh/id_ecdsa' are too open
# 降低权限
chmod 0600 ~/.ssh/id_ecdsa
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="wireshark"><a class="header" href="#wireshark">wireshark</a></h1>
<hr />
<h3 id="抓httpshttp2包"><a class="header" href="#抓httpshttp2包">抓https,http2包</a></h3>
<hr />
<ul>
<li>配置firefox</li>
</ul>
<pre><code class="language-sh">#设置环境变量,让firefox编入通讯密钥,调试完成后记得删除这个环境变量,它会影响速度和浪费空间
export SSLKEYLOGFILE=~/sslkeylog.log
#命令行启动,让firefox继承环境变量,也防止firefox后台运行,没有真正重启
/Applications/Firefox.app/Contents/MacOS/firefox-bin
</code></pre>
<ul>
<li>
<p>配置wireshark</p>
<ul>
<li>
<p>设置通讯密钥文件位置
<img src="webp/wireshark/masterkey_log.webp" alt="masterkey_log" /></p>
</li>
<li>
<p>设置显示域名,默认显ip
<img src="webp/wireshark/dns.webp" alt="dns" /></p>
</li>
</ul>
</li>
<li>
<p>firefox访问网址,wireshark抓包
<img src="webp/wireshark/catch.webp" alt="catch" /></p>
</li>
</ul>
<h3 id="显示过滤语法"><a class="header" href="#显示过滤语法">显示过滤语法</a></h3>
<hr />
<p><img src="webp/wireshark/show_filter.webp" alt="show_filter" /></p>
<pre><code class="language-sh"># 获取指定port包
tcp.port == 8411
tcp.port in {80, 443, 8080}

# 指定ip源或目的
ip.src == 192.168.0.1
ip.dst == 192.168.0.1

# 按长度
http.content_length &lt;=20
udp.length &lt; 30

# 按协议
http
http contains &quot;https://www.wireshark.org&quot;
http.request.method == &quot;POST&quot;
http.request.method in {&quot;HEAD&quot;, &quot;GET&quot;}

# 条件组合 and or
ip.src == 192.168.0.1 or ip.dst == 192.168.0.1
ip.dst eq www.mit.edu

</code></pre>
<h3 id="capture过滤语法"><a class="header" href="#capture过滤语法"><a href="https://www.wireshark.org/docs/wsug_html_chunked/ChCapCaptureFilterSection.html">capture过滤语法</a></a></h3>
<hr />
<ul>
<li>表达式规则</li>
</ul>
<pre><code class="language-sh">[not] primitive [and|or [not] primitive ...]
</code></pre>
<ul>
<li>
<p>primitive有几种形式</p>
<ul>
<li>[src|dst] host <host></li>
<li>ether [src|dst] host <ehost></li>
<li>gateway host <host></li>
<li>[src|dst] net <net> [{mask <mask>}|{len <len>}]</li>
<li>[tcp|udp] [src|dst] port <port></li>
<li>less|greater <length></li>
<li>ip|ether proto <protocol></li>
<li><expr> relop <expr></li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-sh">tcp port 23 and not src host 10.0.0.5
</code></pre>
<h3 id="小知识-1"><a class="header" href="#小知识-1">小知识</a></h3>
<hr />
<ul>
<li>局域网抓包可采用路由器<strong>镜像端口</strong></li>
<li>远程服务器抓包,远程抓包+rpcap,本机wireshark连接远程rpcap,则远程数据包转发到本机</li>
<li>wireshark支持lua扩展解释自定义协议</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="windows"><a class="header" href="#windows">windows</a></h1>
<hr />
<ul>
<li>
<p>win10运行linux命令</p>
<ul>
<li>系统设置——更新和安全——针对开发人员——选择开发者模式</li>
<li>搜索“程序和功能”，选择“开启或关闭Windows功能”,开启Windows Subsystem for Linux （Beta）,并重启系统</li>
<li>下载安装linux</li>
</ul>
</li>
<li>
<p>配置windows Terminal</p>
<ul>
<li><a href="https://moedev.net/nice-winterminal/">让终端更优雅</a></li>
<li><a href="https://scoop.sh/">windows版-brew</a></li>
<li><a href="https://withfig.typeform.com/linux">fig-更好体验</a></li>
<li><a href="https://chocolatey.org/install">windows版-brew2</a></li>
<li><a href="http://www.mingw.org">mingw-windows</a></li>
</ul>
</li>
<li>
<p>小知识</p>
<ul>
<li>power shell</li>
</ul>
<pre><code class="language-sh"># 十六进制显示文件
Format-Hex -Path ./fileName.xxx

# 文件浏览器打开当前目录
explorer .
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="elastic"><a class="header" href="#elastic">elastic</a></h1>
<hr />
<h3 id="官网-2"><a class="header" href="#官网-2"><a href="https://www.elastic.co/">官网</a></a></h3>
<ul>
<li><a href="https://github.com/zinclabs/zinc">zinc-golang版本替代品</a></li>
<li><a href="https://github.com/meilisearch/MeiliSearch">meili-rust版本替代品</a></li>
</ul>
<pre><code class="language-bash">docker run --name ms1.0 --restart always -p 9080:7700 -v $(pwd)/meili_data:/meili_data -d getmeili/meilisearch:v1.0
</code></pre>
<ul>
<li><a href="https://typesense.org/">typesense-c++版本替代品,纯内存</a></li>
</ul>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<ul>
<li>
<p>elasticsearch,基于Lucene(TM)的开源搜索引擎</p>
<pre><code class="language-sh">brew tap elastic/tap
brew install elastic/tap/elasticsearch-full
brew services start elasticsearch-full
curl -X GET http://localhost:9200/
# 查看安装的插件
curl -X GET http://localhost:9200/_cat/plugins
</code></pre>
<pre><code class="language-sh">docker pull docker.elastic.co/elasticsearch/elasticsearch:8.1.3
docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:8.1.3
</code></pre>
<ul>
<li>
<p>名词概念对比
| 关系数据库 | elasticsearch |
| -- | -- |
| 库 | 索引 |
| 表 | 类型 |
| 表模式 | 映射 |
| 行 | 文档 |
| 字段 | 字段 |</p>
<ul>
<li>支持类型
| 字段类型 |说明 |
| -- | -- |
| string | 字符串 |
| byte, short, integer, long | 数字 |
| float, double | 浮点 |
| boolean | 布尔 |
| date | 日期 |</li>
</ul>
</li>
<li>
<p>采用倒序存储,关键字 --》[文档1, 文档2, 文档3 ....],所以能快速搜索</p>
</li>
<li>
<p>插入的数据自动地创建类型(type)及其映射(mapping)</p>
</li>
<li>
<p>没有事务一致性,采用乐观版本,文档每更新一次，文档元数据中版本号就增加</p>
</li>
<li>
<p>传统数据库更关注数据一致性，永久存储等,在于操作数据,es则偏重于快速搜索</p>
</li>
<li>
<p>通常用数据库数据初始化es索引</p>
</li>
<li>
<p>索引别名理解及应用</p>
</li>
<li>
<p>默认端口9200</p>
</li>
<li>
<p>查询语法</p>
<ul>
<li>Leaf query clauses
<ul>
<li>
<p>match,全文搜索,支持text, number, date or boolean</p>
<pre><code class="language-js">GET /_search
{
    &quot;query&quot;: {
        &quot;match&quot;: {
        &quot;message&quot;: &quot;this is a test&quot;
        }
    }
}
</code></pre>
</li>
<li>
<p>term,精确相等,不要查询text字段</p>
<pre><code class="language-js">GET /_search
{
    &quot;query&quot;: {
        &quot;term&quot;: {
            &quot;user.id&quot;: {
                &quot;value&quot;: &quot;kimchy&quot;,
                &quot;boost&quot;: 1.0
            }
        }
    }
}
</code></pre>
</li>
<li>
<p>range</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>浏览器插件</p>
<ul>
<li>es-client-elasticsearch客户端</li>
<li>Elasticvue-elasticsearch客户端</li>
</ul>
</li>
<li>
<p>kibana</p>
<pre><code class="language-sh"># 注意和elasticsearch版本配对,否则跑不起来
curl -O https://artifacts.elastic.co/downloads/kibana/kibana-7.17.2-darwin-x86_64.tar.gz
curl https://artifacts.elastic.co/downloads/kibana/kibana-7.17.2-darwin-x86_64.tar.gz.sha512 | shasum -a 512 -c - 
tar -xzf kibana-7.17.2-darwin-x86_64.tar.gz
cd kibana-7.17.2-darwin-x86_64/
./bin/kibana
# 浏览器访问
http://localhost:5601/
</code></pre>
<p><img src="webp/elastic/kibana_dev.webp" alt="dev" />
<img src="webp/elastic/kibana_console.webp" alt="console" /></p>
</li>
<li>
<p>如果报内存不够,则删除monitoring索引</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jenkins"><a class="header" href="#jenkins">jenkins</a></h1>
<h2 id="动作"><a class="header" href="#动作">动作</a></h2>
<ul>
<li>重启-直接在地址后面加个 /restart</li>
</ul>
<pre><code class="language-bash">https://jenkins.xxx/restart
</code></pre>
<ul>
<li>退出-直接在地址后面加个/exit</li>
</ul>
<pre><code class="language-bash">https://jenkins.xxx/exit
</code></pre>
<ul>
<li>出现错误</li>
</ul>
<pre><code class="language-bash"># 一般是私钥的-----BEGIN OPENSSH PRIVATE KEY-----没有复制全
stderr: Load key &quot;/tmp/jenkins-gitclient-ssh7026290831916999837.key&quot;: invalid format 
</code></pre>
<ul>
<li>
<p>复制到远程主机</p>
<ul>
<li>安装publish-over-ssh插件</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="vim"><a class="header" href="#vim">vim</a></h1>
<hr />
<h3 id="常用命令-3"><a class="header" href="#常用命令-3">常用命令</a></h3>
<ul>
<li>ddp-交换上下行-光标在上行，其与下行交换</li>
<li>:$ 跳转到最后一行</li>
<li>:1 跳转到第一行</li>
</ul>
<h3 id="查找字符串"><a class="header" href="#查找字符串">查找字符串</a></h3>
<ul>
<li>/hello 查找光标处下一个&quot;hellp&quot; ,键入&quot;n&quot; 继续查找下一个,键入&quot;shift+n&quot;(大写N), 向上查找</li>
<li>?hello朝找光标处上一个&quot;hellp&quot; 键入&quot;n&quot; 继续查找上一个, 键入&quot;shift+n&quot;(大写N), 向下查找</li>
<li>/&lt;printf&gt; 精确搜索printf：&quot;&lt;“表示匹配单词开头，”&gt;“表示匹配单词末尾，需要加转义符&quot;&quot;</li>
</ul>
<h3 id="复制粘贴"><a class="header" href="#复制粘贴">复制粘贴</a></h3>
<ul>
<li>复制一行，我们只要把光标移动到想复制的那一行，按yy，就是两次y键，</li>
<li>粘贴，把光标移动到你想粘贴的那一行，按p键即可。</li>
<li>复制多行，把光标移动到想复制多行的开头，想要向下复制几行，就按nyy，比如我想从这一行开始复制5行，就按5yy</li>
</ul>
<h3 id="插件管理器-vim-plug"><a class="header" href="#插件管理器-vim-plug">插件管理器-vim-plug</a></h3>
<ul>
<li>
<p>vim-plug 是 vim 下的插件管理器, 可以帮我们统一管理后续的所有插件, 后续的安装插件全部由此工具完成
类似的插件管理工具还有 Vundle, 相较而言 vim-plug 支持异步且效率非常高, 具体选择交由读者自己</p>
</li>
<li>
<p>安装</p>
</li>
</ul>
<pre><code class="language-bash">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre>
<ul>
<li>配置声明</li>
</ul>
<pre><code class="language-bash">
vim .vimrc

:set term=builtin_ansi
:set encoding=utf-8
:set nocompatible
:set nu
:set hlsearch
:syn on
call plug#begin()
Plug 'preservim/nerdtree'
Plug 'jiangmiao/auto-pairs'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'morhetz/gruvbox'
Plug 'frazrepo/vim-rainbow'
Plug 'chiel92/vim-autoformat'
Plug 'vim-scripts/bash-support.vim'
Plug 'zaach/jsonlint'
Plug 'plasticboy/vim-markdown'
Plug 'ambv/black'
Plug 'fatih/vim-go'
Plug 'sheerun/vim-polyglot'
Plug 'ekalinin/Dockerfile.vim'
call plug#end()
</code></pre>
<ul>
<li>激活安装-相应插件</li>
</ul>
<pre><code class="language-bash">$ vim        #打开vim
:PlugStatus  #查看插件状态
:PlugInstall #安装之前在配置文件中声明的插件
</code></pre>
<ul>
<li><a href="https://vimawesome.com/">优秀插件网站</a>(<a href="https://github.com/vim-awesome/vim-awesome">https://github.com/vim-awesome/vim-awesome</a>)</li>
</ul>
<pre><code class="language-bash">机器上/.vimrc 修改无法显示中文及方向键不能移动光标
 :set term=builtin_ansi
 :set encoding=utf-8
 :set nocompatible
 修改~/.bashrc 打开force_color_prompt=yes
</code></pre>
<ul>
<li>右键不能复制</li>
</ul>
<pre><code class="language-bash">vim set mouse-=a屏蔽了鼠标右健功能.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="makefile"><a class="header" href="#makefile">makefile</a></h1>
<hr />
<h3 id="常见编译变量参数"><a class="header" href="#常见编译变量参数">常见编译变量参数</a></h3>
<pre><code class="language-bash">SHELL := /usr/bin/env bash -o pipefail

GIT_VERSION ?= $(shell git describe --always --tags --match 'v*' --dirty)
COMMIT     ?= $(shell git rev-parse HEAD)
BRANCH     ?= $(shell git rev-parse --abbrev-ref HEAD)
BUILD_DATE ?= $(shell date +%s)
BUILD_HOST ?= $(shell hostname)
BUILD_USER ?= $(shell id -un)
</code></pre>
<h3 id="变量不同赋值区别"><a class="header" href="#变量不同赋值区别">变量不同赋值区别</a></h3>
<pre><code class="language-bash">= 是最基本的赋值
:= 是覆盖之前的值
?= 是如果没有被赋值过就赋予等号后面的值
+= 是添加等号后面的值
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="github"><a class="header" href="#github">github</a></h1>
<hr />
<h3 id="重要提示"><a class="header" href="#重要提示">重要提示</a></h3>
<ul>
<li><a href="https://about.gitlab.com/">替代品-gitlab</a></li>
<li><a href="https://www.githubs.cn/">中文社区-github</a></li>
<li><a href="https://ossinsight.io/">ossinsight-</a></li>
<li><a href="https://docs.github.com/">api文档-github</a></li>
</ul>
<h3 id="解决访问超慢"><a class="header" href="#解决访问超慢">解决访问超慢</a></h3>
<hr />
<ol>
<li>
<p><a href="https://www.ipaddress.com/">ip address.com</a>查域名
<img src="webp/github/ipaddress.webp" alt="ip address" /></p>
</li>
<li>
<p>修改/etc/hosts</p>
<pre><code class="language-sh">140.82.113.21 collector.Github.com
140.82.113.5 api.github.com
140.82.114.4 github.com
140.82.113.4 github.com
185.199.108.154 github.githubassets.com
185.199.109.154 github.githubassets.com
185.199.110.154 github.githubassets.com
185.199.111.154 github.githubassets.com
185.199.110.153 assets-cdn.github.com
185.199.111.153 assets-cdn.github.com
185.199.108.153 assets-cdn.github.com
199.232.69.194 github.global.ssl.fastly.net
</code></pre>
</li>
<li>
<p>原因是国内dns解析相应域名都是到新加坡,有时候访问不了</p>
</li>
<li>
<p><a href="https://github.com/dotnetcore/FastGithub">FastGithub</a>github加速神器</p>
</li>
</ol>
<ul>
<li>
<p>osx-arm64版本会直接被杀死,改用osx-x86</p>
<pre><code class="language-sh">   [1]    9226 killed     ./fastgithub

   # 丢掉烦人的输出，并且后台运行
   ./fastgithub &gt; /dev/null &amp;
   godoc -http=:6060 &amp;
</code></pre>
</li>
<li>
<p><a href="https://github.com/dotnetcore/FastGithub/blob/master/MacOSXConfig.md">MacOSx配置</a></p>
</li>
<li>
<p>最新版firefox替换证书, 证书-查看证书-颁发机构-导入cer证书,否则报错</p>
</li>
<li>
<p>设置系统自动代理为<code>http://127.0.0.1:38457</code>，或手动代理http/https为<code>127.0.0.1:38457</code></p>
</li>
</ul>
<h3 id="pages服务"><a class="header" href="#pages服务">pages服务</a></h3>
<hr />
<ol>
<li>
<p>User/Organization Pages 个人或公司站点</p>
<ol>
<li>创建username.github.io仓库</li>
<li>仓库设置自定义域名,项目下面会自动增加CNAME文件</li>
<li>域名解析增加相应的CNAME记录</li>
</ol>
</li>
<li>
<p>Project Pages 项目站点</p>
<ol>
<li>gh-pages分支用于构建和发布；</li>
<li>如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名；
如果没有使用独立域名，project pages将通过子路径的形式提供服务<a href="http://username.github.com/projectname">http://username.github.com/projectname</a>；</li>
</ol>
</li>
</ol>
<h3 id="自定义github主页"><a class="header" href="#自定义github主页">自定义github主页</a></h3>
<ol>
<li>
<p>新建一个同名仓库</p>
<blockquote>
<p>官方提示：.... is a special repository. Its README.md will appear on your public profile!</p>
</blockquote>
</li>
<li>
<p>编辑该仓库的 README.md 文件</p>
</li>
</ol>
<h3 id="官方工具"><a class="header" href="#官方工具">官方工具</a></h3>
<ul>
<li><a href="https://desktop.github.com/">GitHub Desktop</a></li>
<li><a href="https://cli.github.com/">GitHub CLI</a></li>
</ul>
<h3 id="名词"><a class="header" href="#名词">名词</a></h3>
<ul>
<li>
<p>Sponsor：打赏</p>
</li>
<li>
<p>Watch：如有更新，通知提醒。</p>
</li>
<li>
<p>Fork：分支一份到你的仓库。</p>
</li>
<li>
<p>Code：默认页面，通常会有一个 README.md 文件，用于介绍该项目。</p>
</li>
<li>
<p>Pull requests：请求代码合并，如果你想为项目贡献代码，可以在这里提交。</p>
</li>
<li>
<p>Actions：工作流。</p>
<blockquote>
<p>大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。
很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。
如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。
GitHub 会监控到，然后分配一台虚拟机先将你的项目 checkout 过去，然后按照你指定的 step 顺序执行定义好的 action</p>
</blockquote>
</li>
<li>
<p>Projects：项目管理</p>
</li>
<li>
<p>Security：安全评估</p>
</li>
<li>
<p>Wiki：说明文档</p>
</li>
<li>
<p>Insights：数据统计</p>
</li>
<li>
<p>codespaces 类似web IDE，省去环境配置环节，云端开发</p>
</li>
<li>
<p>高级搜索 例如包括nginx的pdf书 nginx extension:pdf</p>
</li>
</ul>
<h3 id="配套网站-netlify"><a class="header" href="#配套网站-netlify">配套网站-<a href="https://app.netlify.com/">Netlify</a></a></h3>
<ul>
<li>用最快的方法构建最快的网站</li>
</ul>
<blockquote>
<p>当使用 Github 将网站项目文件夹里的所有东西上传完毕之后，那么就可以打开 Netlify 给予它访问 Github 仓库的权限。
当 Netlify 读取完你的网站所属仓库时，会自动识别你所用的静态网页生成器的程序，然后只要点击部署并发布，你的网站就会在 Netlify 被构建并且被发布.</p>
</blockquote>
<ul>
<li>
<p>能够托管服务，免费 CDN</p>
</li>
<li>
<p>能够绑定自定义域名</p>
</li>
<li>
<p>能够启用免费的TLS证书，启用HTTPS</p>
</li>
<li>
<p>支持自动构建</p>
</li>
<li>
<p>提供 Webhooks 和 API</p>
</li>
<li>
<p><a href="https://hellogithub.com/">开源有趣项目-介绍</a></p>
</li>
<li>
<p><a href="https://www.githubs.cn/">github-中文社区</a></p>
</li>
</ul>
<h3 id="多个帐号多个ssh"><a class="header" href="#多个帐号多个ssh">多个帐号，多个ssh</a></h3>
<pre><code class="language-bash"># ~/.ssh/config配置

Host github3
   HostName github.com
   PreferredAuthentications publickey
   IdentityFile ~/.ssh/id_rsa

Host github2
   HostName github.com
   PreferredAuthentications publickey
   IdentityFile ~/.ssh/id_ecdsa

# 修改远程地址
# git@github.com:xxx/yyy -&gt; git@github3:xxx/yyy
# git@github.com:xxx/yyy -&gt; git@github2:xxx/yyy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="firefox"><a class="header" href="#firefox">firefox</a></h1>
<hr />
<ul>
<li>
<p>扩展组件</p>
<ul>
<li>实际上zip压缩后,直接改后缀名xpi</li>
<li>注意不能直接压缩整个目录,应该是选择文件压缩,否则认为损坏.估计压缩比解压多一级目录.</li>
<li>现代firefox一般要求认证,扩展组件开发者,否则不能安装与运行</li>
</ul>
</li>
<li>
<p>&quot;此附件组件无法安装，未通过验证&quot;</p>
<ul>
<li>打开Firefox浏览器</li>
<li>地址栏输入“about:config”</li>
<li>搜索“xpinstall.signatures.required”设置项，双击改为“false”，重启</li>
<li>再把xpi拖进Firefox窗口便会提示是否安装</li>
</ul>
</li>
<li>
<p>优秀插件</p>
<ul>
<li>Dark Reader-<strong>推荐使用</strong>,把网站改成暗黑主题,少数网站表现不好</li>
<li>uBlock Origin-<strong>推荐使用</strong>去广告</li>
<li>sourcegraph-<strong>推荐使用</strong>浏览器享受ide级别待遇</li>
<li>savetopdf-自动把网页转化为pdf</li>
<li>es-client-elasticsearch客户端</li>
<li>Elasticvue-elasticsearch客户端</li>
<li>autocopy-自动复制选中内容</li>
<li>探索者小舒--一键切换多个搜索引擎</li>
<li>Vue.js devtools-vue.js开发助手</li>
<li>jsonview-在浏览器中查看JSON 文件</li>
<li>Postwoman中文版-优秀Api测试插件</li>
<li>monknow新标签页,美观且允许高度自定义的新标签页扩展插件</li>
<li>chrome://flags/#enable-force-dark 自带暗黑模式</li>
</ul>
</li>
<li>
<p>开发者模式-禁止网页跳转自动清除日志</p>
<ul>
<li>禁止页面跳过自动清除log
<img src="webp/firefox/firefox-log.webp" alt="firefox-log" title="firefox-log" />
<img src="webp/firefox/chrome-log.webp" alt="chrome-log" title="chrome-log" /></li>
</ul>
</li>
<li>
<p>lighthouse-chrome出品网站优化建议报告,dev-tools自带，方便又快捷</p>
<ul>
<li><img src="webp/firefox/lighthouse-start.webp" alt="lighthouse-start" title="lighthouse-start" /></li>
<li><img src="webp/firefox/lighthouse-report.webp" alt="lighthouse-report" title="lighthouse-report" /></li>
</ul>
</li>
<li>
<p>firefox开发者专用版,获取最新的开发者工具,帮助调试很多问题</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN-前端开发必备</a></p>
<ul>
<li>MDN-Mozilla开发者社区（MDN）是一个完整的学习平台</li>
<li>临时加载的脚本扩展，必须用cmd+shift+j调出浏览器控制台,设置&quot;显示消息内容&quot;,才能看到日志,</li>
<li>PWA（Progressive Web App）-渐进式Web应用,利用缓存+在线网站构建本地应用</li>
</ul>
</li>
<li>
<p>WebDriver是远程控制接口，可以对用户代理进行控制。它提供了一个平台和语言中性线协议，作为进程外程序远程指导web浏览器行为的方法.</p>
</li>
<li>
<p>有空实现插件</p>
<ul>
<li>浏览器扩展 类似go search,python search</li>
<li>浏览器扩展 把github有关hg项目生成pdf</li>
<li>dial,类似monknow</li>
<li>批量html转化成pdf</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="flutter"><a class="header" href="#flutter">flutter</a></h1>
<hr />
<h3 id="中文官网"><a class="header" href="#中文官网"><a href="https://flutter.cn">中文官网</a></a></h3>
<h3 id="常用命令-4"><a class="header" href="#常用命令-4">常用命令</a></h3>
<pre><code class="language-bash"># 检查环境
flutter doctor

# 创建新工程
flutter create xxx

# 调试运行
flutter run

# 生成apk,默认release,上线应用市场需要签名,个人使用可以直接生成
flutter build apk

# 插上数据线，连上手机，手机打开调试选项,直接安装
flutter install

# 生成不同的ios应用,默认生成apple store,否则就指定用途
# 没有订阅会费，无法生成上架及ad-hoc,只能生成 development
flutter build ipa --export-method ad-hoc、--export-method development 和 --export-method enterprise。

flutter build ipa --export-method development

# 应用程序支持的最低 macOS 版本。Flutter 支持 macOS 10.11 及更高版本。Deployment Target（部署目标）需要注意.
flutter build macos

# 出现类似下面提示，可能是xcode版本或m1芯片造成,仍然可以正常打包
# --- xcodebuild: WARNING: Using the first of multiple matching destinations:
# { platform:macOS, arch:arm64, id:xxxxx }
# { platform:macOS, arch:x86_64, id:xxxx }

# cd project/build/web
# python3 -m http.server 8000
flutter build web

# linux仅限linux主机支持
flutter build linux

# windows仅限windows主机支持
flutter build windows
</code></pre>
<h3 id="中国特定的环境变量否则doctor失败"><a class="header" href="#中国特定的环境变量否则doctor失败">中国特定的环境变量,否则doctor失败</a></h3>
<pre><code class="language-bash">vim .zshrc
vim .bashrc
export CHROME_EXECUTABLE=/Applications/Chromium.app/Contents/MacOS/Chromium
export PUB_HOSTED_URL=https://pub.flutter-io.cn
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
</code></pre>
<h3 id="本地跑起flutter官网"><a class="header" href="#本地跑起flutter官网">本地跑起flutter官网</a></h3>
<pre><code class="language-bash">cd git-code/github/flutter-website
# make up,如果不能,就先启动docker
./local.sh
</code></pre>
<h3 id="知名扩展库"><a class="header" href="#知名扩展库">知名扩展库</a></h3>
<ul>
<li>
<p><a href="https://github.com/flutter/samples">samples-flutter官方示例</a></p>
</li>
<li>
<p><a href="https://fair.58.com/">Fair-界面动态化</a></p>
</li>
<li>
<p><a href="https://bruno.ke.com/">bruno-组件开源</a></p>
</li>
<li>
<p><a href="https://bruno.ke.com/">AppFlowy-开源笔记</a></p>
</li>
</ul>
<h3 id="bundle和apk区别"><a class="header" href="#bundle和apk区别">Bundle和apk区别</a></h3>
<blockquote>
<p>Bundle是google推出一种文件格式,帮助下载时动态产生apk,以节省不必要的浪费.Google Play就是基于对aab文件处理，将App Bundle在多个维度进行拆分，在资源维度，ABI维度和Language维度进行了拆分，你只要按需组装你的Apk然后安装即可。如果你的手机是一个x86，xhdpi的手机，你在google play应用市场下载apk时，gogle play会获取手机的信息，然后根据App Bundle会帮你拼装好一个apk，这个apk的资源只有xhdpi的，而且so库只有x86，其他无关的都会剔除。从而减少了apk的大小。</p>
</blockquote>
<h3 id="xcode无线调试真机同局域内"><a class="header" href="#xcode无线调试真机同局域内">xcode无线调试真机(同局域内)</a></h3>
<ul>
<li>
<p>手机采用数据线连接上Xcode，打开Xcode菜单：Windows-&gt;Device and Simulators。找到连接上的设备，把Connect via network选项打勾.</p>
</li>
<li>
<p>之后Xcode将会转一会圈圈，耐心等待一会就成功了，此时拔掉数据线，可以看到左侧的设备连接列表上手机仍在列表中</p>
</li>
<li>
<p>运行我们的项目，在设备列表中不出意外会看到我们的无线连接的手机。选择手机后运行</p>
</li>
<li>
<p>不出意外的话，此时是跑不起来的。还需要最后一步，回到刚刚的设备列表中，选中手机右键，在出来的选项卡中选择一个Connect via IP Address项。选择之后输入手机的局域网ip地址。</p>
</li>
<li>
<p>完成后可以看到在连接的手机右边有一个地球连接标志.</p>
</li>
<li>
<p>以后项目运行，在下拉列表如果手机在局域网中也会有这个标志</p>
</li>
<li>
<p>最后一步，选择后直接运行，不出意外的话，项目无需数据线就跑起来了</p>
</li>
<li>
<p>此方法是支持无线调试的，连一次以后就不需要数据线了了</p>
</li>
</ul>
<h3 id="苹果帐户添加设备uuid"><a class="header" href="#苹果帐户添加设备uuid">苹果帐户添加设备uuid</a></h3>
<ul>
<li>
<p>打开<a href="https://developer.apple.com/">https://developer.apple.com/</a> 登录你的苹果开发者账号,交过钱才能看到界面</p>
</li>
<li>
<p>登进去之后点击Certificates, Identifiers &amp; Profiles</p>
</li>
<li>
<p>左侧点击Devices，可以看到现在账号里面注册的设备，再点击+号新增设备</p>
</li>
<li>
<p>填写设备的名字（这个自己随便写就好了，方便你知道是谁的什么设备就行）还有设备的UDID，完成后点击Continue</p>
</li>
<li>
<p>然后会让你再次确认信息，看你填写是否正确，下面显示的是该账号最多可以添加的测试设备数目和剩余可添加设备的数目。信息无误，点击Register下一步。再点击done完成注册，跳转回Devices页面，就可以看到我们新添加的设备了。如果是做app开发，需要重新打包之后，新设备才能进行测试</p>
</li>
<li>
<p>平时打<strong>adhoc</strong>，不用打store包</p>
</li>
<li>
<p>iphone6 plus的uuid 0da336454935d7d38373cbd54a403cad888ba845</p>
</li>
</ul>
<h3 id="xcode查看uuid"><a class="header" href="#xcode查看uuid">xcode查看uuid</a></h3>
<ul>
<li>
<p>iphone数据线连接MAC</p>
</li>
<li>
<p>打开Xcode</p>
</li>
<li>
<p>点击Window----&gt;Devices and Simulators---&gt;在右侧可查看到identifier</p>
</li>
<li>
<p>identifier即为我们获取到的iPhone 的UDID</p>
</li>
</ul>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<ul>
<li>
<p><a href="https://www.jianshu.com/p/8c99cb119bb3">xcode真机调试</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/19ed6b2ea8a1">xcode真机安装ipa</a></p>
</li>
</ul>
<p><img src="webp/flutter/xcode_ipa_1.webp" alt="第一步" /></p>
<p><img src="webp/flutter/xcode_ipa_2.webp" alt="第二步" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="tesseract"><a class="header" href="#tesseract">tesseract</a></h1>
<hr />
<h3 id="安装-1"><a class="header" href="#安装-1">安装</a></h3>
<pre><code class="language-sh"># 多半已安装过了,最新版本为5.xx
brew install tesseract

# This formula contains only the &quot;eng&quot;, &quot;osd&quot;, and &quot;snum&quot; language data files.
# If you need any other supported languages, run `brew install tesseract-lang`

# 本质是下载github所有训练完好的模型数据,放在/opt/homebrew/share/tessdata,供tesseract调用
brew install tesseract-lang
</code></pre>
<h3 id="使用-1"><a class="header" href="#使用-1">使用</a></h3>
<pre><code class="language-bash"># 获取帮助
tesseract --help-extra

# 告诉tesseract 源文件chinese.png -l 表示中文 stdout输出到标准库
tesseract chinese.png stdout -l chi_sim

# 类似数字识别
tesseract digit.png stdout -l snum

# 类似英文识别
tesseract english.png stdout -l eng

# 单行文本识别率非常不错,多行错误率非常高
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="harbor"><a class="header" href="#harbor">harbor</a></h1>
<hr />
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<ul>
<li>
<p><a href="https://goharbor.io/">官网</a> <a href="https://github.com/goharbor/harbor">github</a></p>
</li>
<li>
<p>Harbor是VMware公司开源的企业级Docker Registry项目，其目标是帮助用户迅速搭建一个企业级的Docker Registry服务</p>
</li>
<li>
<p>Harbor以 Docker 公司开源的Registry 为基础，提供了图形管理UI、基于角色的访问控制(Role Based AccessControl)、AD/LDAP集成、以及审计日志(Auditlogging)等企业用户需求的功能，同时还原生支持中文</p>
</li>
<li>
<p>Harbor的每个组件都是以Docker 容器的形式构建的，使用docker-compose 来对它进行部署。用于部署Harbor 的docker- compose模板位于harbor/ docker- compose.yml</p>
</li>
<li>
<p>linux至少4核/8G</p>
</li>
</ul>
<p><img src="webp/harbor/harbor-1.webp" alt="harbor组件图" />
<img src="webp/harbor/harbor-2.webp" alt="harbor说明" /></p>
<pre><code class="language-bash"># 下载离线安装包
~/Downloads/harbor-offline-installer-v1.10.11.tgz
</code></pre>
<h3 id="最好在linux机器上"><a class="header" href="#最好在linux机器上">最好在linux机器上</a></h3>
<pre><code class="language-bash"># mac机器出现
ERROR: for portal  Cannot start service portal: failed to initialize logging driver: dial tcp 127.0.0.1:1514: connect: connection refused
ERROR: Encountered errors while bringing up the project.
</code></pre>
<h3 id="docker-compose脚本转发命令"><a class="header" href="#docker-compose脚本转发命令">docker-compose脚本转发命令</a></h3>
<ul>
<li>docker compose自带,不必另外按装.</li>
<li>harbor需要启动docker-compose相关依赖,所以需要一个转发</li>
</ul>
<pre><code class="language-bash">vim docker-compose
#!/bin/bash
docker compose $*
</code></pre>
<h3 id="修改commonsh"><a class="header" href="#修改commonsh">修改common.sh</a></h3>
<pre><code class="language-bash"># 注释掉dockercompose检查
function check_dockercompose {
 return
 ....
}
</code></pre>
<h3 id="修改配置-1"><a class="header" href="#修改配置-1">修改配置</a></h3>
<pre><code class="language-yml"># The IP address or hostname to access admin UI and registry service.
# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.
hostname: 修改自定义ip或域名

# 根据自已需求来配置http/https
# http related config
http:
  # port for http, default is 80. If https enabled, this port will redirect to https port
  port: 80

# https related config
#https:
  # https port for harbor, default is 443
#  port: 443
  # The path of cert and key files for nginx
#  certificate: /your/certificate/path
#  private_key: /your/private/key/path
</code></pre>
<h3 id="免费制品管理-nexushttpswwwsonatypecomproductsrepository-oss-download"><a class="header" href="#免费制品管理-nexushttpswwwsonatypecomproductsrepository-oss-download">[免费制品管理-nexus]https://www.sonatype.com/products/repository-oss-download</a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="gitlab"><a class="header" href="#gitlab">gitlab</a></h1>
<hr />
<h3 id="安装私有部署内存最低2gb机器配置越高越好否则会有各种问题"><a class="header" href="#安装私有部署内存最低2gb机器配置越高越好否则会有各种问题">安装私有部署(内存最低2GB,机器配置越高越好,否则会有各种问题)</a></h3>
<pre><code class="language-bash"># 下载安装docker
curl -fsSL &lt;https://get.docker.com&gt; | bash -s docker --mirror Aliyun

# 启动docker
systemctl start docker

# 创建gitlab home
mkdir /srv/gitlab
# 导出环境变量 vim .bash_profile
export GITLAB_HOME=/srv/gitlab

# docker跑起来,采用社区版,自带常见服务足够了
docker run --detach \
  --hostname gitlab.example.com \
  --publish 443:443 --publish 80:80 --publish 8090:22 \
  --name gitlab \
  --restart always \
  --volume $GITLAB_HOME/config:/etc/gitlab \
  --volume $GITLAB_HOME/logs:/var/log/gitlab \
  --volume $GITLAB_HOME/data:/var/opt/gitlab \
  --shm-size 256m \
  registry.gitlab.cn/omnibus/gitlab-jh:latest

# 初始化过程可能需要很长时间。 您可以通过以下方式跟踪此过程,查看日志
docker logs -f gitlab

# 获取默认初始化密码,用户名是root
docker exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password
</code></pre>
<p><a href="https://docs.gitlab.cn/jh/install/docker.html">官方安装说明</a></p>
<pre><code class="language-bash"># 安装sourcegraph
docker run --detach \
    --publish 8091:7080 \
    --publish 127.0.0.1:3370:3370 \
    --rm --volume ~/.sourcegraph/config:/etc/sourcegraph \
    --volume ~/.sourcegraph/data:/var/opt/sourcegraph sourcegraph/server:3.40.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="地理编码"><a class="header" href="#地理编码">地理编码</a></h1>
<hr />
<h2 id="地理编码-1"><a class="header" href="#地理编码-1">地理编码</a></h2>
<blockquote>
<p>地理编码是指将地址或地名等位置描述转换为经纬度坐标的过程.</p>
<p>出于国家安全考虑，公布出来的坐标信息一般是经过加偏的.</p>
</blockquote>
<h2 id="逆地理编码"><a class="header" href="#逆地理编码">逆地理编码</a></h2>
<blockquote>
<p>逆地理编码可将经纬度坐标转换为详细,标准的地址信息.</p>
</blockquote>
<h2 id="常用接口"><a class="header" href="#常用接口">常用接口</a></h2>
<ol>
<li>
<p><a href="https://lbs.amap.com/api/webservice/guide/api/georegeo/">高德地图开放平台</a></p>
</li>
<li>
<p><a href="http://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding-abroad">百度地图开放平台</a></p>
</li>
<li>
<p><a href="https://developers.google.cn/maps/documentation/geocoding/start?hl=zh-cn#Limits">google中国</a></p>
</li>
<li>
<p><a href="https://market.aliyun.com/products/57002002/cmapi020535.html#sku=yuncode1453500000">阿里云-云市场</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="hugo"><a class="header" href="#hugo">hugo</a></h1>
<hr />
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<ul>
<li>Hugo是由Go语言实现的静态网站生成器 <a href="https://gohugo.io">官网</a></li>
<li>用户编辑内容文件,主题插件提供显示方式,hugo利用两者生成纯静态网站</li>
<li>Hugo靠shortcode扩展</li>
<li>用最新的mermaid.js替换Hugo-theme-learn主题自带的mermaid.js,可获取最新mermaid功能</li>
<li>config.toml中&quot;home = [&quot;HTML&quot;, &quot;RSS&quot;, &quot;JSON&quot;]&quot;,会产生index.json索引，不要删除</li>
</ul>
<h2 id="本地运行官网"><a class="header" href="#本地运行官网">本地运行官网</a></h2>
<pre><code class="language-sh">
git clone https://github.com/gohugoio/hugoDocs.git

cd hugoDocs

hugo -D server

</code></pre>
<blockquote>
<p>默认访问<a href="http://localhost:1313/">http://localhost:1313/</a></p>
<p>出现类似下面报错,hugoDocs中的config.toml增加timeout = 100000000000,单位ms</p>
<p>timeout默认值过短,原因为hugo生成网站时间超出默认配置</p>
</blockquote>
<pre><code class="language-sh">
Error building site: &quot;.../hugoDocs/content/en/troubleshooting/faq.md:1:1&quot;: timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file.

</code></pre>
<h2 id="优秀的主题网站httpswowchemycom"><a class="header" href="#优秀的主题网站httpswowchemycom">优秀的主题网站(<a href="https://wowchemy.com/">https://wowchemy.com/</a>)</a></h2>
<h2 id="替代品-jekyll"><a class="header" href="#替代品-jekyll">替代品-jekyll</a></h2>
<ul>
<li>
<p>官网(<a href="http://jekyllcn.com/">http://jekyllcn.com/</a>)</p>
</li>
<li>
<p>中文官网(<a href="http://jekyllcn.com/">http://jekyllcn.com/</a>)</p>
</li>
<li>
<p>mac自带的ruby,gem安装权限问题-示例<a href="https://segmentfault.com/a/1190000023872147">本地运行fyne官网</a></p>
</li>
</ul>
<pre><code class="language-bash">ERROR:  While executing gem ... (Gem::FilePermissionError)
You don't have write permissions for the /usr/bin directory.
</code></pre>
<ul>
<li>
<p>sudo gem install fastlane,采用sudo</p>
</li>
<li>
<p>gem install fastlane --user-install, 采用用户级别安装</p>
</li>
<li>
<p>sudo gem install -n /usr/local/bin fastlane,同时指时路径</p>
</li>
<li>
<p>bundle exec jekyll serve-如果出错</p>
</li>
<li>
<p>常用参数</p>
</li>
</ul>
<pre><code class="language-bash"># -w 表示监控文件变化及时生成网站
# --incremental 增量构建
# 启动过程会有点慢,需要等待一会儿
jekyll serve -w --port=4001 
</code></pre>
<ul>
<li>github项目中，如果只有__config.yml,没有Gemfile,则可能手动添加,方便本地跑起来</li>
</ul>
<pre><code class="language-yml">gem 'github-pages', group: :jekyll_plugins
</code></pre>
<h3 id="ruby-version-manager-rvm-httpsrvmio"><a class="header" href="#ruby-version-manager-rvm-httpsrvmio">Ruby Version Manager-RVM (<a href="https://rvm.io/">https://rvm.io/</a>)</a></h3>
<pre><code class="language-bash">curl -sSL https://get.rvm.io | bash -s stable
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="svn"><a class="header" href="#svn">svn</a></h1>
<hr />
<h2 id="svn命令"><a class="header" href="#svn命令">svn命令</a></h2>
<ol>
<li>下载</li>
</ol>
<pre><code class="language-bash">svn checkout svn://host/svn/IOS/remote_dir (svn项目全路径）project_dir（本地目录全路径) --username 用户名 --password 密码
</code></pre>
<blockquote>
<p>svn checkout 简写：svn co</p>
</blockquote>
<ol start="2">
<li>添加新文件</li>
</ol>
<pre><code class="language-bash">svn add file（文件名）
svn add *.php(添加当前目录下所有的php文件)
</code></pre>
<ol start="3">
<li>提交到版本库</li>
</ol>
<pre><code class="language-bash">svn commit -m &quot;LogMessage&quot; PATH
svn commit -m “提交当前目录下的全部在版本控制下的文件“ * （ *表示全部文件 ）
</code></pre>
<blockquote>
<p>svn commit 简写：svn ci</p>
</blockquote>
<ol start="4">
<li>更新文件</li>
</ol>
<pre><code class="language-bash">svn　update
svn　update　文件名
</code></pre>
<blockquote>
<p>提交的时候提示过期冲突，需要先 update 修改文件</p>
<p>然后清除svn resolved，最后再提交commit。</p>
<p>svn　update 间写： svn up</p>
</blockquote>
<ol start="5">
<li>查看文件或者目录状态</li>
</ol>
<pre><code class="language-bash">svn status [-v] path（目录下的文件和子目录的状态，正常状态不显示）
</code></pre>
<blockquote>
<p>?：不在svn的控制中；</p>
<p>M：内容被修改；</p>
<p>C：发生冲突；</p>
<p>A：预定加入到版本库；</p>
<p>K：被锁定</p>
<p>D:文件、目录或是符号链item预定从版本库中删除。</p>
<p>I:忽略</p>
<p>svn status 简写：svn st</p>
</blockquote>
<ol start="6">
<li>查看日志（显示文件的所有修改记录，及其版本号的变化）</li>
</ol>
<pre><code class="language-bash"># 查看最近3条日志
svn log [path] -l 3 
</code></pre>
<ol start="7">
<li>解决冲突</li>
</ol>
<pre><code class="language-bash"># 手工解决冲突后,移除工作副本的目录或文件的“冲突”状态,再提交
svn resolved PATH
</code></pre>
<ol start="8">
<li>删除文件</li>
</ol>
<pre><code class="language-bash"># 本地先删,再提交
svn delete test.php 
svn ci -m 'delete test file‘
</code></pre>
<ol start="9">
<li>恢复本地修改</li>
</ol>
<pre><code class="language-bash"># 用法: revert PATH...
svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。
</code></pre>
<blockquote>
<p>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录</p>
</blockquote>
<pre><code class="language-bash"># 丢弃对一个文件的修改
svn revert foo.c
# 恢复一整个目录的文件，. 为当前目录
svn revert --recursive . 
</code></pre>
<ol start="10">
<li>版本库下的文件和目录列表</li>
</ol>
<pre><code class="language-bash">svn list [path]
</code></pre>
<ol start="11">
<li>忽略目录</li>
</ol>
<pre><code class="language-bash"># 注意没有目录斜杠
svn propset svn:ignore .idea .
</code></pre>
<ol start="12">
<li>查看文件详细信息</li>
</ol>
<pre><code class="language-bash"># svn info path
svn info test.php
</code></pre>
<ol start="13">
<li>比较差异</li>
</ol>
<pre><code class="language-bash"># svn diff path(将修改的文件与基础版本比较)
svn diff test.php

# svn diff -r m:n path(对版本m和版本n比较差异)
svn diff -r 200:201 test.php
</code></pre>
<blockquote>
<p>svn diff 简写：svn di</p>
</blockquote>
<ol start="14">
<li>SVN 帮助</li>
</ol>
<pre><code class="language-bash">svn help 全部功能选项
svn help ci 具体功能的说明
</code></pre>
<ol start="15">
<li>上传</li>
</ol>
<pre><code class="language-bash">svn import project_dir（本地项目全路径） http://host/svn/IOS/Ben/remote_dir（svn项目全路径） -m &quot;必填, 不填此命令执行不会成功.&quot;
</code></pre>
<blockquote>
<p>服务器上remote_dir若不存在, 会自动创建;</p>
<p>只会上传project_dir目录下的文件到remote_dir的目录下</p>
<p>import之后, project_dir并没有自动转化为工作目录, 需要重新checkout(后面会用到)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重要"><a class="header" href="#重要">重要</a></h1>
<hr />
<ul>
<li>
<p>保护眼晴</p>
<ul>
<li>
<p><a href="https://github.com/darkreader/darkreader">darkreader暗黑模式</a>
<img src="webp/content/darkreader.webp" alt="darkreader" /></p>
</li>
<li>
<p>mac深色模式
<img src="webp/content/mac_display_deep.webp" alt="深色模式" /></p>
</li>
<li>
<p><a href="https://github.com/sindresorhus/awesome">各个领域优秀库-github</a></p>
</li>
</ul>
</li>
<li>
<p>Life is short.You need python!</p>
</li>
</ul>
<pre><code class="language-python">
print(&quot;hello, world&quot;)

</code></pre>
<ul>
<li>Dead is coming. Let is Go!</li>
</ul>
<pre><code class="language-go">import (
    &quot;fmt&quot;
)
func main() {
    fmt.Println(&quot;hello, world&quot;)
}
</code></pre>
<h3 id="扫-扫"><a class="header" href="#扫-扫">扫-扫</a></h3>
<hr />
<ul>
<li>公众号</li>
</ul>
<p><img src="webp/content/official_qr.webp" alt="公众号" title="公众号" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="rpc"><a class="header" href="#rpc">rpc</a></h1>
<hr />
<h3 id="运行过程"><a class="header" href="#运行过程">运行过程</a></h3>
<hr />
<p><img src="webp/rpc/rpc.webp" alt="rpc" /></p>
<pre class="mermaid">
sequenceDiagram
    actor c as Client
    actor cs as ClientSub
    actor s as Server
    actor ss as ServerSub
    actor h as Handler
    c-&gt;&gt;cs: 函数调用
    cs-&gt;&gt;cs: json/protobuf等序列化
    cs-&gt;&gt;s: tcp/http等发送
    s-&gt;&gt;ss: 函数调用
    ss-&gt;&gt;ss: json/protobuf等反序列化
    ss-&gt;&gt;h: 功能实现
    h--&gt;&gt;ss: 函数返回
    ss--&gt;&gt;ss: json/protobuf等序列化
    ss--&gt;&gt;s: 回包
    s--&gt;&gt;cs: tcp/http等发送
    cs--&gt;&gt;cs: json/protobuf等反序列化
    cs--&gt;&gt;c: 函数返回

</pre>
<h3 id="常见框架"><a class="header" href="#常见框架">常见框架</a></h3>
<hr />
<ul>
<li>
<p><img src="gwebp/rpc/rpc.webp" alt="google出品-grpc" /></p>
</li>
<li>
<p><img src="webp/rpc/tars.webp" alt="腾讯出品-tars" /></p>
</li>
<li>
<p><img src="bwebp/rpc/rpc.webp" alt="baidu出品-grpc" /></p>
</li>
<li>
<p><img src="webp/rpc/rpcx.webp" alt="golang语言专用" /></p>
</li>
<li>
<p>grpcurl 类似curl,但用于grpc</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="搜索技巧"><a class="header" href="#搜索技巧">搜索技巧</a></h1>
<hr />
<blockquote>
<p>搜索技巧就是在搜索关键字时，配合一些通配符，帮助快速定位到想要的结果
&gt;搜索技巧常常作为SEO(Search Engine Optimization)技术学习的一部分
&gt;&gt;SEO : 是一种通过了解搜索引擎，以及提高目的网站在有关搜索引擎内排名的方式</p>
</blockquote>
<h3 id="intitle标题"><a class="header" href="#intitle标题">intitle标题</a></h3>
<pre><code class="language-sh">keyword intitle:标题关键字
</code></pre>
<h3 id="intext内容"><a class="header" href="#intext内容">intext内容</a></h3>
<pre><code class="language-sh">keyword intext:内容关键字
</code></pre>
<h3 id="site站内还可以查看网站的收录情况"><a class="header" href="#site站内还可以查看网站的收录情况">site站内(还可以查看网站的收录情况)</a></h3>
<pre><code class="language-sh">keyword site:cnblogs.com
duckduckgo site:zhihu.com
</code></pre>
<h3 id="inurl链接"><a class="header" href="#inurl链接">inurl链接</a></h3>
<pre><code class="language-sh">keyword inurl:video
</code></pre>
<h3 id="限定时间段"><a class="header" href="#限定时间段">限定时间段</a></h3>
<pre><code class="language-sh">keyword 2022..2022
</code></pre>
<h3 id="info-介绍"><a class="header" href="#info-介绍">info 介绍</a></h3>
<pre><code class="language-sh">info:zhihu.com
</code></pre>
<h3 id="cache-搜索引擎关于某项关键字的缓存"><a class="header" href="#cache-搜索引擎关于某项关键字的缓存">cache 搜索引擎关于某项关键字的缓存</a></h3>
<pre><code class="language-sh">cache:keyword
</code></pre>
<h3 id="双引号书括号禁止拆分"><a class="header" href="#双引号书括号禁止拆分">双引号/书括号,禁止拆分</a></h3>
<pre><code class="language-sh">&quot;keyword&quot;《keyword》
</code></pre>
<h3 id="filetype过滤文件类型"><a class="header" href="#filetype过滤文件类型">Filetype过滤文件类型</a></h3>
<pre><code class="language-sh">keyword:pdf
</code></pre>
<h3 id="减号排除关键词"><a class="header" href="#减号排除关键词">减号,排除关键词</a></h3>
<pre><code class="language-sh"># python -广告 -推广
keyword -keyword2
</code></pre>
<h3 id="模糊匹配"><a class="header" href="#模糊匹配">模糊匹配</a></h3>
<pre><code class="language-sh">keyword*keyword
</code></pre>
<h3 id="define-关键词定义"><a class="header" href="#define-关键词定义">define 关键词定义</a></h3>
<pre><code class="language-sh">define:keyword
</code></pre>
<h3 id="link-搜索与某个网址有关联的其他网址"><a class="header" href="#link-搜索与某个网址有关联的其他网址">link 搜索与某个网址有关联的其他网址</a></h3>
<pre><code class="language-sh">keyword link:xxx.com
</code></pre>
<h3 id="bing高级搜索帮助"><a class="header" href="#bing高级搜索帮助"><a href="https://help.bing.microsoft.com/#apex/bing/zh-CHS/10001/-1">bing高级搜索帮助</a></a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="杂项"><a class="header" href="#杂项">杂项</a></h1>
<hr />
<h3 id="stmp发邮件"><a class="header" href="#stmp发邮件">STMP发邮件</a></h3>
<hr />
<pre class="mermaid">
sequenceDiagram
    actor c as 邮件客户端
    actor s as smtp服
    actor o as 目标邮件服
    actor u as 邮件接收者
    c-&gt;&gt;s: 登陆发邮件
    s--&gt;&gt;c: 错误或者垃级邮件就退回
    s-&gt;&gt;o: 成功中转发邮件
    o--&gt;&gt;s: 错误或者垃级邮件就退回
    o-&gt;&gt;u: 成功放入用户邮箱

</pre>
<h3 id="newsql"><a class="header" href="#newsql">NewSQL</a></h3>
<hr />
<pre class="mermaid">
flowchart LR
    SQL(SQL例如MySQL) --&gt; NoSQL(NoSQL例如MongoDB)
    NoSQL --&gt; newSQL(NewSQL例如CockroachDB,TiDB)

</pre>
<p>简述</p>
<ul>
<li>newSQL 就是在传统关系型数据库上集成了 noSQL 强大的可扩展性</li>
<li>newSQL 生于云时代，天生就是分布式架构</li>
<li><a href="https://www.cockroachlabs.com">CockroachDB</a></li>
<li><a href="https://pingcap.com">TiDB</a></li>
</ul>
<h3 id="好用的搜索"><a class="header" href="#好用的搜索">好用的搜索</a></h3>
<hr />
<ul>
<li><a href="https://github.com/benbusby/whoogle-search">whoogle-search-自建google元搜索</a></li>
<li><a href="https://github.com/searxng/searxng">searxng-另一个searx</a></li>
<li><a href="https://github.com/searx/searx">SEARX-开源元搜索</a></li>
<li><a href="https://kaifa.baidu.com/">百度开发者-搜索</a></li>
<li><a href="https://bing.com/">必应国际版-搜索</a></li>
<li><a href="https://goobe.io/">goobe-程序员专用搜索</a></li>
<li><a href="https://mengso.com/neice">mengso-搜索引擎</a>,采用opensearch方式才能用</li>
<li><a href="https://yandex.com/">yandex-搜索引擎</a>,过滤得不够</li>
<li><a href="https://sourcegraph.com/search">专搜代码-source</a></li>
<li><a href="https://searchcode.com/">专搜代码-search</a></li>
<li><a href="https://publicwww.com/">专搜代码-publicwww</a></li>
</ul>
<h3 id="chromium安装darkreader"><a class="header" href="#chromium安装darkreader">chromium安装darkreader</a></h3>
<hr />
<ul>
<li>
<p>github下载
<img src="webp/other/darkreader_download.webp" alt="下载" /></p>
</li>
<li>
<p>chromium安装
<img src="webp/other/darkreader_chrome.webp" alt="安装" /></p>
</li>
</ul>
<h3 id="写好博客wiki有用参考"><a class="header" href="#写好博客wiki有用参考">写好博客/wiki有用参考</a></h3>
<hr />
<ul>
<li>官方文档/教程</li>
<li>github优秀项目的readme</li>
<li>搜索 Stackoverflow 「关于某个 Wiki 话题」，前 10 ~ 20 个问题；</li>
<li>阅读 Google 搜索「关于某个 Wiki 话题」，前 10 ~ 100 篇文章；</li>
<li>社区优秀的免费和付费书籍（如果有的话）；</li>
<li>优秀的出版书籍（如果有的话）</li>
</ul>
<h3 id="华为手机自定义安装vlc"><a class="header" href="#华为手机自定义安装vlc">华为手机自定义安装VLC</a></h3>
<hr />
<ul>
<li>
<p><a href="https://consumer.huawei.com/cn/support/hisuite/">电脑安装华为手机助手</a>
<img src="webp/other/hisuite_download.webp" alt="华为手机助手" /></p>
</li>
<li>
<p>用数据线连接电脑和手机,手机开启HDB
<img src="webp/other/nova_hdb.webp" alt="开启hdb" /></p>
</li>
<li>
<p>下载VLC安装包
<img src="webp/other/vlc_download.webp" alt="下载vlc" /></p>
</li>
<li>
<p>复制到手机
<img src="webp/other/vlc_copy.webp" alt="复制vlc" /></p>
</li>
<li>
<p>手机-&gt;实用工具-&gt;文件管理-&gt;浏览-&gt;下载与接收-&gt;下载管理器-&gt;点击apk</p>
</li>
</ul>
<h3 id="小度音箱播放本地音乐"><a class="header" href="#小度音箱播放本地音乐">小度音箱播放本地音乐</a></h3>
<hr />
<ol>
<li>
<p>进入小度APP之后，点击上方配置的小度智能音箱</p>
</li>
<li>
<p>点击进入设备设置。</p>
</li>
<li>
<p>点击进入蓝牙设置。</p>
</li>
<li>
<p>打开音箱蓝牙的开关。</p>
</li>
<li>
<p>再打开手机的蓝牙功能，找到音箱的蓝牙名称。</p>
</li>
<li>
<p>成功连接音箱蓝牙后，打开手机音乐即可在小度音箱中播放</p>
</li>
</ol>
<h3 id="优秀工具"><a class="header" href="#优秀工具">优秀工具</a></h3>
<hr />
<ul>
<li><a href="https://www.githubs.cn/">githubs中文社区</a></li>
<li><a href="https://github.com/alist-org/alist">alist-各种网盘分享</a>非常优秀,值得试试</li>
<li><a href="https://txc.qq.com/">腾讯兔小巢</a>快速建立用户反馈系统,值得试试</li>
<li><a href="https://wkhtmltopdf.org/">wkhtmltopdf-html转pdf</a>把html转化为pdf</li>
</ul>
<pre><code class="language-sh">brew install --cask wkhtmltopdf
</code></pre>
<ul>
<li><a href="https://riptutorial.com/">riptutorial</a>国内免费分享的书籍示例</li>
<li><a href="https://github.com/Eloston/ungoogled-chromium">无google全家桶的chromium</a></li>
<li><a href="https://www.jenkins.io/zh/">jenkins</a></li>
<li><a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/">jenkins-pipeline语法</a></li>
<li><a href="%E5%8F%AF%E8%A7%86%E5%8C%96%E7%89%88pipeline%EF%BC%8C%E5%80%BC%E5%BE%97%E5%AE%89%E8%A3%85">jenkins-BlueOcean插件</a></li>
<li><a href="https://www.drone.io/">drone-轻量级的jenkins</a></li>
<li><a href="https://code.onedev.io/">onedev-java版gogs</a></li>
<li><a href="https://gogs.io">gogs本地代码托管</a></li>
<li><a href="https://gitea.io">gitea本地代码托管</a></li>
<li><a href="https://mermaid-js.github.io/mermaid/">mermaid</a></li>
<li><a href="https://mirrors.ustc.edu.cn/">中科大镜像</a></li>
<li><a href="https://developer.aliyun.com/mirror/">阿里云镜像</a></li>
<li><a href="https://mirror.tuna.tsinghua.edu.cn/">清华大学镜像</a></li>
<li><a href="https://www.docusaurus.cn/">类似hugo-文档建站工具</a></li>
<li><a href="https://github.com/AlDanial/cloc">cloc代码统计工具</a></li>
<li><a href="https://github.com/getrebuild/rebuild/">企业管理系统</a></li>
<li><a href="https://discord.onl/">Discord社交软件</a></li>
<li><a href="https://slack.com/">Slack社交软件</a></li>
<li><a href="https://www.odoo.com/zh_CN">odoo以前openERP</a></li>
<li><a href="https://www.zentao.net/">禅道</a></li>
<li><a href="https://www.layabox.com/">LayaAirH5小游戏引擎</a></li>
<li><a href="https://apijson.com/">apijson</a></li>
<li><a href="https://apifox.com/">apifox</a></li>
<li><a href="https://www.bazhuayu.com/">八爪鱼-自动爬虫</a></li>
<li><a href="https://clickhouse.com/docs/zh/">clickhouse-联机分析(OLAP)的列式数据库管理系统(DBMS)</a>,用来分析现有数据,发现数据规律，商业模式好帮手.</li>
</ul>
<blockquote>
<p><a href="https://doris.apache.org/zh-CN">Apache Doris</a>是由百度贡献的开源MPP分析型数据库产品，亚秒级查询响应时间，支持实时数据分析；分布式架构简洁，易于运维，可以支持10PB以上的超大数据集；可以满足多种数据分析需求，例如固定历史报表，实时数据分析，交互式数据分析和探索式数据分析等。
ClickHouse是俄罗斯的搜索公司Yandex开源的MPP架构的分析引擎，号称比事务数据库快100-1000倍，团队有计算机体系结构的大牛，最大的特色是高性能的向量化执行引擎，而且功能丰富、可靠性高。</p>
</blockquote>
<h3 id="小知识-2"><a class="header" href="#小知识-2">小知识</a></h3>
<hr />
<ul>
<li>国内dns地址</li>
</ul>
<pre><code class="language-sh">腾讯 DNS
119.29.29.29
182.254.116.116

阿里DNS
223.5.5.5
223.6.6.6
2400:3200::1

百度DNS
180.76.76.76
114.114.114.114

2400:da00::6666

下一代互联网国家工程中心
240c::6666
240c::6644
</code></pre>
<ul>
<li>域名解析ipv6地址,是增加<strong>AAAA记录</strong></li>
</ul>
<pre><code class="language-sh">#采用ipv6
ping -6 host
#mac
ping6 host
</code></pre>
<ul>
<li><a href="https://mac.getutm.app/">utm-虚拟机</a>
detian linux可以正常启动
Username: debian
Password: debian</li>
</ul>
<p>centos-stream9
root
密码同mac的帐户密码</p>
<p>utm一个虚拟机对应一个utm文件,当初次创建可能需要iso,等iso安装完成了，编辑虚拟机属性，删除掉dvd就不会再安装</p>
<ul>
<li><a href="https://github.com/brave/brave-browser">brave-另一个chromium</a></li>
<li><a href="https://rockylinux.org/zh_CN/">rockylinux-centos开源替代品</a></li>
<li><a href="https://docs.openeuler.org/zh/">openEuler欧拉OS-linux发行版</a></li>
<li><a href="https://flutter.cn/">android studio-开发ide</a></li>
<li><a href="https://flutter.cn/">flutter-跨六个平台</a>-为每个平台生成对应的工程目录,从而达到支持多平台目录</li>
<li><a href="https://www.runoob.com/">菜鸟教程-入门必看</a></li>
<li><a href="https://www.consul.io/">Consul-服务发现和配置</a></li>
<li><a href="https://www.crxfun.com">优质chrome插件-国内下载离线安装</a></li>
<li><a href="https://docs.fastlane.tools/">fastlane-自动部署工具</a></li>
<li><a href="https://Fundebug/">BUG监控-开发者报警</a></li>
<li><a href="https://github.com/tesseract-ocr/tesseract">tesseract-谷歌的ocr开源</a></li>
<li><a href="https://www.paddlepaddle.org.cn/">paddle-百度的ocr开源</a></li>
<li><a href="https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.5/PPOCRLabel/README_ch.md">PPOCRLabel-百度开源标注系统</a></li>
<li><a href="https://github.com/DayBreak-u/chineseocr_lite">chineseocr_lite-ocr开源</a></li>
<li><a href="https://github.com/ushelp/EasyOCR">EasyOCR-ocr开源,基于tesseract</a></li>
<li><a href="https://github.com/chineseocr/chineseocr">chineseocr-ocr开源</a></li>
<li><a href="https://github.com/opencv/cvat">cvat-开源标注系统</a></li>
<li><a href="https://github.com/microsoft/VoTT">VoTT-微软开源标注系统</a></li>
<li><a href="https://github.com/wkentaro/labelme">labelme-开源标注系统</a></li>
<li><a href="https://github.com/tzutalin/labelImg">labelImg-开源标注系统</a></li>
<li><a href="https://gitlab.com/vgg/via">via-开源标注系统</a></li>
<li><a href="https://github.com/features/copilot/">copilot-AI写代码</a></li>
<li><a href="https://www.oschina.net/company">开源公司介绍-oschina</a></li>
<li><a href="https://www.fabfile.org/">Fabric-python自动化运维</a></li>
<li><a href="https://github.com/baidu/dperf">dperf-百度开源压测工具</a></li>
<li><a href="https://www.traefik.tech/">traefik-开源的边缘路由器,类似于nginx</a></li>
<li><a href="https://tensorflow.google.cn/">tensorflow-谷歌的人工智能开源</a></li>
<li><a href="https://www.geetest.com/">极验-交互式验证码</a></li>
<li><a href="https://720yun.com/">720-VR全景制作</a></li>
<li><a href="https://upx.github.io/">upx-免费程序打包压缩神器</a></li>
<li><a href="https://lanhuapp.com/">蓝湖</a>
<blockquote>
<p>蓝湖是一款产品文档和设计图的共享平台，帮助互联网团队更好地管理文档和设计图。蓝湖可以在线展示Axure，自动生成设计图标注，与团队共享设计图，展示页面之间的跳转关系</p>
</blockquote>
</li>
<li>OCSP-在线证书状态协议 目的：验证SSL证书的有效性，以确保它未被吊销。</li>
<li><a href="https://opensource.tencent.com/">腾讯开源</a></li>
<li><a href="https://opensource.baidu.com/">百度开源</a></li>
<li><a href="https://ai.baidu.com/">百度AI</a></li>
<li><a href="https://opensource.alibaba.com/">阿里开源</a></li>
<li><a href="https://cloud.tencent.com/developer/">腾讯-开发者社区</a></li>
<li><a href="https://developer.baidu.com/">百度-开发者社区</a></li>
<li><a href="https://developer.aliyun.com/">阿里云-开发者社区</a></li>
<li><a href="https://developer.ibm.com/">IBM-开发者社区</a></li>
<li><a href="https://gitlab.com/">gitlab-开源gitlab</a></li>
<li><a href="https://codefever.pgyer.com/">dodefever-蒲公英托管平台</a>,<a href="github.com/PGYER/codefever">github开源地址</a></li>
<li><a href="https://gitee.com/">gitee-百度投资托管平台</a></li>
<li><a href="https://coding.net/">coding-腾讯投资托管平台</a></li>
<li><a href="https://developer.tencent.com/">工蜂-腾讯托管平台</a></li>
<li><a href="https://codeup.aliyun.com/">云效-阿里云托管平台</a></li>
<li>企业微信添加机器人,实现接受webhook</li>
<li>钉钉添加机器人,实现接受webhook,<a href="https://open.dingtalk.com/">钉钉开放平台</a></li>
<li><a href="https://www.tapd.cn/">Tapd-让协作更敏捷</a></li>
<li>介绍<a href="https://draveness.me/whys-the-design-linux-macos-fragmentation/">不需要碎片整理</a>
<ul>
<li>文件系统基于区块分配的设计使得磁盘上出现碎片的概率很低，延迟分配和自动的整理策略解放了操作系统的使用者，在多数情况下不需要考虑磁盘的碎片化；</li>
<li>固态硬盘的随机读写性能远远好于机械硬盘，随机读写和顺序读写虽然也有性能差异，但是没有机械硬盘的差异巨大，而频繁的碎片整理也会影响固态硬盘的使用寿命；</li>
</ul>
</li>
<li>存在ipv0,ipv1,ipv2,ipv3,ipv5协议</li>
<li>ipv6难取代ipv4,IPv6的回环地址是：0:0:0:0:0:0:0:0或::,ipv4使用32bit/4字节,每组一个字节,4组,ipv6采用128bit/16字节,每组2个字节,8组.
<ul>
<li>IPv6 协议在设计时没有考虑与 IPv4 的兼容性问题</li>
<li>NAT 技术很大程度上缓解了 IPv4 地址短缺的问题</li>
<li>更细粒度的管控 IPv4 地址并回收闲置的资源</li>
<li>谁有能力强制推行大家支持?国家虽有文件要求,但设备厂商、运营商、互联网服务提供商、软件开发者、用户这整个链路中，所有的人都把IPv4当必选方案，IPv6当可选方案。所有的人都有非常一致的思维：既然IPv4 100%能访问，IPv6不确定因素那么多，那我就直接全部用IPv4多好多省事。</li>
<li><a href="http://www.test-ipv6.com/">这里测试ipv6</a></li>
</ul>
</li>
<li>tcp粘包因为是传输字节流,解决办法是协议自定义消息边界
<ul>
<li>消息长度固定</li>
<li>消息中有包括长度的字段</li>
<li>采用特定字符串作为消息边界</li>
</ul>
</li>
<li>Google perftools
<ul>
<li>它的主要功能就是通过采样的方式，给程序中cpu的使用情况进行“画像”，通过它所输出的结果，我们可以对程序中各个函数（得到函数之间的调用关系）耗时情况一目了然。</li>
<li>在对程序做性能优化的时候，这个是很重要的，先把最耗时的若干个操作优化好，程序的整体性能提升应该十分明显.</li>
</ul>
</li>
<li><a href="https://www.bbsmax.com/A/mo5kZmX4Jw/">HMM(隐马尔科夫模型)</a></li>
<li><a href="https://webtorrent.io/">webtorrent-直接看p2p</a></li>
<li><a href="https://github.com/apache/dolphinscheduler">开源工作流</a></li>
<li><a href="https://github.com/moyix/fauxpilot">开源免费的-pilot</a></li>
<li><a href="https://github.com/eolinker/eoapi">eoapi-postman开源替代品</a></li>
<li>[almalinux-centos社区版]（<a href="https://almalinux.org/zh-hans/">https://almalinux.org/zh-hans/</a>）</li>
<li>转换pdf为jpg图片</li>
</ul>
<pre><code class="language-shell"># -density 300设置渲染PDF的dpi。
# -trim删除与角像素颜色相同的所有边缘像素。
# -quality 100将JPEG压缩质量设置为最高质量。
magick convert -density 300 -trim a.pdf -quality 100 a.jpg
</code></pre>
<h3 id="英特尔的nuc迷你电脑"><a class="header" href="#英特尔的nuc迷你电脑">英特尔的NUC迷你电脑</a></h3>
<ul>
<li>二手服务器主机(无尘机房下来的,质量较好)-费电，响声大</li>
<li>NUC-性能低</li>
</ul>
<h3 id="appimagelinux-apps-that-run-anywhere"><a class="header" href="#appimagelinux-apps-that-run-anywhere">AppImage(Linux apps that run anywhere)</a></h3>
<ul>
<li>AppImage 是一个压缩的镜像文件，它包含所有运行所需要的依赖和库文件.你可以直接执行AppImage 文件不需要安装。. 当你把AppImage 文件删除，整个软件也被删除了。. 你可以把它当成windows系统中的那些免安装的exe文件。</li>
</ul>
<h3 id="jsonljson-lines"><a class="header" href="#jsonljson-lines">jsonl(JSON Lines)</a></h3>
<p>JSON Lines 是一种文本格式，适用于存储大量结构相似的嵌套数据、在协程之间传递信息等。
它有如下特点：</p>
<p>每一行都是完整、合法的 JSON 值；采用 \n 或 \r\n 作为行分隔符；
采用 UTF-8 编码；
使用 jsonl 作为文件扩展名；建议使用 gzip 或 bzip2 压缩并生成 .jsonl.gz 或 .jsonl.bz2 文件，以便节省空间。</p>
<h3 id="gitlab-1"><a class="header" href="#gitlab-1">gitlab</a></h3>
<ul>
<li>gitlab-&gt;偏好设置-&gt;中文</li>
</ul>
<h3 id="wps"><a class="header" href="#wps">wps</a></h3>
<h4 id="wps加载网页表格"><a class="header" href="#wps加载网页表格">WPS加载网页表格</a></h4>
<ul>
<li>第一步：在网页上找到自己想要的表格，如果不能复制粘贴的话，那么就勾选其网址，然后复制</li>
<li>第二步：打开Excel表格，在菜单中的数据选项卡中找到“自网站”，然后点击进入。</li>
<li>第三步：在弹出的页面中，选择“基本”，然后在下方的空格中粘贴刚刚复制好的网址，点击确定。</li>
<li>第四步：稍等一会儿，就会弹出导航器，里面就有刚刚网页上的表格，选择你想要的表格，然后点击下方的加载。</li>
<li>第五步：最后表格就会很完美的加载在你的Excel中，而且格式都是网页上一样的，避免你再次挑战格式的麻烦</li>
</ul>
<h4 id="快速选中多行多列"><a class="header" href="#快速选中多行多列">快速选中多行、多列</a></h4>
<ul>
<li>鼠标选中某个单元格，按住 shift 键，然后鼠标点击另外一个单元单元格</li>
</ul>
<h3 id="kcpquicenet协议的区别"><a class="header" href="#kcpquicenet协议的区别">kcp/quic/enet协议的区别</a></h3>
<ul>
<li>
<p>quic 是一个完整固化的 http 应用层协议，目前已经更名 http/3，指定使用 udp（虽然本质上并不一定需要 udp）。其主要目的是为了整合TCP协议的可靠性和udp协议的速度和效率，其主要特性包括：避免前序包阻塞、减少数据包、向前纠错、会话重启和并行下载等，然而QUIC对标的是TCP+TLS+SPDY，相比其他方案更重，目前国内用于网络游戏较少</p>
</li>
<li>
<p>kcp 只是一套基于无连接的数据报文之上的连接和拥塞控制协议，对底层【无连接的数据报文】没有具体的限制，可以基于 udp，也可以基于伪造的 tcp/icmp 等，也可以基于某些特殊环境的非 internet 网络（比如各种现场通信总线）,KCP协议就是在保留UDP快的基础上，提供可靠的传输，应用层使用更加简单.</p>
</li>
<li>
<p>enet: 有ARQ协议。收发不用自己实现，提供连接管理，心跳机制。支持人数固定。自己实现跨平台。支持可靠无序通道。没有拥塞控制。线程不安全</p>
</li>
</ul>
<h3 id="理解socks5协议的工作过程和协议细节"><a class="header" href="#理解socks5协议的工作过程和协议细节"><a href="https://wiyi.org/socks5-protocol-in-deep.html">理解socks5协议的工作过程和协议细节</a></a></h3>
<p><img src="webp/other/socks5.webp" alt="示意图" /></p>
<h3 id="全球ip地址查询"><a class="header" href="#全球ip地址查询"><a href="https://github.com/lionsoul2014/ip2region">全球ip地址查询</a></a></h3>
<h3 id="luminati中国"><a class="header" href="#luminati中国"><a href="http://www.luminati-cn.net/">luminati中国</a></a></h3>
<ul>
<li>Luminati是全球最大的代理服务，全球拥有3500万IP的住宅代理网络和零编码代理管理接口。爬取任何网络数据， 从不被屏蔽，从不被掩盖。Luminati是道德代理网络。</li>
</ul>
<h3 id="无界面浏览器"><a class="header" href="#无界面浏览器">无界面浏览器</a></h3>
<ul>
<li><a href="https://playwright.dev/">playwright-微软出品</a>(<a href="https://github.com/microsoft/playwright">https://github.com/microsoft/playwright</a>)</li>
<li><a href="https://github.com/puppeteer/puppeteer/">puppeteer-谷歌出品</a>
<img src="webp/other/puppeteer.webp" alt="puppeteer" /></li>
<li><a href="https://phantomjs.org">phantomjs-停止开发</a></li>
</ul>
<h3 id="openwrite-次编写markdown多个平台发布"><a class="header" href="#openwrite-次编写markdown多个平台发布"><a href="https://openwrite.cn">openwrite-次编写markdown多个平台发布</a></a></h3>
<h3 id="检测vps的ip是否被封有人检测到http代理或socks5则会临时被封几分钟"><a class="header" href="#检测vps的ip是否被封有人检测到http代理或socks5则会临时被封几分钟">检测vps的ip是否被封,有人检测到http代理或socks5,则会临时被封几分钟</a></h3>
<ul>
<li>
<p><a href="https://tool.chinaz.com/">中国站长工具</a>,同时采用国内及国外ping，如果都不行，则肯定是vps问题，否则就极可能被封.</p>
</li>
<li>
<p>traceroute(linux/mac),tracert(windows) xxx 追踪一下</p>
</li>
<li>
<p>查看路由表</p>
<ul>
<li>mac系统</li>
</ul>
<pre><code class="language-bash">netstat -r Routing tables
</code></pre>
<ul>
<li>linux系统</li>
</ul>
<pre><code class="language-bash">route -n
</code></pre>
<ul>
<li>windows系统</li>
</ul>
<pre><code class="language-bash">route print
</code></pre>
</li>
</ul>
<h3 id="各大厂商的ocr接口"><a class="header" href="#各大厂商的ocr接口">各大厂商的ocr接口</a></h3>
<ul>
<li>华为没有免费的</li>
<li>阿里和腾讯都有免费额度</li>
<li>baidu的效果最好</li>
<li>window10/11自带ocr api接口</li>
</ul>
<p><a href="https://blogs.windows.com/windowsdeveloper/2016/02/08/optical-character-recognition-ocr-for-windows-10/">https://blogs.windows.com/windowsdeveloper/2016/02/08/optical-character-recognition-ocr-for-windows-10/</a></p>
<p><a href="https://cloud.tencent.com/document/product/866/35945">https://cloud.tencent.com/document/product/866/35945</a></p>
<p><a href="https://help.aliyun.com/document_detail/330957.html">https://help.aliyun.com/document_detail/330957.html</a></p>
<p><a href="https://ai.baidu.com/ai-doc/REFERENCE/Ck3dwjhhu#%E8%8E%B7%E5%8F%96-access-token">https://ai.baidu.com/ai-doc/REFERENCE/Ck3dwjhhu#%E8%8E%B7%E5%8F%96-access-token</a></p>
<h3 id="开源代码库可以通过关键字在-github-中查找教程博客可以在-medium-这样的平台上搜索api-则可在官方文档翻阅"><a class="header" href="#开源代码库可以通过关键字在-github-中查找教程博客可以在-medium-这样的平台上搜索api-则可在官方文档翻阅">开源代码库可以通过关键字在 GitHub 中查找；教程博客可以在 Medium 这样的平台上搜索；API 则可在官方文档翻阅</a></h3>
<h3 id="埋点"><a class="header" href="#埋点">埋点</a></h3>
<ul>
<li>是数据采集领域（尤其是用户行为数据采集领域）的术语,指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。比如用户某个icon点击次数、观看某个视频的时长等等。埋点的技术实质，是先监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获</li>
</ul>
<h3 id="便宜的海外服务器"><a class="header" href="#便宜的海外服务器">便宜的海外服务器</a></h3>
<ul>
<li><a href="https://buy.cloud.tencent.com">腾讯云</a>孟买-特惠</li>
</ul>
<h3 id="代码相似度检查nicad"><a class="header" href="#代码相似度检查nicad">代码相似度检查<a href="http://www.txl.ca/txl-nicaddownload.html">NiCad</a></a></h3>
<h3 id="ocr错别字都是形近字根据语义能否提示错别字"><a class="header" href="#ocr错别字都是形近字根据语义能否提示错别字">ocr错别字都是形近字,根据语义能否提示错别字?</a></h3>
<h3 id="常见usb接口"><a class="header" href="#常见usb接口">常见usb接口</a></h3>
<p><img src="webp/other/usb.webp" alt="usb" /></p>
<h3 id="阿里云智能插件仅支持java"><a class="header" href="#阿里云智能插件仅支持java"><a href="https://alibaba-cloud-toolkit.github.io/cosy/#/zh-cn/README">阿里云智能插件,仅支持java</a></a></h3>
<h3 id="antlr---强大的开源语法分析工具"><a class="header" href="#antlr---强大的开源语法分析工具"><a href="https://github.com/antlr">Antlr - 强大的开源语法分析工具</a></a></h3>
<h3 id="har"><a class="header" href="#har">HAR</a></h3>
<p>HAR（HTTP档案规范），是一个用来储存HTTP请求/响应信息的通用文件格式，基于JSON。这种格式的数据可以使HTTP监测工具以一种通用的格式导出所收集的数据，这些数据可以被其他支持HAR的HTTP分析工具（包括Firebug、httpwatch、Fiddler等）所使用，来分析网站的性能瓶颈。</p>
<h3 id="开源的聊天应用rocketchat-替代微信"><a class="header" href="#开源的聊天应用rocketchat-替代微信"><a href="https://www.rocket.chat/">开源的聊天应用RocketChat-替代微信</a></a></h3>
<h3 id="toml文件格式"><a class="header" href="#toml文件格式"><a href="https://toml.io/cn/v1.0.0">toml文件格式</a></a></h3>
<h3 id="开源替换google-analytics-umamiown-your-website-analytics-开源替换google-analytics-应该是当今互联网使用最广泛的网站流量分析服务"><a class="header" href="#开源替换google-analytics-umamiown-your-website-analytics-开源替换google-analytics-应该是当今互联网使用最广泛的网站流量分析服务"><a href="https://umami.is/">开源替换Google Analytics-umami</a>Own your website analytics 开源替换Google Analytics 应该是当今互联网使用最广泛的网站流量分析服务</a></h3>
<h3 id="次世代图片格式-jpeg-xlavifwebp-2"><a class="header" href="#次世代图片格式-jpeg-xlavifwebp-2">次世代图片格式 JPEG XL、AVIF、WebP 2</a></h3>
<ul>
<li>AVIF 有损压缩效果最好，无损压缩非常糟糕。编码速度很慢。</li>
<li>JPEG XL 无损压缩效果最好，有损压缩较 AVIF 有些许差距。编码速度快。</li>
<li>WebP 2 无损压缩效果优秀，有损压缩的上限达到了 AVIF 的水平，但下限很低，不稳定。编码速度很慢</li>
</ul>
<h3 id="这里是-ant-design-的-vue-实现开发和服务于企业级后台产品https2xantdvcomdocsvueintroduce-cn"><a class="header" href="#这里是-ant-design-的-vue-实现开发和服务于企业级后台产品https2xantdvcomdocsvueintroduce-cn">这里是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品(<a href="https://2x.antdv.com/docs/vue/introduce-cn">https://2x.antdv.com/docs/vue/introduce-cn</a>)</a></h3>
<h3 id="github-404项目"><a class="header" href="#github-404项目"><a href="https://github.com/knownsec/404StarLink">github-404项目</a></a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="优秀开源软件"><a class="header" href="#优秀开源软件">优秀开源软件</a></h1>
<hr />
<h3 id="mrdoc-觅思文档"><a class="header" href="#mrdoc-觅思文档"><a href="https://mrdoc.pro/">mrdoc-觅思文档</a></a></h3>
<ul>
<li>其功能类似于国内的语雀平台、看云平台和飞书文档，国外的 GitBook 平台。</li>
</ul>
<h3 id="rustdesk-远程桌面"><a class="header" href="#rustdesk-远程桌面"><a href="https://github.com/rustdesk/rustdesk">rustdesk-远程桌面</a></a></h3>
<h3 id="网络状态模拟器"><a class="header" href="#网络状态模拟器"><a href="https://github.com/tylertreat/comcast">网络状态模拟器</a></a></h3>
<h3 id="opencv"><a class="header" href="#opencv"><a href="https://opencv.org/">opencv</a></a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="机器学习"><a class="header" href="#机器学习">机器学习</a></h1>
<hr />
<h3 id="常见框架-1"><a class="header" href="#常见框架-1">常见框架</a></h3>
<ul>
<li>
<p><a href="https://pytorch.org/">pytorch</a>,1.12之后支持m1芯片</p>
</li>
<li>
<p><a href="https://tensorflow.google.cn/">tensorflow</a>,目前支持m1芯片，需要打补丁<a href="https://developer.apple.com/metal/tensorflow-plugin/">tensorflow-plugin</a></p>
</li>
<li>
<p><a href="https://scikit-learn.org/stable/index.html">scikit-learn</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/cn/machine-learning/">Core ML</a>,苹果内置机器学习</p>
</li>
</ul>
<h3 id="python机器学习包介绍"><a class="header" href="#python机器学习包介绍">python机器学习包介绍</a></h3>
<p><img src="webp/machinelearn/python_package.webp" alt="python_package图" title="python_package图" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="ai"><a class="header" href="#ai">ai</a></h1>
<hr />
<ul>
<li>Finetuning
Fine tuning的原理就是利用已知的网络结构和已知的网络参数，修改output层为我们自己的层，微调最后一层前的所有层的参数，加大最后一层的学习率，因为最后一层我们需要重新学习，所以与其它层相比要有相对较大的学习率，这样就有效利用了深度神经网络强大的泛化能力，又免去了设计复杂的模型以及耗时良久的训练，所以fine tuning是当数据量不足时的一个比较合适的选择。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="wasm"><a class="header" href="#wasm">wasm</a></h1>
<hr />
<h3 id="官方网站"><a class="header" href="#官方网站"><a href="https://webassembly.org/">官方网站</a></a></h3>
<blockquote>
<p>WebAssembly，通常简称为 Wasm，是一种相对较新的技术，它允许你编译用 40 多种语言（包括 Rust、C、C++、JavaScript 和 Golang）编写的应用程序代码，并在沙盒环境中运行它。最初的用例主要是在 Web 浏览器中运行本地代码，但是由于 WebAssembly 系统接口（WASI）的存在，Wasm 正在迅速向浏览器之外扩展，</p>
</blockquote>
<h3 id="wasmedge"><a class="header" href="#wasmedge"><a href="https://wasmedge.org/">wasmedge</a></a></h3>
<h3 id="wasm-二进制标准格式另一个一次编译到处执行"><a class="header" href="#wasm-二进制标准格式另一个一次编译到处执行">wasm-二进制标准格式，另一个&quot;一次编译，到处执行&quot;</a></h3>
<p><img src="webp/was/wasm_brower.webp" alt="浏览器中wasm" />
<img src="webp/was/wasm_os.webp" alt="os中wasm" />
<img src="webp/was/wasm_interpreter.webp" alt="解释器的wasm" />
<img src="webp/was/wasm_docker.webp" alt="docker版的wasm" />
<img src="webp/was/wasm_enter.webp" alt="wasm的进化史" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="阿里云-1"><a class="header" href="#阿里云-1">阿里云</a></h1>
<hr />
<h3 id="开源mirror网址"><a class="header" href="#开源mirror网址"><a href="https://developer.aliyun.com/mirror/">开源mirror网址</a></a></h3>
<hr />
<p><img src="webp/aliyun/aliyun_mirror.webp" alt="截图" title="aliyun_mirror" /></p>
<h3 id="阿里云专有网络"><a class="header" href="#阿里云专有网络"><a href="https://help.aliyun.com/document_detail/100380.html">阿里云专有网络</a></a></h3>
<hr />
<ul>
<li>专有网络是您独有的云上虚拟网络，您可以将云资源部署在您自定义的专有网络中.</li>
<li>云资源不可以直接部署在专有网络中，必须属于专有网络内的一个交换机（子网）内.</li>
<li>目前专有网络必须手动开启ipv6功能</li>
</ul>
<p><img src="webp/aliyun/aliyun_vpc.webp" alt="vpc" /></p>
<p><img src="webp/aliyun/aliyun_route.webp" alt="route" /></p>
<h3 id="阿里云支持ipv6"><a class="header" href="#阿里云支持ipv6">阿里云支持ipv6</a></h3>
<p><img src="webp/aliyun/aliyun_dns.webp" alt="aliyun_dns" />
<img src="webp/aliyun/aliyun_ipv6_ipv4.webp" alt="aliyun_ipv6_ipv4" />
<img src="webp/aliyun/aliyun_ipv6_slb.webp" alt="aliyun_ipv6_slb" />
<img src="webp/aliyun/aliyun_ipv6.webp" alt="aliyun_ipv6" /></p>
<h3 id="阿里云ecs配置ipv6"><a class="header" href="#阿里云ecs配置ipv6"><a href="https://help.aliyun.com/document_detail/108458.html">阿里云ECS配置ipv6</a></a></h3>
<p><img src="aliyun_ecs_ipv6.web" alt="aliyun_ecs_ipv6" /></p>
<ul>
<li>
<p>VPC和ECS支持双栈后，ECS上会分配到IPv6地址，部署在ECS上的系统需要主动访问Internet的IPv6系统，这就需要配合IPv6网关使用</p>
</li>
<li>
<p>开通IPv6网关后，通过配置IPv6网关规则，允许VPC内指定IPv6地址访问公网，则指定的IPv6 ECS就可以主动访问公网了</p>
</li>
<li>
<p>如不配置IPv6网关规则，默认ECS分配的IPv6地址只能在VPC内部通信</p>
</li>
<li>
<p>安全组,源:&quot;::/0&quot;表示允许ipv6,源:&quot;0.0.0.0/0&quot;表示允许ipv4,要支持双栈就要同端口开放两个规则</p>
</li>
<li>
<p><a href="https://help.aliyun.com/document_detail/187463.html">ip6无法访问解决办法</a></p>
</li>
</ul>
<h3 id="阿里云邮箱-默认开通"><a class="header" href="#阿里云邮箱-默认开通">阿里云邮箱 默认开通</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>服务器名称</th><th>服务器地址</th><th>服务器端口号（非加密）</th><th>服务器端口号（SSL加密）</th></tr></thead><tbody>
<tr><td>POP3</td><td>pop3.aliyun.com</td><td>110</td><td>995</td></tr>
<tr><td>SMTP</td><td>smtp.aliyun.com</td><td>25</td><td>465</td></tr>
<tr><td>IMAP</td><td>imap.aliyun.com</td><td>143</td><td>993</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>subject</strong>不能太随意了,否则会认为垃圾邮件,被系统退信的!
发件邮箱最好加入白名单</p>
</blockquote>
<h3 id="杂项-1"><a class="header" href="#杂项-1">杂项</a></h3>
<hr />
<ul>
<li><a href="https://market.aliyun.com/products">阿里云:云市场,买各种api接口</a></li>
<li><a href="http://codeup.aliyun.com">阿里云:云效代码托管</a>,可能快速导入其他的repos</li>
<li><a href="https://open.dingtalk.com/">钉钉开放平台</a></li>
<li>弹性云手机-远程虚拟手机,可以批量安装测试</li>
<li>批量安装设置服务器
<ul>
<li>设置一台机器为种子,进行各种配置和安装</li>
<li>把种子机器导出为镜像</li>
<li>购买其他实例,选择从指定镜像初始化</li>
</ul>
</li>
<li>号码隐私保护服务-真实号码绑定虚拟号码,其他人可用虚拟号码转到真实号码</li>
</ul>
<h3 id="阿里云ecs高危漏洞问题处理"><a class="header" href="#阿里云ecs高危漏洞问题处理">阿里云ECS高危漏洞问题处理</a></h3>
<hr />
<pre><code class="language-bash"># 升级系统及软件就能解决多数
yum -y upgrade
</code></pre>
<h3 id="服务器vi乱码"><a class="header" href="#服务器vi乱码">服务器vi乱码</a></h3>
<hr />
<pre><code class="language-bash">cd ~
vi .vimrc

set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
set number
filetype on
syntax on
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h1 id="腾讯"><a class="header" href="#腾讯">腾讯</a></h1>
<hr />
<h3 id="微信公众号"><a class="header" href="#微信公众号">微信公众号</a></h3>
<hr />
<ol>
<li>
<p>清除微信公众号</p>
<blockquote>
<p>找到 文件传输助手, 发送 debugtbs.qq.com, 打开链接，清楚TBS内核，success
<img src="webp/tencent/tbs.webp" alt="tbs" title="tbs" /></p>
</blockquote>
</li>
<li>
<p>头像300*300像素左右</p>
</li>
<li>
<p>页面模板位置
<img src="webp/tencent/page_template.webp" alt="page_template" title="page_template" /></p>
</li>
</ol>
<h3 id="信息"><a class="header" href="#信息">信息</a></h3>
<hr />
<ul>
<li>
<p><a href="https://developers.weixin.qq.com">开放平台</a></p>
</li>
<li>
<p>微信允许手机号转账,不必加好友(支付宝也支持)</p>
</li>
<li>
<p><a href="https://bugly.qq.com/">移动APP集成报告</a></p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
